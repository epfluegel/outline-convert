<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<opml version="2.0">
    <head>
        <title>Arman's GTD Outline </title>
        <flavor>dynalist</flavor>
        <source>https://dynalist.io</source>
        <ownerName>Eckhard</ownerName>
        <ownerEmail>e.pfluegel@gmail.com</ownerEmail>
    </head>
    <body>
        <outline text="Inbox"/>
        <outline text="Projects">
            <outline text="Thesis">
                <outline text="#Example Structure">
                    <outline text="Introduction">
                        <outline text="Motivation and Background "/>
                        <outline text="Aims and Objectives "/>
                        <outline text="Thesis Contributions "/>
                        <outline text="Thesis Structure "/>
                        <outline text="Associated Publications "/>
                    </outline>
                    <outline text="Prelimaries">
                        <outline text="..."/>
                    </outline>
                    <outline text="Cryptographic Schemes">
                        <outline text="..."/>
                    </outline>
                    <outline text="Conclusion ">
                        <outline text="Summary"/>
                        <outline text="Discussion"/>
                        <outline text="Future Work"/>
                    </outline>
                </outline>
                <outline text="Structure">
                    <outline text="Introduction">
                        <outline text="In this document, we will explore the building blocks of cryptographic primitives which enable us to understand the rationale behind various types of cryptographic schemes. We will then examine what applications exist for these particular schemes and also propose novel applications."/>
                    </outline>
                    <outline text="Preliminaries">
                        <outline text="Hard Problems">
                            <outline text="Introduction">
<outline text="Cryptographically viable hard problems tend to be easy to compute and hard to reverse. These are problems that cannot be solved by some algorithm in polynomial time. We will look at these problems and how they are used to construct cryptographic schemes."/>
                            </outline>
                            <outline text="Discrete Logarithm Problem">
<outline text="The Discrete Logarithm Problem is about finding $$k$$ in $$a = b^k$$ which the logarthm $$\log_{b}{a} = k$$. This is a difficult problem whereby the process of directly reversing it requires an efficient algorithm."/>
                            </outline>
                            <outline text="Integer Factorisation">
<outline text="The construction of some cryptographic schemes, such as RSA where the security relies on the product of two relatively prime integers. It is difficult to factorise this composition of integers."/>
                            </outline>
                        </outline>
                        <outline text="Modular Arithmetic in Finite Field">
                            <outline text="These operations are calculated in finite fields where integers are mod $$p$$ where $$p$$ is a prime number."/>
                            <outline text="Addition       - $$[a] + [b] = [a + b \pmod{p}]$$"/>
                            <outline text="Subtraction    - $$[a] - [b] = [a - b \pmod{p}]$$"/>
                            <outline text="Multiplication - $$[a] \times [b] = [ab \pmod{p}] $$"/>
                            <outline text="Greatest Common Divisor">
<outline text="A core aspect of using finite fields is to establish that two integers share no common factors except $$1$$ which is usually used to compare some integer with another prime integer. This is to establish that they are relatively prime, that is, the Greatest Common Divisor (GCD) of these numbers is $$1$$. "/>
<outline text="There are various methods to finding the $$gcd(a, b)$$ but an efficient and well known method is the Euclidean algorithm."/>
                            </outline>
                            <outline text="Extended Euclidean Algorithm">
<outline text="The greatest common divisor may be extended to find the Bézout Identity of the GCD given $$a$$ and $$b$$.">
    <outline text="$$ax + by = gcd(a, b)$$"/>
</outline>
<outline text="When using this algorithm for example, we will find the modular multiplicative inverse of $$a$$ given a prime number $$b$$. The output of this is the GCD with Bézout's Identity $$x$$ and $$y$$ where $$x$$ will be the number we are interested in. The result value $$x$$ is the reciprocal of $$a$$ in the finite field. Therefore:">
    <outline text="$$\frac{1}{a} = x \pmod{p}$$"/>
    <outline text="$$ax \bmod{p} = 1$$"/>
</outline>
<outline text="The other part, $$by \bmod{p} = 0$$ so if gcd$$(a, b) = 1$$ then it is still true that $$ax + by = 1$$"/>
                            </outline>
                            <outline text="Exponentiation">
<outline text="Requires a computationally efficient method such as the Montgomery Reduction. The following is an algorithm by Bruce Schneier which also efficiently reduces the number of calculations. It takes integer $$a$$, exponent $$k$$ and modulus $$p$$."/>
<outline text="**Input**$$($$Integer $$x,$$ Integer $$k,$$ Integer $$p)$$">
    <outline text="**Declare** Integer $$t;$$"/>
    <outline text="**If** $$y = 1$$ **Then**">
        <outline text="**Return** $$x \pmod{p};$$"/>
    </outline>
    <outline text="**If** $$y$$ Bitwise AND $$1 = 0$$ **Then**">
        <outline text="**Compute** $$t = $$ **Input**$$(x, \frac{y}{2}, p);$$"/>
        <outline text="**Return** $$(t \times t) \bmod{p};$$"/>
    </outline>
    <outline text="**Else**">
        <outline text="**Compute** $$t = $$ **Input**$$(x, \frac{y-1}{2}, p);$$"/>
        <outline text="**Compute** $$t = (t \times t) \bmod{p};$$"/>
        <outline text="**Return** $$(t \times x) \bmod{p}$$"/>
    </outline>
    <outline text="**End**"/>
</outline>
                            </outline>
                            <outline text="Division">
<outline text="Division is performed by computing the modular multiplicative inverse."/>
<outline text="Fermat's Little Theorem or Fermat-Euler's Theorem can be used to formulate the reciprocal. This can be proven with Wilson's Theorem. "/>
<outline text="Fermat's Little Theorem states: If $$p$$ is a prime number $$a$$ cannot be divided by $$p$4 then:">
    <outline text="$$a^{p-1} \equiv 1 \pmod{p}$$"/>
</outline>
<outline text="Establishing the modular inverse of $$b$$ in $$a/b$$ or $$ab^{-1}$$ is this:">
    <outline text="$$b^{(p-1)} = 1$$"/>
    <outline text="If $$\frac{1}{b} = b^{-1} \times 1 = b^{-1} \times b^{(p-1)}$$ "/>
    <outline text="Then $$b^{-1} \times b^{(p-1)} = b^{(p-2)}$$"/>
</outline>
<outline text="Alternatively the Extended Euclidean Algorithm can be used to find $$x$$ in $$ax \equiv 1 \pmod{p}$$."/>
                            </outline>
                            <outline text="Generators">
<outline text="A base generator $$g$$ can be used to generate a set of all integers between $$1$$ and $$p - 1$$ by computing $$g^k \bmod{p}$$ for any $$k$$. If $$g$$ cannot generate all integers from $$1$$ to $$p - 1$$, then it is not a generator."/>
                            </outline>
                        </outline>
                        <outline text="Elliptic Curve Point Arithmetic">
                            <outline text="Curve Selection">
<outline text="An elliptic curve is defined as the following where integers $$a, b$$ and prime $$p$$ are parameters.">
    <outline text="$$y^2 = x^3 + ax + b \pmod{p}$$"/>
</outline>
<outline text="Elliptic Curve Cryptography (ECC) is more efficient than RSA because ECC can use smaller key sizes to achieve the same level of security as RSA. For example, 256-bits key for ECC  is equivalent to 3072-bit RSA key. This improves applications that are constrained by limited resources. "/>
<outline text="There are variations of elliptic curves which use different parameters, one application, Bitcoin is known for its use of the Secp256k1 standard."/>
                            </outline>
                            <outline text="Addition">
<outline text="Point addition is an operation which adds two elliptic curve points that exist in the same field and returns a new point."/>
<outline text="**Input**$$($$Point $$A (A_x,A_y),$$ Point $$B (B_x,B_y))$$:">
    <outline text="**If** $$A_x = 0$$ **Then**">
        <outline text="**Return** $$B;$$"/>
    </outline>
    <outline text="**If** $$B_x = 0$$ **Then**">
        <outline text="**Return** $$A;$$"/>
    </outline>
    <outline text="**If** $$A_x = B_x$$ __and__ $$A_y \neq B_y$$ **Then**">
        <outline text="**Return** New Point $$(0, 0);$$"/>
    </outline>
    <outline text="**If** $$A_x \neq B_x$$ **Then**">
        <outline text="**Compute** $$s = \frac{B_y - A_y}{B_x - A_x} \pmod{p};$$"/>
        <outline text="**Compute** $$x = s^2 - A_x - B_x \pmod{p};$$"/>
        <outline text="**Compute** $$y = s \times (A_x - x) - A_y \pmod{p};$$"/>
        <outline text="**Return** New Point $$(x,y);$$"/>
    </outline>
    <outline text="**If** $$A = B$$ __and__ $$A_y = 0$$ **Then**">
        <outline text="**Return** New Point $$(0,0)$$"/>
    </outline>
    <outline text="**If** $$A = B$$ ">
        <outline text="**Compute** $$s = \frac{3 \times (A_x)^2 + a}{2 \times A_y};$$"/>
        <outline text="**Compute** $$x = s^2 - 2 \times A_x;$$"/>
        <outline text="**Compute** $$y = s \times (A_x - x) - A_y;$$"/>
        <outline text="**Return** New Point $$(x, y);$$"/>
    </outline>
    <outline text="**End**"/>
</outline>
                            </outline>
                            <outline text="Multiplication">
<outline text="The Multiplication operation for elliptic curves is adding the point to itself a given number of times, it is a computationally expensive task which is remedied by this binary expansion algorithm. The algorithm has an input point and coefficient which outputs a new point."/>
<outline text="**Input**$$($$Point $$A,$$ Integer $$c)$$:">
    <outline text="**Declare** Point $$S =$$ Point $$A;$$"/>
    <outline text="**Declare** Point $$B$$ $$(0,0);$$"/>
    <outline text="**While** $$c &gt; 0$$ **Do**">
        <outline text="**If** $$c$$ Bitwise AND $$1$$ &gt; 0 **Then**">
            <outline text="**Compute** $$B = B + S;$$"/>
        </outline>
        <outline text="**End**"/>
        <outline text="**Compute** $$S = S + S;$$"/>
        <outline text="**Compute** $$c = c$$ Bitshift RIGHT $$1;$$"/>
    </outline>
    <outline text="**End**"/>
    <outline text="**Return** Point $$B;$$"/>
</outline>
                            </outline>
                            <outline text="Division">
<outline text="Division requires finding the modular multiplicative inverse as discussed in the modular arithmetic section. The operation is performed by taking a Point $$A$$ and a divisor $$d$$ which outputs a new point. It is possible to find the multiplicative inverse with the extended Euclidean algorithm."/>
<outline text="Using Fermat-Euler's theorem will result in this computation:">
    <outline text="Point $$B = \frac{\text{Point } A}{d} = (\text{Point} A) \times d^{-1} \pmod{p}$$ "/>
    <outline text="Point $$B = (\text{Point } A) \times d^{(p-2)} \pmod{p}$$"/>
</outline>
                            </outline>
                        </outline>
                        <outline text="Polynomial Interpolation">
                            <outline text="Although itself not necessarily categorised as a "/>
                            <outline text="Lagrange"/>
                            <outline text="Matrix Inverse"/>
                        </outline>
                    </outline>
                    <outline text="Schemes">
                        <outline text="Signature Schemes">
                            <outline text="Introduction">
<outline text="Cryptographic method of verifying the authenticity messages. Digitally signed messages that are altered will become invalid, furthermore the message sender cannot disprove their authorship."/>
                            </outline>
                            <outline text="Schnorr">
<outline text="Schnorr's signature scheme is an interactive protocol which requires both parties to exchange some uniformly chosen random integer and takes advantage of the properties given by multiplying two values that have been exponentiated in a finite field."/>
<outline text="This scheme attempts to check the correctness of $$g^y \times (g^x)^c = g^{y+cx}$$ where $$y+cx$$ may be computed as integer $$z \therefore g^z = g^y \times (g^x)^c$$. "/>
<outline text="Preprocessing">
    <outline text="Prime $$p$$, Generator $$g$$, Secret $$x$$"/>
    <outline text="$$X = g^x \bmod{p}$$"/>
    <outline text="Public Key  $$(p, g, X)$$"/>
    <outline text="Private Key $$(p, x)$$"/>
</outline>
<outline text="Protocol" listStyle="arabic">
    <outline text="Prover computes Y and sends it to Verifier">
        <outline text="Select random value $$y$$."/>
        <outline text="Compute $$Y = g^y \bmod{p}$$"/>
    </outline>
    <outline text="Verifier selects random value $$c$$ and sends to Prover">
        <outline text="Select random value $$c$$."/>
    </outline>
    <outline text="Prover computes $$z$$ and sends to Verifier">
        <outline text="$$z = y + cx \bmod{p}$$"/>
    </outline>
    <outline text="Verifier attempts to validate Prover inputs">
        <outline text="Check that $$g^z = YX^c \pmod{p}$$"/>
    </outline>
</outline>
<outline text="$$YX^c = g^y \times (g^x)^c = g^y \times g^{cx} = g^{(y+cx)}$$"/>
<outline text="$$g^z = g^{(y + cx)}$$"/>
                            </outline>
                            <outline text="ElGamal">
<outline text="Preprocessing">
    <outline text="Prime $$p$$, Generator $$g$$"/>
    <outline text="Uniformly Random Secret $$x \in \{1,...,p-1\}$$ "/>
    <outline text="$$y = g^x \bmod{p}$$"/>
    <outline text="Public Key  $$(p,g,y)$$"/>
    <outline text="Private Key $$(x)$$"/>
</outline>
<outline text="Protocol" listStyle="arabic">
    <outline text="Prover hashes message $$m$$ and sends $$(r,s)$$">
        <outline text="Select uniformly random integer $$k \in \{2,...,p-2\}$$ where $$gcd(k, p-1) = 1$$"/>
        <outline text="$$r = g^k \bmod{p}$$"/>
        <outline text="$$s = (\text{Hash}(m) - xr)k^{-1} \bmod{p-1}$$ where $$k^{-1}$$ is the modular multiplicative inverse and $$s \neq 0$$."/>
    </outline>
    <outline text="Verifier attempts to validate Prover inputs">
        <outline text="Check that $$g^{\text{Hash}(m)} \equiv y^r r^s \pmod{p}$$"/>
    </outline>
</outline>
<outline text="The correctness of this scheme is evident by looking at the formulation of $$s$$:">
    <outline text="$$s \equiv \frac{\text{Hash}(m)-xr}{k}$$"/>
    <outline text="$$sk \equiv$$ Hash$$(m)-xr$$"/>
    <outline text="$$xr + sk \equiv \text{Hash}(m)$$"/>
    <outline text="$$g^{xr + sk} \equiv g^{\text{Hash}(m)}$$"/>
    <outline text="$$g^{xr} \times g^{sk} = (g^x)^r \times (g^k)^s = y^r \times r^s$$"/>
</outline>
                            </outline>
                            <outline text="Ring Signature"/>
                        </outline>
                        <outline text="Commitments">
                            <outline text="Pedersen Commitment">
<outline text="Preprocessing">
    <outline text="Prime $$p$$, Generator $$g$$, Secret $$s$$"/>
    <outline text="Shared Value $$h = g^s \bmod{p}$$"/>
</outline>
<outline text="Protocol" listStyle="arabic">
    <outline text="Prover computes commitment $$c$$ using message $$m$$ and sends $$c$$ to Verifier.">
        <outline text="Select Uniformly Random Integer $$r$$"/>
        <outline text="$$c = g^m h^r \bmod{p}$$"/>
    </outline>
    <outline text="Verifier can check the correctness of $$c$$ after receiving $$m$$ and $$r$$ from the Prover.">
        <outline text="$$\hat c = g^m h^r \bmod{p}$$"/>
        <outline text="Check that $$\hat c = c$$"/>
    </outline>
</outline>
                            </outline>
                        </outline>
                        <outline text="Zero-Knowledge Proofs">
                            <outline text="Fiat-Shamir Non-Interactive Identity Scheme">
<outline text="Preprocessing">
    <outline text="Generator $$g$$, Prime $$p$$, Alleged Common Value $$x$$"/>
    <outline text="Prover and Verifier Compute $$y = g^x \bmod{p}$$ with their own knowledge of $$x$$."/>
</outline>
<outline text="Protocol" listStyle="arabic">
    <outline text="Prover computes a pair of values $$(r,c)$$ for the verifier to check">
        <outline text="$$t = g^v \bmod{p}$$"/>
        <outline text="$$c = \text{Hash}(g || y || t)$$"/>
        <outline text="$$r = v - cx \bmod{p-1}$$"/>
    </outline>
    <outline text="Verifier checks the correctness of $$(r,c)$$">
        <outline text="$$\hat t = g^r y^c \bmod{p}$$"/>
        <outline text="$$\hat c = \text{Hash}(g || y || t)$$"/>
        <outline text="Check that $$\hat c = c$$"/>
    </outline>
</outline>
                            </outline>
                        </outline>
                        <outline text="Elliptic Curve">
                            <outline text="ECDSA"/>
                            <outline text="EC-VOPRF"/>
                        </outline>
                        <outline text="Secret Sharing">
                            <outline text="Shamir Secret Sharing"/>
                            <outline text="Blakley Secret Sharing"/>
                            <outline text="Herzberg et al. Proactive Shares"/>
                            <outline text="Shah et al. Share Dissemination"/>
                        </outline>
                        <outline text="Homomorphic">
                            <outline text="Paillier Encryption"/>
                        </outline>
                    </outline>
                    <outline text="Applications">
                        <outline text="Contemporary Applications"/>
                    </outline>
                    <outline text="Paper #1"/>
                    <outline text="Paper #2"/>
                    <outline text="Paper #3">
                        <outline text="???Threshold Ring Signatures???"/>
                    </outline>
                </outline>
            </outline>
            <outline text="Presentations">
                <outline text="MPhil Upgrade #section">
                    <outline text="Introduction #slide ">
                        <outline text="Cyber world has made information to be a critical asset for organisations and criminals alike. Whether it is in the healthcare, finance or energy sector."/>
                        <outline text="There exists legal constraints on disclosing information between different departments. "/>
                        <outline text="This project is focused on `signalling' cyber intelligence as a way to establish common knowledge without a disclosure of sensitive information."/>
                        <outline text="![magnet](https://i.imgur.com/mMnwCXL.png)"/>
                    </outline>
                    <outline text="Evidence Signalling #slide">
                        <outline text="No existing platform exists that cryptographically aids `signalling' cyber intelligence. The literature will outline some techniques."/>
                        <outline text="These will be relevant to some contributions:">
                            <outline text="Published framework for anti-money laundering"/>
                            <outline text="Cyber Intelligence Concurrence Framework"/>
                            <outline text="Extending the functionality of a Secret Sharing Scheme"/>
                            <outline text="![img](https://i.imgur.com/5U76yYA.png)"/>
                        </outline>
                    </outline>
                    <outline text="Aims &amp; Objectives #slide">
                        <outline text="Aim is to design a robust framework that allows parties to find some information in common whilst maintaining confidentiality and integrity."/>
                        <outline text="Objectives:">
                            <outline text="To devise the concept for cyber evidence signalling and apply them in scenarios (e.g. finance or evidence sharing)."/>
                            <outline text="To identify suitable cryptographic methods for implementation."/>
                            <outline text="To evaluate the systems in order to demonstrate their efficacy."/>
                        </outline>
                    </outline>
                    <outline text="Literature #slide">
                        <outline text="In order to meet the confidentiality requirements in an intrinsic and fundamental manner, the literature outlines various cryptographic schemes."/>
                        <outline text="These are related to the contributions to date (evidence signalling frameworks and secret sharing extension)."/>
                        <outline text="Literature includes cryptographic primitives and algorithms, zero-knowledge proofs, public key schemes and secret sharing schemes."/>
                        <outline text="![bruce_schneier](https://i.imgur.com/lNPtP5h.jpg)"/>
                    </outline>
                    <outline text="Primitives #slide">
                        <outline text="Security based on usage of prime numbers with modulo operator. ">
                            <outline text="$$x^a \pmod{p}$$ which takes advantage of the Discrete logarithm problem."/>
                        </outline>
                        <outline text="Modular arithmetic operators (addition, multiplication, exponentiation, multiplicative inverse)."/>
                        <outline text="This extends to Elliptic Curve points with similar operators.">
                            <outline text="$$y^2 = x^3 + ax + b \pmod{p}$$"/>
                        </outline>
                        <outline text="![legos](https://i.imgur.com/19ict4S.png)"/>
                    </outline>
                    <outline text="ZKP #slide">
                        <outline text="Zero-Knowledge Proofs are a type of protocol that can prove some information without revealing said information. This protocol involves a Prover and Verifier."/>
                        <outline text="This is an improvement of hash functions where entropy produces a different output for the same input as output and it is less complex than signature schemes with fewer modular multiplications. "/>
                        <outline text="ZKPs are designed to be protective against forgery in proving some identity or authenticity of messages."/>
                        <outline text="Some ZKP schemes mentioned are Interactive / Non-Interactive Fiat-Shamir Heuristic and ZK-SNARKs."/>
                    </outline>
                    <outline text="Elliptic Curves #slide">
                        <outline text="EC was proposed independently by Neal Koblitz and Victor Miller, popularised by cryptocurrencies (Bitcoin) for the smaller key sizes.">
                            <outline text="2048 bits for RSA is equivalent to 223 bits for EC."/>
                            <outline text=", works by adding together points."/>
                        </outline>
                        <outline text="Is used for setting up trust in networks with private and public keys."/>
                        <outline text="Schemes include digital signatures, blind verification and alternative to modular exponentiation (Diffie-Hellman, RSA)."/>
                        <outline text="![!paint](https://i.imgur.com/SsTIGMz.png)"/>
                    </outline>
                    <outline text="Secret Sharing #slide">
                        <outline text="Secret Sharing is splitting up some information into $$n$$ pieces (shares) so that a threshold $$t$$ of those shares can recover this information."/>
                        <outline text="Popular early scheme is Shamir's Secret Sharing Scheme (also Blakley) to produce shares ($$f(0)$$ is the secret):">
                            <outline text="$$f(x) = \displaystyle\sum_{i=0}^{k-1} a_i \cdot x^i \pmod{p}$$"/>
                        </outline>
                        <outline text="Can use Lagrange interpolation or matrix inverse to recover $$f(0)$$."/>
                        <outline text="Other schemes increase functionality of the scheme:">
                            <outline text="Proactive - Herzberg et al."/>
                            <outline text="Dissemination - Shah et al."/>
                        </outline>
                        <outline text="![treasure-map](https://i.imgur.com/QCKpXad.png)"/>
                    </outline>
                    <outline text="Research Contributions #slide">
                        <outline text=""/>
                    </outline>
                    <outline text="Money Laundering Framework #slide"/>
                    <outline text="Cyber Intelligence Concurrence #slide"/>
                    <outline text="Extending Shah Secret Sharing Scheme #slide"/>
                    <outline text="Conclusion #slide"/>
                </outline>
                <outline text="CySec 2020 #h ">
                    <outline text="Title #slide">
                        <outline text="A Secure Framework for Anti-Money-Laundering using Machine Learning and Secret Sharing"/>
                    </outline>
                    <outline text="Introduction #slide">
                        <outline text="Money Laundering in the UK is still not accurately estimated by the UK Gov E.Fell, (O.James, N.Shah and J.Grimshaw. &quot;Understanding Organismed Crime 2015/16&quot;)"/>
                        <outline text="Funds may be transferred multiple time in a burst pattern to varying accounts in smaller fragments."/>
                        <outline text="KYC (Know Your Customer) policies or procedures employed by banks to verify the identity of customers. "/>
                    </outline>
                    <outline text="Literature Review #slide">
                        <outline text="Existing advances in the domain of: ">
                            <outline text="The detection of suspicious transactions"/>
                            <outline text="The detection of entities that may be associated with money laundering.">
<outline text="(G.Leite, A.Alburquerque and P.Pinheiro &quot;Application of Technological Solutions in the Fight Against Money Laundering - A Systematic Literature Review&quot;  2019)"/>
                            </outline>
                        </outline>
                        <outline text="Various Machine-Learning techniques (testing accuracy rate, computational performance, reinforced learning)"/>
                    </outline>
                    <outline text="Issues Identified #slide" listStyle="arabic">
                        <outline text="Data availability and format">
                            <outline text="(Missing values, data types, non-disclosure)"/>
                            <outline text="(M.Brown and J.Kros &quot;Data Mining and the impact of missing Data 2003&quot;)"/>
                        </outline>
                        <outline text="Privacy laws and ethical codes">
                            <outline text="(Inhibiting sharing of information, attributing to the first issue)"/>
                        </outline>
                        <outline text="Computational Peformance">
                            <outline text="(Reasonable time complexity to classify transactions or determine suspicious activity. Using real-time analysis or exported dataset?)"/>
                        </outline>
                    </outline>
                    <outline text="Related Work #slide">
                        <outline text="Machine-Learning Techniques">
                            <outline text="Success rates"/>
                            <outline text="Processing time"/>
                            <outline text="Reinforcement learning efficiency"/>
                        </outline>
                        <outline text="Forensic Analysis">
                            <outline text="More customised/old-fashioned approach"/>
                        </outline>
                    </outline>
                    <outline text="Where do we fit in the gap? #slide">
                        <outline text="Collaboration - Literature review finds a lack of collaboration and aggregation of data from multiple banks."/>
                        <outline text="Cryptography - Mentioned once in systematic review source and not used as a forefront."/>
                        <outline text="Result sharing - Technique to deliver outcome of analysis back to banks."/>
                    </outline>
                    <outline text="Proposed System Design">
                        <outline text="Banks send encrypted transactions to an Auditor."/>
                        <outline text="Auditor analyses completely anonymous information with machine learning."/>
                        <outline text="Auditor produces a Suspicious Activity Report (SAR) and splits it up into 'shares' for the banks to recover."/>
                    </outline>
                    <outline text="Phase 1 - SIGNALLING to the Auditor">
                        <outline text="Each bank converts their respective transaction into a redacted/encrypted format."/>
                        <outline text="The Auditor and any other party is not authorised to read plaintext transaction data. Amount and timestamp is not redacted."/>
                        <outline text="The banks involved in the same transaction send a &quot;pairwise&quot; signal to the Auditor."/>
                        <outline text="Fig 2."/>
                        <outline text="AES SIV"/>
                    </outline>
                    <outline text="Phase 2 - ML DETECTION">
                        <outline text="The Auditor organises relationship with received information as trees of transactions."/>
                        <outline text="Fig 3."/>
                        <outline text="Binary classification algorithm determines relevant transaction as either suspicious or not."/>
                        <outline text="Bundle together transactions and respective probability of Money Laundering into an SAR."/>
                    </outline>
                    <outline text="Phase 3 - SAR FEEDBACK">
                        <outline text="The Auditor splits up the SAR into shares and send them to the banks via Shamir Secret Sharing."/>
                        <outline text="The banks co-operate to recover the SAR."/>
                        <outline text="Secret Sharing Notation"/>
                    </outline>
                    <outline text="Preliminary Evaluation">
                        <outline text="Prototype implementation of the 3 phases"/>
                        <outline text="Fast Tree binary classifcation">
                            <outline text="(Dataset produced with various derivatives of transaction properties such as time, relationships (e.g. transaction children) and amount.)"/>
                        </outline>
                    </outline>
                    <outline text="Conclusion">
                        <outline text=""/>
                    </outline>
                </outline>
                <outline text="CySec 2022 #h">
                    <outline text="Efficient Cyber-Evidence Sharing using Zero-Knowledge Proofs"/>
                    <outline text="Introduction #h">
                        <outline text="Introduction #slide">
                            <outline text="We propose a scheme that allows participants to establish mutual information using existing methods. We combine merkle trees and zero-knowledge proofs so that organisations may "/>
                        </outline>
                        <outline text="Background">
                            <outline text="We define cyber evidence sharing as the task of verifying mutual knowledge of confidential info or digital evidence without disclosure."/>
                            <outline text="We propose to use cryptography using openly published security solutions, specifically Zero-Knowledge Proofs (ZKP)."/>
                            <outline text="The method of constructing this proof system is not complex  and does not require specialist knowledge in order to be implemented correctly."/>
                        </outline>
                        <outline text="Overview">
                            <outline text="[Simple overview diagram]"/>
                        </outline>
                        <outline text="Previous Work">
                            <outline text="Solutions for sharing cyber evidence legally does not use any cryptographic means."/>
                            <outline text="Some examples include:">
<outline text="LISTSERV, Information Sharing and Analysis Centers (ISACs), Information Sharing and Analysis Organizations (ISAOs) "/>
                            </outline>
                        </outline>
                    </outline>
                    <outline text="Components #h">
                        <outline text="Merkle Trees">
                            <outline text="Binary Tree used as efficient representation of data structure used for comparison. "/>
                            <outline text="We assume most blocks are the same where the efficiency of finding a difference is $$\mathcal{O}(\log_2(n))$$ for $$n$$ depth of binary tree."/>
                            <outline text="Node hashes are replaced with ZKP Proofs, shown shortly."/>
                        </outline>
                        <outline text="ZKP Instead of Hashes">
                            <outline text="ZKPs is a way of proving something to a verifier without disclosing information. A proof is generated and the verification process will output either true or false."/>
                            <outline text="Uses uniformly random value to generate different output proofs for the same input."/>
                            <outline text="Three Main Aspects:">
<outline text="Zero-Knowledgness - Confidentiality is kept for the information that needs to be proved."/>
<outline text="Completeness - The verifier will have confidence that the prover knows the information that they didn't reveal."/>
<outline text="Soundness - There cannot be an instance where false information can be verified."/>
                            </outline>
                            <outline text="[DIAGRAM PROVER TO VERIFIER]"/>
                        </outline>
                        <outline text="CreateProof()">
                            <outline text="Prover wants to prove knowledge $$x$$ that the Verifier knows but both parties did not disclose (they begin by computing $$y = g^x \bmod{p}$$ for some prime $$p$$). "/>
                            <outline text="Prover computes:">
<outline text="$$t = g^v \bmod{p}$$"/>
<outline text="$$c = \text{Hash}(g,y,t)$$"/>
<outline text="$$r = v - cx \bmod{p}$$"/>
                            </outline>
                            <outline text="The prover sends the proof as values $$r$$ and $$c$$ to the verifier."/>
                        </outline>
                        <outline text="Verify()">
                            <outline text="The Verifier will use $$r$$ and $$c$$ from the prover to have confidence the prover knows $$x$$."/>
                            <outline text="Verifier computes:">
<outline text="$$\hat t = g^r \times y^c \pmod{p}$$"/>
<outline text="$$\hat c = \text{Hash}(g,y,t)$$"/>
                            </outline>
                            <outline text="The verifier will check if $$\hat c == c$$, both parties share the same $$x$$ value if this is true."/>
                        </outline>
                    </outline>
                    <outline text="Scheme #h ">
                        <outline text="Design">
                            <outline text=""/>
                        </outline>
                        <outline text="Protocol">
                            <outline text="[DETAILED DIAGRAM]"/>
                        </outline>
                        <outline text="Implementation"/>
                    </outline>
                    <outline text="Results #h">
                        <outline text="Fiat-Shamir Non-Interactive Scheme Performance"/>
                        <outline text="Linear List vs Merkle Tree"/>
                    </outline>
                    <outline text="Related Work">
                        <outline text="Potentially, ZK-SNARKs "/>
                    </outline>
                    <outline text="Conclusion #h"/>
                </outline>
                <outline text="Cyber Evidence Signalling : An approach using Anonymous Authentication and Zero-Knowledge Proofs">
                    <outline text="Notes:">
                        <outline text="Not about detection of sifting through data"/>
                        <outline text="Slide on case-study / scenario e.g. someone could cheat here"/>
                        <outline text="Slide on knowledge-proofs"/>
                        <outline text="Signalling Data">
                            <outline text="Hashes give computational security, revisit Confidence"/>
                        </outline>
                    </outline>
                    <outline text="Evidence Signalling #slide">
                        <outline text="The aim of this project is to design a robust framework that allows parties that don't trust each other to find some information in common. "/>
                        <outline text=""/>
                        <outline text="Which the current situation is not a cryptographically aided approach which saves time and resources by not being a lengthy interactive human process. Moreover, the framework would aim to have certain properties such as Anonymity and Trust (although contradictory), to encourage to have confidence in using framework."/>
                        <outline text="Objectives:">
                            <outline text="To outline the framework's top-down structure."/>
                            <outline text="To elicit security requirements of such framework."/>
                            <outline text="To identify and use cryptographic methods to achieve security goals."/>
                        </outline>
                    </outline>
                    <outline text="What is Evidence Signalling #slide">
                        <outline text="A bank and law enforcement agency have some mutual information."/>
                        <outline text="Both parties do not trust each other enough to share what they have."/>
                        <outline text="This communication between the two parties should not allow them to identify each other."/>
                        <outline text="One party should send a 'signal', which this 'signal' allows the other party to find matching data."/>
                        <outline text="This signal however, does not allow the other party to learn any more information."/>
                        <outline text="After finding data in common, anonymous parties may reveal identities to pursue more open communication."/>
                    </outline>
                    <outline text="What Evidence Signalling Isn't #slide ">
                        <outline text="The detection of mutual information is not about finding correlations in different sets of data. It is about letter by letter matching."/>
                        <outline text=""/>
                    </outline>
                    <outline text="Security Considerations #Slide">
                        <outline text="Ideal requirements">
                            <outline text="Resistance to Active / Passive MITM"/>
                            <outline text="Resistance to Offline / Online Dictionary (Computational Non-Perfect Soundness)"/>
                            <outline text="Forward Secrecy (Secure disclosed session key)"/>
                            <outline text="Known Session (Disclosed session doesn't affect other sessions)"/>
                        </outline>
                    </outline>
                    <outline text="Framework Components #slide" listStyle="arabic">
                        <outline text="Anonymous Authentication">
                            <outline text="Anonymity gained by unlinkability of information. "/>
                            <outline text="Authentication gained by ability to verify messages are from a trusted source."/>
                        </outline>
                        <outline text="Signalling Data">
                            <outline text="Initiating party sends a schema signalled data and must be agreed upon."/>
                            <outline text="Data is converted as Zero-Knowledge Proofs."/>
                            <outline text="Party receiving the signal will attempt to verify signal."/>
                        </outline>
                        <outline text="Reveal Identity">
                            <outline text="Reveal Identity with Certificate (Sign a challenge with private key)"/>
                        </outline>
                    </outline>
                    <outline text="Trusted Third Party Network Solution #slide">
                        <outline text="Functions">
                            <outline text="TTP can act as group manager and certificate authority."/>
                            <outline text="Relay communication between entities."/>
                        </outline>
                        <outline text="Advantages">
                            <outline text="Confidence in trust by using PKI."/>
                            <outline text="Clients only communicate to server."/>
                        </outline>
                        <outline text="Disadvantages">
                            <outline text="Authority knows others' identity."/>
                            <outline text="Single point of failure."/>
                        </outline>
                    </outline>
                    <outline text="Anonymous Authenticaton #slide">
                        <outline text="Anonymous Authentication may also be done without relaying to a centralised server.">
                            <outline text="Reminder: Parties cannot be identified from exchanged information although must be authenticated."/>
                            <outline text="Anonymity gained with untraceability -- making messages unlinkable between entities.">
<outline text="Onion Routing, Dandelion++, "/>
                            </outline>
                            <outline text="Authentication with Public Key Schemes">
<outline text="Key Agreement Protocols (SRP, J-PAKE), Group Signatures..."/>
                            </outline>
                        </outline>
                    </outline>
                    <outline text="Signalling Data #slide">
                        <outline text="Parties agree on structure and properties of data to exchange."/>
                        <outline text="Zero-Knowledge Proofs (ZKP) can be used as a stochastic one-way trap door function to map data. (e.g. Fiat-Shamir, ZK-SNARK)"/>
                        <outline text="Schemes involves Peggy (Prover i.e. Bank) and Victor (Verifier i.e. Police)."/>
                        <outline text="The result computed by Victor is either true or false that some knowledge is in common. A callback is done on true results to inform the Peggy."/>
                        <outline text="https://blog.ethereum.org/2016/12/05/zksnarks-in-a-nutshell/"/>
                    </outline>
                    <outline text="Zero-Knowledge Proofs #slide">
                        <outline text="Peggy and Victor share some knowledge $$x$$ which they do not know they share, for which Peggy wants to prove to victor she knows $$x$$."/>
                        <outline text="Peggy computes a proof using a special function that takes a random number and $$x$$."/>
                        <outline text="Victor computes a challenge based on his $$x$$ and the received proof from Peggy."/>
                        <outline text="If the challenge matches what Peggy has sent, then indeed they share the knowledge of $$x$$."/>
                        <outline text="The benefits of ZKP over hashes:">
                            <outline text="Added Entropy"/>
                            <outline text="Accurate Convincing Results"/>
                            <outline text="Simple Method"/>
                            <outline text="Won't learn more than true or false"/>
                        </outline>
                    </outline>
                    <outline text="Reveal Identity #slide">
                        <outline text="Drop Anonynmous Authentication for Identified Authentication."/>
                        <outline text="Proof of identity can be exchanged in order to proceed with more open communication"/>
                        <outline text="Public Key Signature Scheme can be used to create a proof of identity."/>
                        <outline text="Commitments of identity sent earlier and revealed at this stage."/>
                    </outline>
                    <outline text="Summary #slide">
                        <outline text="We propose a novel scheme based on Anonymous Authentication to implement cyber signalling."/>
                        <outline text="Three distinct components of the framework that each require certain cryptographic primitives."/>
                        <outline text="Implementation of framework to accompany paper."/>
                    </outline>
                </outline>
            </outline>
            <outline text="Investigations" listStyle="arabic">
                <outline text="Evidence Signalling Framework">
                    <outline text="Points">
                        <outline text="The Cyber Evidence Signalling project is pursuing the development of a framework for different parties to `signal' to each other that they have some mutual information."/>
                        <outline text="The signalling part requires parties to agree on a schema or set of rules that dictate the format of data e.g. whether to hide labels like `first name` and `last name` as well as their corresponding values `John`, `Smith`."/>
                        <outline text="The framework would also need to facilitate the verification of data from anonymous sources."/>
                        <outline text="When parties find some mutual information, it is within the scope to get an actionable entity to begin making steps towards more open communication."/>
                    </outline>
                    <outline text="Incorporate Money Laundering Paper">
                        <outline text="Proper implementation"/>
                    </outline>
                </outline>
                <outline text="Matrix based Bivariate Secret Sharing Scheme">
                    <outline text="Clarifications">
                        <outline text="Security of the scheme">
                            <outline text="From information theoretical point of view:"/>
                            <outline text="Is it ramp, ideal, etc.."/>
                        </outline>
                        <outline text="How does it compare to published work /novelty"/>
                    </outline>
                    <outline text="Revisit examples for correctness of the scheme"/>
                </outline>
                <outline text="Extension of Shah (Herzberg et al.)">
                    <outline text="Shah adding nodes"/>
                    <outline text="Application for Shah Dissemination"/>
                    <outline text="Proactive Secret Sharing (Herzberg)"/>
                </outline>
            </outline>
            <outline text="Papers [Ongoing]">
                <outline text="An Efficient Novel Protocol for Cyber EvidenceSharing using Anonymous Zero-Knowledge Proofs">
                    <outline text="ZKP Merkle Tree Proposal #h ">
                        <outline text="Related Work">
                            <outline text="Merkle Trees">
<outline text="Generally used as an efficient data structure comparison of $$O(\log_{2}(n))$$ assuming that most of the data blocks are the same. A popular use case is crypto-currency transaction blocks being represented as Merkle Trees. Cryptographic hash function such as SHA256 or higher are used and often times double hash the value."/>
                            </outline>
                        </outline>
                        <outline text="Scheme">
                            <outline text="The use of the Merkle Tree is used in the same conventional way of detecting differences in some data structure efficiently. Firstly, the hashes give a degree of privacy of the data being compared however it is possible to perform a pre-image attack, second pre-image attack and finding collisions. "/>
                            <outline text="With Merkle Trees, we assume that participants already have knowledge of $$x$$ in Hash$$(x)$$ and can use this knowledge to find changes in a hash e.g. $$x+y$$ in Hash$$(x+y)$$."/>
                            <outline text="We propose to use a Random Oracle ZKP Scheme to enhance the security and privacy of Merkle trees. By replacing hashes with proofs, an attacker will not have a target hash, this is because the proof will not reveal any information about the original hash it was derived by."/>
                        </outline>
                        <outline text="Scheme Example">
                            <outline text="Departments share records of some customers e.g. in a bank."/>
                            <outline text="An anonymising and trusted central server relays communication between the departments.">
<outline text="The server computes the Merkle Tree of the records and convert the hashes into Zero-Knowledge Proofs. "/>
<outline text="The participants will use this tree of ZKP to verify mutual information and find data blocks that have changed."/>
<outline text="For all data blocks that aren't verifiable (ZKP Verification returns False), the participants enter a dialogue to establish mutual knowledge of any subset information. "/>
                            </outline>
                        </outline>
                        <outline text="Scheme Issue">
                            <outline text="Instead of checking for the same hash, there will be a verify function, Verify(hash) which returns True or False. An entity using this function can still try multiple inputs in order to brute force a True return.">
<outline text="One solution is to pad the input with some uniformly random chosen value that is unique to the proof. This will make it more difficult for an attack to try and find a collision."/>
<outline text="Another solution is to make some trusted authority the verifier, effectively outsourcing the verification computation which will control the number of attempts an entity can use the verify function."/>
                            </outline>
                        </outline>
                        <outline text="Key Concepts">
                            <outline text="Black Box">
<outline text="A system or object that is understood from its inputs and outputs without knowledge of inner functions."/>
                            </outline>
                            <outline text="Oracle">
<outline text="Oracle is some entity that acts as a black box where it is able to provide a solution for any given problem."/>
                            </outline>
                            <outline text="Random Oracle">
<outline text="A black box that for every unique input, a uniformly random output is chosen. Repeating the same input will respond in the same i.e. another uniformly random chosen output."/>
                            </outline>
                            <outline text="Pre-Image Attack">
<outline text="Given $$y$$, find $$x$$ where Hash$$(x) = y$$."/>
                            </outline>
                            <outline text="Second Pre-Image Attack">
<outline text="Given $$x$$, find $$\hat x \neq x$$ where Hash$$(x) = $$ Hash$$(\hat x)$$."/>
                            </outline>
                            <outline text="Collision Attack">
<outline text="Given $$x$$ and $$y$$, find Hash$$(x) =$$ Hash$$(y)$$."/>
                            </outline>
                        </outline>
                        <outline text="Assumptions #h">
                            <outline text="Computational Security, Hash Functions are not invertible (SHA3)."/>
                            <outline text="Changes in datablocks are not trivial, e.g. use of padding."/>
                            <outline text="Merkle Tree is shared between parties and distributed by authority.">
<outline text="Parties can compute sha3 of datablocks and send to authority. Authority can then pad the hashes with random values and hash again. The result is put into a Merkle tree and distributed."/>
                            </outline>
                        </outline>
                        <outline text="archive">
                            <outline text="Scheme">
<outline text="Use Merkle Tree to detect differences between some data"/>
<outline text="Detected changes are followed up with ZKP protocol to determine any similarities">
    <outline text="Example:">
        <outline text="Departments share records of some customers e.g. in a bank">
            <outline text="Both departments note some suspicious activity in their own way">
                <outline text="This is recorded in the customer records"/>
            </outline>
            <outline text="Merkle Trees are updated and redistributed and participants check new differences starting from the root">
                <outline text="If there is a change, a party is notified and will have to check down the tree and find the node that has changed."/>
            </outline>
            <outline text="For each difference, participants enter a ZKP Protocol to prove if they share some knowledge in those differing nodes.">
                <outline text="A participant can establish mutual knowledge of the characteristics of the suspicious customer."/>
                <outline text="In order to prevent a participant from attempting to have multiple guesses in the ZKP Protocol, the notified participant must be a prover and the original notifier is the verifier."/>
            </outline>
        </outline>
    </outline>
</outline>
                            </outline>
                        </outline>
                    </outline>
                </outline>
                <outline text="Evidence Signalling Framework ">
                    <outline text="Content">
                        <outline text="Introduction">
                            <outline text="Context">
<outline text="World of cyber space has made information to be a  critical asset for organisations and criminals alike. Whether it is in the healthcare, finance or energy sector."/>
<outline text="There exists legal constraints on disclosing information between different departments. It may be beneficial to evaluate whether two or more entities have some information in common. This would allow these entities to co-operate on the same level without having to reveal said information. "/>
<outline text="The ability to establish mutual information without disclosure can be done with a centralised authority that relays messages to provide privacy. These messages are part of a protocol between a prover and verifier of some potentially mutual knowledge. The role of the verifier will produce a form that prompts provers with some queries to prove. The provers will then convert their answers into ZKPs (Zero Knowledge Proofs)."/>
                            </outline>
                            <outline text="What is Cyber Evidence Signalling; what is Signalling?">
<outline text="This project is focused on ‘signalling’ cyber intelligence as a way to establish common knowledge without a disclosure of sensitive information."/>
<outline text="Definition: __Signals are electronic messages which do not disclose sensitive information.__"/>
                            </outline>
                            <outline text="Contributions">
<outline text="Framework is a Security Architecture. This is then used to create an example Evidence Signalling Application. We propose to use existing Zero-Knowledge Proofs which provide some benefits of hash functions. Namely, proving some information that no one else can prove, that is even someone that can verify the information cannot also prove it. This is combined into a security architecture that support the means to have a system in which entities can find undisclosed information in common. Henceforth we outline a communication protocol and provide a proof-of-concept application to evaluate and discuss."/>
                            </outline>
                        </outline>
                        <outline text="Existing Literature">
                            <outline text="Principle">
<outline text="The literature described brings forth the language and concepts that are critical in the our proposed architecture. By building this security architecture, it is possible to create Evidence Signalling applications. Hash algorithms have been a versatile tool in security however lack additional measures to give confidence that information came from an authorised entity and critical communication isn't forged. Here we explore some key concepts such as public key cryptography, commitments and zero-knowledge proofs which permit the framework to meet the security requirements."/>
                            </outline>
                            <outline text="Schemes">
<outline text="Hash Algorithms">
    <outline text="Hash Functions">
        <outline text="Hash functions have many applications where a user is challenged to prove some information and the verifier doesn't necessarily require to know this original information in any capacity. This is seen in checksums, error-correction, cryptography and fingerprinting. "/>
        <outline text="With regards to evidence signalling, it may be obvious to use hash functions to fingerprint some information. Hash functions provide a degree of security where it is not feasible to directly reverse the output back to its input.  Aside from dictionary attacks, hashes do not guarantee that the output was computed by an authenticated entity. In this regard it may be combined with public key schemes."/>
    </outline>
    <outline text="Hash Chains / Merkle Tree"/>
    <outline text="Further Usage">
        <outline text="Hash functions with the benefits discussed are used as part of more complex cryptographic schemes such as signatures and zero-knowledge proofs. "/>
    </outline>
</outline>
<outline text="Public Key Cryptography">
    <outline text="Although RSA has been a popular public key system, the advent of Bitcoin has shown the effectiveness of Elliptic Curves which provide the same security for a smaller key size. Hence less bits are required to store and communicate which is critical for cryptocurrencies that have public distributed ledgers. Moreover, public keys can be used for anonymous authentication "/>
</outline>
<outline text="Commitments">
    <outline text="Commitments allow some entity to commit some encrypted information and then reveal whilst simultaneously verifying the correctness of the commitment. The Pedersen Commitment scheme can perform this task using the Discrete Logarithm Problem. Moreover, a source of entropy is used to give unique commitments for all the same input values. "/>
    <outline text="This can be used to commit some identity in the form of a public key or simply some string identifier."/>
    <outline text="[~] Pedersen Commitment"/>
</outline>
<outline text="Zero-Knowledge Proofs">
    <outline text="An early development of ZKP [1] was motivated by the necessity of having stronger security against forgery. It is derived from signature schemes and it introduces three distinctions in ZKPs:">
        <outline text="Authentication – A can prove to B that he is A, but someone else cannot prove to B that he is A."/>
        <outline text="Identification – A can prove to B that he is A, but B cannot prove to someone else that he is A."/>
        <outline text="Signature schemes – A can prove to B that he is A, but B cannot prove even to himself that he is A."/>
    </outline>
    <outline text="Furthermore it proposes a simple identification and signature scheme which can be used to prove identity and authenticity of messages without sharing public keys. This assumes there is a trusted centre that has already given some information to users beforehand whilst verifying their identity. "/>
    <outline text="The Fiat-Shamir Random Oracle scheme is ideal for this framework due to the following properties:">
        <outline text="Secret common value is encrypted with the hard problem of modular exponentiation with primes. "/>
        <outline text="The verifier will have confidence in binary terms about the correctness of a proof. That is, there is no probability that some proof has been derived by some common knowledge."/>
        <outline text="The same input will produce and different output which prevents values from being mappable. This is due to added entropy in the proof creation. "/>
    </outline>
    <outline text="[1] Amos Fiat and Adi Shamir. How To Prove Yourself: Practical Solutions to Identification and SignatureProblems. InAdvances in Cryptology — CRYPTO’ 86, volume 263 LNCS, pages 186–194. SpringerBerlin Heidelberg, Berlin, Heidelberg, 1987."/>
</outline>
                            </outline>
                            <outline text="Current Applications">
<outline text="Unforgeable Identification Cards">
    <outline text="In this application, it must be impossible for a verifier to misrepresent their identity as the prover even after performing and witnessing arbitrarily numerous proof verifications of said prover. Examples of this application: passport, credit cards, passwords and military command and control systems. [1]"/>
    <outline text="[1] Amos Fiat and Adi Shamir - How to Prove Yourself: Practical Solutions to Identification and Signature Problems"/>
</outline>
<outline text="Cryptocurrencies">
    <outline text="Monero and Zcash are privacy orientated cryptocurrencies in which the transactions are confidential but their ownership can be proved using ZKP. Specifically, Monero employs ZK-SNARK (Zero-Knowledge Succinct Non-Interactive Argument of Knowledge) as the ZKP scheme to verify the authenticity of transactions."/>
    <outline text="A more popular cryptocurrency, Ethereum has a research group which has explored ZK-SNARK to enhance privacy in transactions. "/>
    <outline text="Briefly, ZK-SNARK is a complex scheme where proving information is taken further by also having to prove correct computation of values. This was taken from the Pinocchio Protocol [2] which proposes a method of verifying the correctness of outsourced computations. This is later improved by [3] in which the protocol is non-interactive and succinct whilst having better performance. The ZK-SNARK has several properties:">
        <outline text="Zero-Knowledge -- able to prove to another party a statement is true without revealing said information."/>
        <outline text="Succinct -- Must be verifiable in milliseconds and proofs produced are of short length."/>
        <outline text="Non-Interactive -- Protocol doesn't require back-and-forth communication between the prover and verifier."/>
    </outline>
    <outline text="This is achieved by combining several concepts. Firstly code is flattened into gates, then converted to R1CS (Rank 1 Constraint System) [1]. This is now in a suitable format to convert into a QAP (Quadratic Arithmetic Program). As a QAP, it is possible to perform homomorphic hiding with blind polynomial evaluation. Furthermore, the security of the polynomials is enhanced by using Elliptic Curve Mapping. The improvements made by [3] allow this scheme to be used by cryptocurrencies due to the short length proofs being produced."/>
    <outline text="[1] QAP - https://eprint.iacr.org/2012/215.pdf"/>
    <outline text="[2] Pinocchio Protocol - https://eprint.iacr.org/2013/279.pdf"/>
    <outline text="[3] Succinct ZKP Pinocchio - https://eprint.iacr.org/2016/260.pdf"/>
</outline>
<outline text="Other notable - Remote Computational Correctness">
    <outline text="The Pinocchio protocol [1] developed by ... and ... has a use-case for a client to verify computational correctness of outsourced program execution. This takes advantage of ZKP schemes to provide confidence in not only proving that some information is correct but that the entity computing this information has arrived at that this outcome without cheating."/>
</outline>
                            </outline>
                        </outline>
                        <outline text="Personal Work">
                            <outline text="Security Architecture">
<outline text="Compounded Components ">
    <outline text="Public Keys">
        <outline text="With a centralised server network arrangement, the public keys are only used in certificate and authenticating the server. Vice-versa, the clients may also be authenticated when working in a closed group of members.  "/>
    </outline>
    <outline text="Pedersen Commitment"/>
    <outline text="NIZKP Fiat-Shamir Heuristic">
        <outline text="Purpose">
            <outline text="When a client answers the questions provided in a proof form, the client will derive NI-Random Oracle Proofs for these answers. This takes the role of a prover which the proof form creator will be the verifier. It is also plausible to reverse the roles where the form creator creates proofs of the answers and the other clients can verify it themselves. Several issues arise from this protocol:">
                <outline text="The form creator with the real answers does not have control over how many times a client may try to prove their knowledge."/>
                <outline text="Once a client has supposedly verified that there is common knowledge, the client will have to prompt the form creator of this event. Once again, another proof must be derived so that the original form creator will have confidence that this client is not lying. (Whether this derived information is from scheme attributed to the form's queries or another round of NI-Random Oracle Proof creation which is redundant considering it reverse the roles again of prover and verifier."/>
            </outline>
        </outline>
        <outline text="Values &amp; Properties">
            <outline text="The security of the scheme is based on the difficulty of modular exponentiation with primes. "/>
            <outline text="Parameters">
                <outline text="$$g$$ generator"/>
                <outline text="$$p$$ prime"/>
                <outline text="$$v$$ random"/>
                <outline text="$$s$$ common secret"/>
            </outline>
            <outline text="Proof">
                <outline text="The scheme uses entropy to produce proofs with same input but different output which prevents reuse of proofs and also mapping and attributing this value with another user with the same input.    "/>
                <outline text="The input to create a proof is a __Common Secret__ with recommended security parameters. A source of entropy is also used in every proof generation to produce unique outputs. An output consists of values __Commitment__ and __Response__ which will be challenged by the verifier. Note that the prover will not need to communicate anymore than these two values in order to prove mutual knowledge with the verifier."/>
                <outline text="Generate Proof" listStyle="arabic">
                    <outline text="$$x =$$ Hash$$(s) \pmod{p}$$"/>
                    <outline text="$$y = g^x \bmod{p}$$"/>
                    <outline text="$$t = g^v \bmod{p}$$"/>
                    <outline text="$$c =$$ Hash$$(g || y || t) \pmod{p}$$"/>
                    <outline text="$$r = v - c \times x$$"/>
                    <outline text="Proof$$($$Commitment: $$t,$$ Response: $$r)$$"/>
                </outline>
            </outline>
            <outline text="Verification">
                <outline text="The verifier will take the two produced values __Commitment__ and __Response__ and complete a calculation by also using the __Common Secret__ that the prover and verifier may share."/>
                <outline text="An aspect of this scheme is that the verifier will have confidence that the verification is either true or false. That is, there are no false positives and probability of mutual knowledge."/>
                <outline text="Verify Proof" listStyle="arabic">
                    <outline text="$$x =$$ Hash$$(s) \pmod{p}$$"/>
                    <outline text="$$y = g^x \bmod{p}$$"/>
                    <outline text="$$c' =$$ Hash$$(g||y||t) \pmod{p}$$"/>
                    <outline text="$$t' = g^r \times y^{c'} \pmod{p}$$"/>
                    <outline text="$$(t' = t) \xrightarrow{} \bold{Verified}$$"/>
                </outline>
            </outline>
        </outline>
    </outline>
    <outline text="Structure">
        <outline text="[ Field ID | Proof of Knowledge | Identity Commitment] = [ Field ID | (t,r) | (c,h) ]"/>
    </outline>
    <outline text="Network Protocol">
        <outline text="Topology">
            <outline text="To simplify development and network protocols, the network is organised with a centralised server that relays messages between clients. The server acts as an anonymising screen as messages that are relayed do not contain sensitive information and infer the identity of the sender. (The clients themselves do not send any identifiable information, at least a commitment of their identity which they have control over). The server is verified with SSL certificates (TLS 1.2) and only stores proof forms and which channel it came from."/>
        </outline>
        <outline text="Messages">
            <outline text="States">
                <outline text="A client wants to submit a proof form">
                    <outline text="Proof Form is sent to server and assigns proof ID"/>
                    <outline text="Server broadcasts proof ID and proof form"/>
                    <outline text="Other clients must approve/deny constraints proposed in the form and reply to server"/>
                    <outline text="Server will determine approval of the proof and relay the feedback to the original proof form creator"/>
                    <outline text="If the form is approved:">
                        <outline text="Other clients will produce answers to the proof form and convert them into NI-Random Oracle Proofs with an attributed Pedersen Commitment of their identity. These will be sent to the original form creator."/>
                        <outline text="The form creator will verify the proofs received and note the attributed commitment of identity."/>
                        <outline text="The attributed commitment will be used to verify the identity of the proof prover when communicating outside of the channel provided by the server."/>
                    </outline>
                </outline>
                <outline text="A client joins the network">
                    <outline text="A client will prompt the server for proofs currently unapproved."/>
                </outline>
                <outline text="A participant creates a form with a directive e.g. Prove the following information for the event that occurred...">
                    <outline text="This form has a schema that others will approve. The serve will hold the form and ask other clients to send proofs for the various fields. "/>
                </outline>
                <outline text="Participants will submit proofs to the server with an attributed commitment of their identity."/>
                <outline text="Upon verifying enough proofs (the verifier, or form producer), it may give enough confidence to reveal their identity in order to pursue open communication. Their identity can be verified with the original commitment sent with the proof."/>
            </outline>
        </outline>
        <outline text="Schemes Used:">
            <outline text="NI Fiat-Shamir Heuristic"/>
            <outline text="Pedersen Commitment"/>
        </outline>
    </outline>
    <outline text="Privacy">
        <outline text="Trusted Third Party"/>
    </outline>
</outline>
                            </outline>
                            <outline text="Notes of Observation">
<outline text="Participants that prove knowledge send the NIROC Commitments instead of verifying it themselves">
    <outline text="This prevents brute forcing of the common knowledge in question (prompted by the form creator)"/>
    <outline text="The form creator cannot bruteforce effectively with the addition of entropy in the proof."/>
    <outline text="The form creator can verify the commitments and determine that an anonymous source has common knowledge."/>
</outline>
<outline text="The Participants that prove knowledge are the ones that send commitments of their identity with Pedersen's scheme">
    <outline text="This gives power to the form creator in being able to verify the identity of a prover after having confidence in common knowledge."/>
    <outline text="This can be used outside of the channel provided by the centralised server that relays messages between the clients."/>
</outline>
<outline text="Server Message Relaying">
    <outline text="All messages sent to be relayed do not contain sufficient parameters or information to decrypt or verify some data without additional secret knowledge (that parties potentially share). The only information the server holds is the structure of the form and the client it came from."/>
    <outline text="Additionally, the server is verified by certificates and any information relayed by this trusted server will not contain any information that will infer the identities of other clients. The server only keeps track of which channel a form originated from and does not receive any more identifiable information about the client."/>
</outline>
<outline text="Handling Form Answers">
    <outline text="When verifying proofs received, the true answers will need to be recalled. There are some options on how to proceed here depending on the sensitivity:">
        <outline text="Human input on the event of receiving proofs (after consensus approving the form)."/>
        <outline text="Answers were stored previously and are loaded to automatically verify received proofs:">
            <outline text="The answers are not encrypted and an observer can view the answers and the challenge is produced then."/>
            <outline text="The answers were computed into challenges which can be regarded as encrypted and can also be used to complete the verification (partially complete the verification process when creating the form)."/>
            <outline text="Produce challenge and attributed answer at form creation, storage can be password protected with a symmetric algorithm."/>
        </outline>
    </outline>
</outline>
                            </outline>
                            <outline text="Application">
<outline text="Discovering Mutual Knowledge between Organisations"/>
<outline text="Requirements">
    <outline text="Anonymity"/>
    <outline text="Authenticity"/>
</outline>
<outline text="Proof-Of-Concept"/>
<outline text="Evaluation">
    <outline text="Show time it takes to create proofs for a range of fields and answer sizes with commitment on top."/>
    <outline text="Is it better to create a unique commitment for each proof or use the same one for the same form?">
        <outline text="A unique one will mean that the prover will have to publish many values"/>
    </outline>
</outline>
                            </outline>
                        </outline>
                        <outline text="Conclusion">
                            <outline text="Further Work">
<outline text="An extension to the type of information being signalled is possible with ZK-SNARKs where it is beneficial to verify correctness of remote code execution. That is, to determine another entity know the inputs, processes and outputs without revealing them."/>
<outline text="This is implementing QAP and Elliptic Curve Pairing for the Pinocchio protocol."/>
                            </outline>
                            <outline text="Discussion"/>
                            <outline text="Closing Statements"/>
                        </outline>
                        <outline text="References">
                            <outline text="Cryptos">
<outline text="Monero"/>
<outline text="Eth"/>
                            </outline>
                            <outline text="ZKP Schemes">
<outline text="NI"/>
                            </outline>
                        </outline>
                    </outline>
                </outline>
                <outline text="Bivariate Secret Sharing Paper [Next year?]">
                    <outline text="A Novel Deterministic Compartmented Secret Sharing Scheme #h">
                        <outline text="Authors">
                            <outline text="AZ, EP"/>
                        </outline>
                        <outline text="Keywords"/>
                        <outline text="Abstract #h">
                            <outline text="#signpost "/>
                        </outline>
                        <outline text="Introduction #h">
                            <outline text="Context and Background #h ">
<outline text="#signpost "/>
<outline text="Matrix Notations #slide #arman">
    <outline text="Galois Field for prime $$p$$ - $$\mathbb{F}_p$$"/>
    <outline text="Principle: write $$f(x,y)$$ as a matrix $$F = ((a_{i,j}))$$ where $$f(x, y) = \sum^m_{i=0} \sum^m_{i=0} a_{ij} x^i y^j \pmod{p}$$."/>
    <outline text="Create shares by evaluating $$f$$ at various points, e.g. $$f(x_i,y), f(x,y_i)$$ or $$f(x_i,y_i)$$. [Depending on application]"/>
    <outline text="Reconstruct $$f$$ by creating invertible Vandermonde matrix from a coalition of shares/players."/>
</outline>
<outline text="Multi-Secret Sharing #slide #arman">
    <outline text="Each Player receives $$g_i(y)=f(x_i, y)$$."/>
    <outline text="Reconstruction of $$f(x,y)$$ is based on $$V(x_1, ...,x_n) \cdot F = \begin{bmatrix} \text{coeffs}_y(g_1) \\ \vdots \\ \text{coeffs}_y(g_m) \end{bmatrix}$$ and inverting $$V(x_{i_1}, ....,x_{i_k})$$."/>
    <outline text="Similarly, the scheme could be using $$h_j(y)=f(x,y_j)$$: ">
        <outline text="$$F \cdot V(y_1,...,y_n)^t = \begin{bmatrix} \text{coeffs}_x(f(x,y)) \\ \vdots \\ \text{coeffs}_x(f(x,y_n)) \end{bmatrix}$$"/>
    </outline>
    <outline text="But this is not different to running multiple instances of Shamir SS."/>
</outline>
                            </outline>
                            <outline text="Research Contributions #h">
<outline text="#signpost "/>
                            </outline>
                            <outline text="Paper Organisation #h">
<outline text="#signpost "/>
                            </outline>
                            <outline text="Notations #h "/>
                        </outline>
                        <outline text="Literature Review and Related Work #h">
                            <outline text="#signpost "/>
                            <outline text="Harn-Hsu's Bivariate Secret Sharing #h #arman ">
<outline text="Share Creation #slide #arman">
    <outline text="$$t$$ secrets $$\{s_1, s_2, ... s_t\}$$ where $$s_r = f(r,0)$$"/>
    <outline text="$$f(x, y)$$ where $$x$$ and $$y$$ have degree $$t-1$$."/>
    <outline text="Dealer computes $$f_i(x) = f(x,i),i = 1,2,...,n$$ and sends this result to the respective $$P_i$$ shareholder."/>
</outline>
<outline text="Share Reconstruction #slide #arman">
    <outline text="$$t$$ Players $$\{P_1, ..., P_t\} \subset \{P_1, P_2, ... , P_n\}, t \leq n$$ can recover the secret."/>
    <outline text="For secret a $$s_r$$ each player $$P_i \in \{P_1, ... , P_t\}$$ computes a value $$e_i = f_i(r) = f(r, i)$$."/>
    <outline text="$$t$$ number of $$e$$ values are required to recover secret $$s_r$$."/>
    <outline text="$$\sum^t_{i=1} (e_i \sum^t_{j=1, j \neq i} \frac{-j}{i - j})\pmod{p} = s_r$$"/>
    <outline text="Vandermonde $$V_{ij}$$ of dimension $$i,j$$ is inverted and transposed $$\hat{V_{ij}}$$, $$\hat{V_{ij}} = V_{ij}^{-1 \rightarrow T}$$."/>
    <outline text="First column is taken where $$N = \hat{V_{1j}}$$"/>
    <outline text="$$\begin{bmatrix} e_{11} &amp; \dots &amp; e_{1n} \\ \vdots &amp; &amp; \vdots \\ e_{1n} &amp; \dots &amp; e_{rn} \end{bmatrix} \cdot N = \begin{bmatrix} s_1 \\ \vdots \\ s_r \end{bmatrix}$$"/>
</outline>
                            </outline>
                            <outline text="Tassa's Probabilistic Multipartite Scheme #h "/>
                        </outline>
                        <outline text="The Novel Scheme #h">
                            <outline text="#signpost "/>
                            <outline text="Introduction #slide #arman">
<outline text="The secret is (part of) a bivariate polynomial $$f(x, y)$$."/>
<outline text="Let $$P_1, P_2,...,P_n$$ be players involved in the sharing scheme."/>
<outline text="We have:">
    <outline text="Symmetric bivariate SS - the poly is symmetric ($$f(x,y) = f(y,x)$$)."/>
    <outline text="Asymmetric BSS otherwise."/>
</outline>
<outline text="The are several applications of BSS:">
    <outline text="Multi-secret sharing"/>
    <outline text="Key agreement"/>
    <outline text="Implementing advanced SS with special access structures"/>
</outline>
                            </outline>
                            <outline text="Properties #slide #arman">
<outline text="There are two sets of players:">
    <outline text="$$\mathcal{P} = \{P_1, ..., P_n\}$$ and $$\mathcal{Q} = \{Q_1,...,Q_n\}$$"/>
</outline>
<outline text="Each set has associated thresholds $$k$$ and $$l$$."/>
<outline text="A coalition of at least $$k$$ players of $$P$$ and at least $$l$$ players of $$Q$$ can reconstruct the secret."/>
<outline text="Any coalition with less than these players do not gain (any? all?) information about the secret."/>
                            </outline>
                            <outline text="Notations #slide #arman ">
<outline text="Given a secret $$s$$, we create a bivariate polynomial $$f(x,y)$$ with $$\deg_x f = k-1$$ and $$\deg_y f = l-1$$."/>
<outline text="We set $$f(0,0) = s$$ and $$f(i,j)$$ is random $$(i,j \neq 0)$$."/>
<outline text="Furthermore, we form the matrix $$B := ((b_{ij}))$$ where $$1 \leq i \leq n, 1 \leq j \leq n$$, and ">
    <outline text="$$b_{ij} = \begin{bmatrix} 1 &amp; x_i &amp;  \cdots &amp; x_i^{k-1} \end{bmatrix} \cdot \begin{bmatrix} a_{0j} \\ a_{1j} \\ \vdots \\ a_{kj} \end{bmatrix} - \begin{bmatrix}a_{i0} &amp; a_{i1} &amp; \cdots &amp; a_{il} \end{bmatrix} \cdot \begin{bmatrix} 1 \\ y_j \\ \vdots \\ y^{l-1}_j \end{bmatrix}$$."/>
    <outline text="Here $$B = V_x A - A V_y$$. "/>
</outline>
                            </outline>
                            <outline text="Share Creation #slide #arman">
<outline text="Each player $$P_i$$ has public value $$x_i$$."/>
<outline text="A public value $$y_j$$ is associated with $$Q_j$$."/>
<outline text="The shares distributed to the players in $$\mathcal{P}$$ and  $$\mathcal{Q}$$ are as follows:">
    <outline text="$$P_i$$ receives the row vector $$\begin{bmatrix} b_{i0} &amp; b_{i1} &amp; \dots &amp; b_{in} \end{bmatrix}$$."/>
    <outline text="$$Q_j$$ receives the column vector $$\begin{bmatrix} b_{0j} \\ b_{1j} \\ \vdots \\ b_{nj} \end{bmatrix}$$."/>
</outline>
                            </outline>
                            <outline text="Share Reconstruction #slide #arman ">
<outline text="In order to reconstruct $$f$$, a coalition of $$k$$ players $$\{P_{i_1},...,P_{i_k}\}$$ and $$l$$ players $$\{Q_{j_i}, ..., Q_{j_l}\}$$ proceed as follows:">
    <outline text="The first coalition constructs the matrix $$V{(x_{i_1},...,x_{i_k})}$$."/>
    <outline text="The second coalition forms the matrix $$V^t{(y_{j_1}, ..., y_{j_l})}$$."/>
    <outline text="Together, they build the matrix $$W(k,l) = \begin{bmatrix} b_{i_1,j_1} &amp; b_{i_1,j_2} &amp; \dots &amp; b_{i,j_l} \\ b_{i_2,j_1} &amp; b_{i_2,j_2} &amp; \dots &amp;b_{i_2,j_l} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ b_{i_k,j_1} &amp; b_{i_k,j_2} &amp; \dots &amp; b_{i_k,j_l}\end{bmatrix}$$. "/>
    <outline text="They find the unique solution of the Sylvester equation $$V{(x_{i_1}, ..., x_{i_k})} F - F V^t{(y_{i_1}, ..., y_{i_l})} = W(k,l)$$."/>
</outline>
                            </outline>
                            <outline text="Example #h">
<outline text="Parameters #slide ">
    <outline text="$$k = 2$$"/>
    <outline text="$$l = 3$$"/>
    <outline text="$$A = \begin{bmatrix}15 &amp; 10 &amp; 5\\1 &amp; 2 &amp; 3 \end{bmatrix}$$"/>
    <outline text="$$V{(x_1, x_2)} = \begin{bmatrix}1 &amp; 1 \\1 &amp; 2\end{bmatrix}$$, $$V{(y_1,y_2,y_3)}^T = \begin{bmatrix}1 &amp; 1 &amp; 1\\1 &amp; 2 &amp; 3 \\1 &amp; 4 &amp; 9\end{bmatrix}$$"/>
</outline>
<outline text="Share Creation #slide ">
    <outline text="Calculation of $$B = V{(x_1,x_2)}  A - A  V{(y_1,y_2,y_3)} = ((b_{ij}))$$:">
        <outline text="$$b_{1,1} = \begin{bmatrix}1 &amp; 1\end{bmatrix}  \begin{bmatrix}15 \\ 1 \end{bmatrix} - \begin{bmatrix}15 &amp; 10 &amp; 5 \end{bmatrix}  \begin{bmatrix} 1 \\ 1 \\ 1 \end{bmatrix} = -14$$ "/>
        <outline text="$$b_{2,1} = \begin{bmatrix} 1 &amp; 2 \end{bmatrix}  \begin{bmatrix} 15 \\ 1 \end{bmatrix} - \begin{bmatrix}1 &amp; 2 &amp; 3\end{bmatrix}  \begin{bmatrix}1 \\ 1 \\ 1 \end{bmatrix} = 11$$"/>
        <outline text="$$b_{1,2} = \begin{bmatrix}1 &amp; 1\end{bmatrix}  \begin{bmatrix} 10 \\ 2 \end{bmatrix} - \begin{bmatrix}15 &amp; 10 &amp; 5\end{bmatrix}  \begin{bmatrix} 1 \\ 2 \\ 4 \end{bmatrix} = -43$$"/>
        <outline text="$$b_{2,2} = \begin{bmatrix}1 &amp; 2\end{bmatrix}  \begin{bmatrix} 10 \\ 2\end{bmatrix} - \begin{bmatrix}1 &amp; 2 &amp; 3\end{bmatrix}  \begin{bmatrix}1 \\ 2 \\ 4 \end{bmatrix} = -3$$"/>
        <outline text="$$b_{1,3} = \begin{bmatrix}1 &amp; 1\end{bmatrix}  \begin{bmatrix}5 \\ 3\end{bmatrix} - \begin{bmatrix}1 &amp; 2 &amp; 3\end{bmatrix}  \begin{bmatrix}1 \\ 3 \\ 9\end{bmatrix} = -23$$"/>
        <outline text="$$b_{2,3} = \begin{bmatrix}1 &amp; 2\end{bmatrix}  \begin{bmatrix} 5 \\ 3\end{bmatrix} - \begin{bmatrix}1 &amp; 2 &amp; 3\end{bmatrix}  \begin{bmatrix}1 \\ 3 \\ 9 \end{bmatrix} = -23$$"/>
        <outline text="$$\therefore B = \begin{bmatrix} -14 &amp; -43 &amp; -82 \\ 11 &amp; -3 &amp; -23 \end{bmatrix} = \begin{bmatrix} b_{1,1} &amp; b_{1,2} &amp; b_{1,3} \\ b_{2,1} &amp; b_{2,2} &amp; b_{2,3} \end{bmatrix}$$"/>
    </outline>
</outline>
<outline text="Secret Recovery #slide  ">
    <outline text="Objective">
        <outline text="$$vec(A) = (I_l \otimes V{(x_1, x_2)} - V{(y_1, y_2, y_3)}^T \otimes I_k)^{-1} \cdot vec(B)^T$$"/>
        <outline text="$$vec(B) = \begin{bmatrix} b_{1,1} &amp; b_{2,1} &amp; b_{1,2} &amp; b_{2,2} &amp; b_{1,3} &amp; b_{2,3}\end{bmatrix}$$"/>
    </outline>
    <outline text="Calculation">
        <outline text="$$vec(B) = \begin{bmatrix} -14 &amp; 11 &amp; -43 &amp; -3 &amp; -82 - 23\end{bmatrix}$$"/>
        <outline text="$$vec(A) = \begin{bmatrix} 0 &amp; 1 &amp; -1 &amp; 0 &amp; -1 &amp; 0 \\ 1 &amp; 1 &amp; 0 &amp; -1 &amp; 0 &amp; -1 \\ -1 &amp; 0 &amp; -1 &amp; 1 &amp; -4 &amp; 0\\ 0  &amp; -1 &amp; 1 &amp; 0 &amp; 0 &amp; -4\\-1 &amp; 0 &amp; -3 &amp; 0 &amp; -8 &amp; 1 \\ 0 &amp; -1 &amp; 0 &amp; -3 &amp; 1 &amp; -7\end{bmatrix}^{-1} \cdot \begin{bmatrix} -14 \\ 11 \\ -43 \\ -3 \\ -82 \\ -23\end{bmatrix} = \begin{bmatrix} 15 \\ 1 \\ 10 \\ 2 \\ 5 \\ 3 \end{bmatrix}$$"/>
    </outline>
</outline>
                            </outline>
                        </outline>
                        <outline text="Evaluation #h">
                            <outline text="#signpost "/>
                            <outline text="Security #h "/>
                            <outline text="Computational Cost #h "/>
                            <outline text="Comparison with Other Schemes #h "/>
                            <outline text="Implementation #h "/>
                        </outline>
                        <outline text="Conclusion #h">
                            <outline text="Summary #h">
<outline text="#signpost "/>
                            </outline>
                            <outline text="Discussion (Limitations, Alternatives, Reflections) #h">
<outline text="#signpost "/>
                            </outline>
                            <outline text="Future Work #h">
<outline text="#signpost "/>
                            </outline>
                        </outline>
                        <outline text="References #h"/>
                    </outline>
                </outline>
            </outline>
            <outline text="Personal Knowledge Base [Ongoing]">
                <outline text="CRYPTOGRAPHY #h">
                    <outline text="INTRO / General Properties #h">
                        <outline text="Definition #slide">
                            <outline text="A protocol is a series of steps, involving two or more parties, to accomplish a task"/>
                            <outline text="There are different protocols for different purposes"/>
                            <outline text="Example of a human protocol: Dining in a Posh Restaurant"/>
                            <outline text="__Cryptographic/Security Protocol __">
<outline text="A set of communication rules (specification) in order to achieve security goals amongst a set of users"/>
<outline text="Can be very difficult to get free of vulnerabilities"/>
                            </outline>
                        </outline>
                        <outline text="Characteristics #slide">
                            <outline text="All parties must have complete knowledge of all the steps involved, in advance"/>
                            <outline text="All parties must agree to follow the protocol"/>
                            <outline text="Must be unambiguous -- each step must be well defined, so that no misunderstandings"/>
                            <outline text="Must be complete -- there must be a specified action for every possible situation"/>
                            <outline text="It should not be possible to do more or learn more than that specified in the protocol"/>
                        </outline>
                        <outline text="Types #slide">
                            <outline text="Based on criteria of dispute resolution mechanism, there are three main types:" _note="[Further Reading](https://www.slideshare.net/afiqefendy/protocols-and-practicesinusingencryption-chap)">
<outline text="Arbitrated -- a Trusted Third Party is involved"/>
<outline text="Adjudicated -- communications proceed with no third party until a disagreement"/>
<outline text="Self-enforcing -- no involvement other than from users"/>
                            </outline>
                            <outline text="Trust Architecture">
<outline text="Centralised (TTP) -- online/offline"/>
<outline text="Partly decentralised (Distributed TTP) -- online/offline"/>
<outline text="Fully decentralised (no TTP)"/>
                            </outline>
                            <outline text="Interactivity">
<outline text="Interactive/non-interactive"/>
                            </outline>
                        </outline>
                        <outline text="Interactive Protocol #slide">
                            <outline text="Multiple rounds of communication is required to achieve the cryptographic objective of a protocol."/>
                            <outline text="Alice and Bob may have to exchange information in succession."/>
                            <outline text="For example:">
<outline text="Alice may need to use a value from Bob in order to compute another value."/>
<outline text="She also uses her own private value in conjuction."/>
<outline text="This is sent back to Bob where he might also use his own secret value that contributes to the objective of the protocol."/>
                            </outline>
                        </outline>
                        <outline text="Non-Interactive Protocol #slide ">
                            <outline text="Definition ">
<outline text="A party can broadcast or complete the cryptographic objective of the protocol by communicating once."/>
                            </outline>
                        </outline>
                        <outline text="Hard Problems (good for security) #h ">
                            <outline text="Non-Deterministic Polynomial Time Complexity">
<outline text="Polynomial Time">
    <outline text="Problem that can be solved on a deterministic algorithm."/>
</outline>
<outline text="Non-Deterministic Polynomial Time"/>
<outline text="Non-Deterministic Polynomial Time - Complete"/>
<outline text="Non-Deterministic Polynomial Time - Hard"/>
                            </outline>
                            <outline text="Discrete Logarithm Problem #h">
<outline text="Description #slide">
    <outline text="The problem of finding $$k$$ in $$a = b^k$$ which the logarithm $$\log_b a = k$$. "/>
    <outline text="This is a difficult problem as this process cannot be directly reversed and requires an efficient algorithm to do this."/>
</outline>
<outline text="Problem #slide">
    <outline text="In terms of classical computers, there is no effective algorithm to determine $$k$$ in any relatively reasonable time that $$k$$ is considered as an important value for it's application."/>
    <outline text="In terms of quantum computers there is Shor's Algorithm"/>
</outline>
                            </outline>
                            <outline text="Shortest Vector Problem #h" colorLabel="1"/>
                        </outline>
                    </outline>
                    <outline text="THEORY #h">
                        <outline text="Hard Problems #h ">
                            <outline text="Discrete Logarithm Problem"/>
                            <outline text="Integer Factorisation"/>
                        </outline>
                        <outline text="Groups #h">
                            <outline text="Definition">
<outline text="A group is a set $$G$$ whereby operations have certain properties:">
    <outline text="Associative operation">
        <outline text="$$a \times (b \times c) = (a \times b) \times c$$"/>
    </outline>
    <outline text="Identity element">
        <outline text="$$a \times i = i \times a = a$$"/>
    </outline>
    <outline text="Inverse element">
        <outline text="$$a \times a^{-1} = a^{-1} \times a = i$$"/>
    </outline>
</outline>
                            </outline>
                            <outline text="Types">
<outline text="Multiplicative Group $$G^\times$$"/>
<outline text="Additive Group $$G^+$$"/>
<outline text="Infinite Group"/>
<outline text="Finite Groups"/>
                            </outline>
                            <outline text="Cyclic Groups">
<outline text="A finite group is cyclic if some generator $$g$$ can produce all elements in group $$G$$ when computing $$g^j$$ for any $$j$$."/>
                            </outline>
                            <outline text="Group Order">
<outline text="The order of some group element $$a$$ is determined by the smallest positive integer $$i$$ in $$a^i = 1$$. "/>
<outline text="This can be written as $$ord(a) = i$$. Which $$1$$ is the unity of this case."/>
                            </outline>
                        </outline>
                        <outline text="Finite Fields #h ">
                            <outline text="Operations are applied on integers which consist of using modulo whereby $$a \bmod{p}$$ is the remainder of $$a \div p$$. Finite Field is an additive group which can form multiplicative group."/>
                            <outline text="A Finite Field $$\mathbb{F}_p$$ that has a prime $$p$$ is a set $$\{0,1,...,p-1\}$$."/>
                            <outline text="Finite Fields $$\mathbb{F}_{p^k}$$ of prime $$p$$ and integer $$k$$ is a polynomial of degree up to $$k-1$$ where the coefficients are in the set $$\mathbb{F}_p$$. This polynomial is irreducible "/>
                            <outline text="Modular Arithmetic #h">
<outline text="Greatest Common Divisor #h"/>
<outline text="Extended Euclidean Algorithm #h"/>
<outline text="Generators #h"/>
<outline text="Operations #h">
    <outline text="Addition #h ">
        <outline text="$$\mathbb{F}_p$$"/>
        <outline text="$$\mathbb{F}_{p^k}$$">
            <outline text=""/>
        </outline>
    </outline>
    <outline text="Subtraction #h"/>
    <outline text="Multiplication #h"/>
    <outline text="Division #h"/>
</outline>
                            </outline>
                        </outline>
                        <outline text="Elliptic Curve Point Arithmetic #h">
                            <outline text="Addition">
<outline text="A point at infinity $$\mathcal{O}$$ when $$P + \mathcal{O} = P$$, $$P - P = \mathcal{O}$$."/>
<outline text="$$P_3(x_3,y_3) = P_1(x_1, y_1) + P_2(x_2,y_2) \neq \mathcal{O}$$:">
    <outline text="$$x_3 = \lambda^2 - x_1 - x_2$$"/>
    <outline text="$$y_3 = \lambda (x_1 - x_3) - y_1$$"/>
</outline>
<outline text="If $$P_1 \neq P_2$$, $$\lambda = \frac{y_2 - y_1}{x_2 - x_1}$$"/>
<outline text="If $$P_1 = P_2$$, $$\lambda = \frac{3 x^2_1 + a}{2 y_1}$$"/>
<outline text="If $$x_1 = x_2$$ and $$y_1 \neq y_2$$, $$P_1 = P_2$$"/>
<outline text="If $$y_1 = 0$$ then $$2 P_1 = \mathcal{O}$$"/>
<outline text="If $$P_1 = (x_1, y_1), -P_1 = (x_1, - y_1)$$"/>
                            </outline>
                            <outline text="Scalar Multiplication">
<outline text="A point $$P$$ is multiplied $$n$$ which is performed by adding $$P$$ to itself $$n$$ times."/>
<outline text="The order of $$P$$ is the smallest positive integer $$a$$, $$aP = \mathcal{O}$$."/>
                            </outline>
                            <outline text="Pairings">
<outline text="Bilinear pairings can be constructed from Tate pairings on specific elliptic curves. "/>
                            </outline>
                        </outline>
                        <outline text="Information #h">
                            <outline text="Theory of Communication (Claude Shannon) #h">
<outline text="Introduction #slide">
    <outline text="First and foremost, the problem of communication is reproducing a message at one point which is exactly or approximately the same as the message at another point. Messages have meanings and are essentially selected from a set of possible messages. "/>
    <outline text="If the number of messages in the set is finite then this number or any monotonic function (a function where the subset of numbers produced are entirely non-increasing or non-decreasing) of this number can be regarded as a measure of the information produced when one message is chosen from the set, all choices being equally likely."/>
    <outline text="A function to measure this number is logarithmic which the base correspond to the choice of a unit measuring information. Naturally, the base 2 results in units called binary digits or bits. $$N$$ `devices' can store $$N$$ bits for a total number of possible states is $$2^N$$ and thus $$\log_2 2^N = N$$."/>
    <outline text="If base 10 is used then the units are called decimal digits since:">
        <outline text="$$\log_2 M = \log_{10} M / \log_{10} 2$$"/>
        <outline text="       $$= 3.32 \log_{10} M$$"/>
    </outline>
    <outline text="Therefore a decimal digit is about $$3 \frac{1}{3}$$ bits."/>
    <outline text="Communication system is classified in three main categories: discrete, continuous and mixed. "/>
    <outline text="A discrete system is one in which both the message and the signal are a sequence of discrete symbols. For example, a message is made up of a sequence of letters and the signal is a sequence of dots, dashes and spaces."/>
</outline>
<outline text="Choice, Uncertainty and Entropy">
    <outline text="Can we define a quantity which will measure, in some sense, how much information is &quot;produced&quot; by such a process, or better, at what rate information is produced?"/>
    <outline text="For probabilities of occurences $$p_1,p_2,...,p_n$$, we measure how much choice is involved in the selection of the event or how uncertain we are of the outcome say $$H(p_1, p_2, ..., p_n)$$ "/>
</outline>
                            </outline>
                        </outline>
                    </outline>
                    <outline text="SCHEMES #h">
                        <outline text="HOMOMORPHIC #h">
                            <outline text="https://en.wikipedia.org/wiki/NTRUEncrypt#Table_1:_Parameters"/>
                            <outline text="https://eprint.iacr.org/2013/094.pdf"/>
                            <outline text="https://asecuritysite.com/lattice/lattice"/>
                            <outline text="https://github.com/openfheorg/openfhe-development?tab=readme-ov-file"/>
                            <outline text="Brakerski-Fan-Vercauteren (BFV)">
<outline text="This is a fully homomorphic encryption scheme based on Ring-Learning with Errors cryptosystem."/>
<outline text="Basic object i a polynomial ring $$R = \mathbb{Z}[x] / (f(x))$$ where $$f(x) \in \mathbb{Z}[x]$$ is a monic irreducible polynomial of degree $$d$$. It is common to take $$f(x) = x^d + 1$$ with $$d=2^n$$."/>
<outline text="Elements of the ring $$R$$ are denoted as lowercase bold e.g. $$\textbf{a} \in R$$. The coefficients of $$\textbf{a} \in R$$ are denoted by $$a_i$$ i.e. $$ \textbf{a} = \sum^{d-1}_{i=0} a_i \cdot x^i$$ ."/>
<outline text="The infinity norm $$||a||$$ is defined as max$$_i|a_i|$$, the largest coefficient in the polynomial. "/>
<outline text="The expansion factor of $$R$$ is defined as $$\delta_{R} = max\{||a \cdot b|| / (||a|| \cdot ||b||) : a,b \in R \}$$."/>
<outline text="Let $$q &gt; 1$$ be an integer, where $$\mathbb{Z}_q$$ there is a set of integers $$(-q/2, q/2]$$."/>
<outline text="Multiplication produces 3 ring elements which requires relinearisation that reduces the ciphertext with $rlk$ key. So $$ct = [c_0,c_1,c_2]$$ is a degree 2 ciphertext which needs to be reduced to $$ct' = [c'_0, c'_1]$$.">
    <outline text="$$[c_0 +c_1 \cdot s + c_2 \cdot s^2 ]_q = [c'_0 + c'_1 \cdot s + r]_q$$"/>
</outline>
<outline text="Notation">
    <outline text="$$n$$ - Ring size"/>
    <outline text="$$q$$ - Ciphertext mod"/>
    <outline text="$$t$$ - Plaintext mod"/>
    <outline text="$$\mu, \sigma$$ - Gaussian distribution parameters"/>
    <outline text="$$\mathcal{X}$$ - Gaussian distribution"/>
    <outline text="$$\psi,\psi_v, \omega, \omega_v$$ - Fast Fourier Transform parameters"/>
    <outline text="$$T$$ - Multiplication relinearlisation value"/>
    <outline text="$$p$$ - modulus scaling for relinearlisation where $$p \geq q^3$$"/>
</outline>
<outline text="Generate Parameters">
    <outline text=""/>
</outline>
<outline text="Polynomial Operations">
    <outline text="Multiplication (Cyclic "/>
</outline>
<outline text="LPR (Lyubashevsky, Peikert and Regev) Encryption Scheme">
    <outline text="LPR.ES.SecretKeyGen($$1^\lambda$$)">
        <outline text="$$sk$$ = Random polynomial derived from discrete gaussian distribution of $$q$$.">
            <outline text="Extracted value from gaussian distribution is processed $$\lfloor f(\mu, \sigma) \rfloor \bmod{q}$$"/>
        </outline>
        <outline text="__output__ $$sk$$"/>
    </outline>
    <outline text="LPR.ES.PublicKeyGen($$sk$$)">
        <outline text="$$a $$ = Uniformly random polynomial of ring $$n$$, mod $$q$$"/>
        <outline text="$$e$$ = Error polynomial derived from discrete gaussian distribution of $$q$$.">
            <outline text="Extracted value from gaussian distribution is processed $$\lfloor f(\mu, \sigma) \rfloor \bmod{q}$$"/>
        </outline>
        <outline text="$$pk_1 = (-(a \times sk)+e) \bmod{q}$$"/>
        <outline text="$$pk_2 = a$$"/>
        <outline text="__output__ $$pk$$"/>
    </outline>
    <outline text="LPR.ES.Encrypt($$pk,m$$)">
        <outline text="$$\Delta = \lfloor q / t \rfloor$$"/>
        <outline text="$$u =$$ Random polynomial derived uniformly random $$R_2$$"/>
        <outline text="$$e{_1}, e{_2} =$$ Random error polynomials derived from discrete gaussian distribution of $$q$$"/>
        <outline text="$$ct_0 = pk_0 * u + e_1 + m * \Delta$$"/>
        <outline text="$$ct_1 = pk_1 * u + e_2$$"/>
        <outline text="__output__ $$ct$$"/>
    </outline>
    <outline text="LPR.ES.Decrypt($$sk,ct$$)">
        <outline text="$$m = \lfloor t * [c_0 + c_1 * sk]_q / q \rceil \pmod{t}$$">
            <outline text="When computing the polynomial result of $$c_0 + c_1 * sk \bmod{q}$$ each element is multiplied by $$t$$ and divided by $$q$$ then rounded to the nearest and mod by $$t$$."/>
        </outline>
        <outline text="__output__ $$m$$"/>
    </outline>
</outline>
<outline text="FV (Fan Vercauteren) Somewhat Homomorphic">
    <outline text="FV.SH.SecretKeyGen($$1^\lambda$$)">
        <outline text="$$sk$$ = Uniformly random polynomial of ring $$n$$, mod $$q$$"/>
        <outline text="__output__ $$sk$$"/>
    </outline>
    <outline text="FV.SH.PublicKeyGen($$sk$$) = [LPR.ES.PublicKeyGen(sk)](https://dynalist.io/d/riJBQwEAtmmlbif-Yp3cjXr-#z=2wfLE15JqcUiRmrHDrXHhZ8q)"/>
    <outline text="FV.SH.EvaluateKeyGenV1($$sk,T$$)">
        <outline text="$$\ell = \lfloor \log_T(q) \rfloor$$"/>
        <outline text="for $$i = 0,\ldots, \ell:$$">
            <outline text="sample $$a_i \leftarrow R_q, e_i \leftarrow \mathcal{X}$$"/>
        </outline>
        <outline text="$$rlkv1 = [([-a(a_i \cdot s + e_i) + T^i \cdot s^2]_q, a_i) : i \in [0 \dots \ell]]$$"/>
        <outline text="__output__ $$rlkv1$$"/>
    </outline>
    <outline text="FV.SH.EvaluateKeyGenV2($$sk,p$$)">
        <outline text="sample $$a \leftarrow R_{p\cdot q}, e \leftarrow \mathcal{X}'$$"/>
        <outline text="$$rlkv2 = ([-a(a \cdot s + e) + p \cdot s^2]_{p \cdot q},a)$$"/>
        <outline text="__output__ $$rlkv2$$"/>
    </outline>
    <outline text="FV.SH.Encrypt($$pk,m \in R_t$$)">
        <outline text="sample $$u \leftarrow R_2, e_1,e_2 \leftarrow \mathcal{X}$$"/>
        <outline text="$$\Delta = \lfloor q / t \rfloor$$"/>
        <outline text="$$ct = ([pk_0 \cdot u + e_1 + \Delta  \cdot m]_q, [pk_1 \cdot u + e_2]_q)$$"/>
        <outline text="__output__ $$ct$$"/>
    </outline>
    <outline text="FV.SH.Decrypt($$sk,ct$$) = [LPR.ES.Decrypt(sk,ct)](https://dynalist.io/d/riJBQwEAtmmlbif-Yp3cjXr-#z=8yHh0ai7LlH-fID_dBjVlOod)"/>
    <outline text="FV.SH.Add($$ct_1,ct_2$$)">
        <outline text="$$ct_3 = (ct_1[0] + ct_2[0], ct_1[1] + ct_2[1])$$"/>
        <outline text="__output__ $$ct_3$$"/>
    </outline>
    <outline text="FV.SH.ADD($$$$)"/>
</outline>
<outline text="Archive">
    <outline text="Secret Key">
        <outline text="$$sk = $$ Random polynomial of ring $$n$$, mod $$q$$"/>
        <outline text="For $$n$$ coefficients that are elements in $$\mathbb{Z}_q$$"/>
    </outline>
    <outline text="Public Key">
        <outline text="Random polynomial $$a \leftarrow R_q$$ "/>
        <outline text="Random polynomial $$e$$ (error) derived from discrete gaussian distribution of $$q$$."/>
        <outline text="Extracted value from gaussian distrib. is processed $$\lfloor f(\mu, \sigma) \rfloor \bmod{q}$$"/>
        <outline text="$$pk_1 = (-(a \times sk)+e) \bmod{q}$$"/>
        <outline text="$$pk_2 = a$$"/>
    </outline>
    <outline text="Encrypt($$pk, m$$)">
        <outline text="$$\Delta = \lfloor q / t \rfloor$$"/>
        <outline text="$$u =$$ Random polynomial derived uniformly random $$R_2$$"/>
        <outline text="$$e{_1}, e{_2} =$$ Random error polynomials derived from discrete gaussian distribution of $$q$$"/>
        <outline text="$$c_0 = pk_0 * u + e_1 + m * \Delta$$"/>
        <outline text="$$c_1 = pk_1 * u + e_2$$"/>
        <outline text="$$ct = c_0,c_1$$"/>
    </outline>
    <outline text="Decrypt($$sk, ct$$)">
        <outline text="$$m = \lfloor t * [c_0 + c_1 * sk]_q / q \rceil \pmod{t}$$"/>
        <outline text="When computing the polynomial result of $$c_0 + c_1 * sk \bmod{q}$$ each element is multiplied by $$t$$ and divided by $$q$$ then rounded to the nearest and mod by $$t$$."/>
    </outline>
    <outline text="HomomorphicAdd($$ct_1,ct_2$$)">
        <outline text="$$ct_3[0] = ct_1[0] + ct_2[0]$$"/>
        <outline text="$$ct_3[1] = ct_1[1] + ct[1]$$"/>
    </outline>
</outline>
                            </outline>
                            <outline text="Brakerski-Gentry-Vaikuntanathan (BGV)">
<outline text="Information">
    <outline text="https://www.inferati.com/blog/fhe-schemes-bgv"/>
    <outline text="This is a fully homomorphic encryption scheme based on Ring-Learning with Errors cryptosystem."/>
    <outline text="Levels of ciphertext $$0 \leq l \leq L$$ have corresponding moduli $$\mathcal{Q} = \{ p_0, p_1, \ldots, p_{L}\}$$"/>
    <outline text="The first round of ciphertext starts at level $$L$$."/>
    <outline text="The plaintext polynomial ring is defined as $$\mathcal{P} = R_t = \mathbb{Z}_{t}[x] / (x^n + 1)$$ where the set of polynomial with degree less than $$n$$ and coefficients in $$\mathbb{Z}_t$$ where the plaintext modulus $$t$$ and the ring dimensions $$n$$ are both integers."/>
    <outline text="The ciphertext $$\mathcal{C} = R_{q_l} \times R_{q_{l'}}$$ where $$R_{q_l} = \mathbb{Z}_{q_l}[x] / (x^n + 1)$$"/>
    <outline text="For efficiency, $$n$$ is usually set as a power of 2 integer."/>
    <outline text="$$q$$ is much greater than $$t$$."/>
</outline>
<outline text="Parameters">
    <outline text="$$R_2$$ used in the encryption keys, is a uniform "/>
</outline>
                            </outline>
                        </outline>
                        <outline text="PRIVATE SET INTERSECTION #h">
                            <outline text="Introduction #h">
<outline text="Alice &amp; Bob each have a set of private items $$A = (a_1, ..., a_n)$$ and $$B = (b_1,...,b_n)$$."/>
<outline text="The PSI is defined as a protocol that aims to find the intersection $$A \bigcap B$$ where no knowledge is learned about items not in the intersection."/>
                            </outline>
                            <outline text="Microsoft - Fast Private Set Intersection from Homomorphic Encryption">
<outline text="https://eprint.iacr.org/2017/299.pdf"/>
<outline text="Homomorphic Scheme">
    <outline text="Ring Learning With Errors based cryptosystem, the scheme specifically notes BrakerskiGentry-Vaikuntanathan (BGV) and Fan-Vercauteren (FV) schemes."/>
</outline>
<outline text="Basic Protocol Outline">
    <outline text="Receiver has set $$Y$$ of size $$N_y$$ and the Sender has set $$X$$ of size $$N_x$$ where the Receiver evaluates $$X \bigcap Y$$."/>
    <outline text="Setup">
        <outline text="Sender and Receiver agree on a fully homomorphic scheme. Receiver generates a public-private key pair."/>
    </outline>
    <outline text="Set Encryption">
        <outline text="Receiver encrypts each element $$y_i \in Y$$ using the fully Homomorphic encryption scheme. The receiver then sends the $$N_y$$ ciphertexts $$(c_1,...,c_{N_y})$$ to sender."/>
    </outline>
    <outline text="Computing Intersection">
        <outline text="For each $$c_i$$, sender">
            <outline text="finds random non-zero plaintext element $$r_i$$"/>
            <outline text="homomorphically computes $$d_i = r_i \displaystyle \prod_{x \in X}{(c_i - x)}$$"/>
        </outline>
        <outline text="Sender return the ciphertexts $$(d_1,...,d_{N_Y})$$ to receiver."/>
    </outline>
    <outline text="Reply Extraction">
        <outline text="Receiver decrypts the ciphertexts $$(d_1,...,d_{N_y})$$ and outputs $$X \bigcap Y = \{y_i : \text{Decrypt}(d_i) = 0\}$$"/>
    </outline>
</outline>
                            </outline>
                        </outline>
                        <outline text="DATA STRUCTURES #h">
                            <outline text="MERKLE TREES #h ">
<outline text="Using a Hash Function e.g. SHA256, data values are hashed and concatenated to form a tree example:">
    <outline text="Root: H(H(Y)+H(X))">
        <outline text="H(Y) = H(H(A) + H(B)) "/>
        <outline text="H(X) = H(H(C) + H(D))"/>
    </outline>
</outline>
<outline text="Applications">
    <outline text="File Comparison">
        <outline text="Check if blocks of the file are the same, can identify blocks that aren't"/>
    </outline>
    <outline text="Distributed  Ledger">
        <outline text="Transactions are stored in fixed-size blocks, these blocks can be represented as merkle trees."/>
    </outline>
    <outline text="Generic">
        <outline text="Checking for inconsistencies in some data structure."/>
    </outline>
</outline>
<outline text="Self Notes:">
    <outline text="When comparing or checking a Merkle tree, it is efficient if most of the data is the same, otherwise more branches of the tree need to be checked."/>
</outline>
                            </outline>
                        </outline>
                        <outline text="SECRET SHARING #h">
                            <outline text="Introduction #slide #arman ">
<outline text="In secret sharing schemes a secret is distributed among a set of users $$\mathcal{P}$$ in such a way that only some sets, the authorised sets, can recover it. "/>
<outline text="Secret sharing schemes are useful for not trusting a single party e.g. two members of staff required to open a vault. "/>
<outline text="Similar challenges can arise in other sensitive areas where a secret should be recovered only if certain users, the authorised sets, get together. "/>
                            </outline>
                            <outline text="Linear Algebra #h ">
<outline text="Notations #slide #arman ">
    <outline text="spec($$A$$) -- the spectrum (set of eigenvalues) of the matrix $$A$$."/>
    <outline text="$$\otimes$$ -- the &quot;Kronecker Product&quot;, defined as #todo  "/>
    <outline text="$$V({x_1,\ldots, x_n})$$ -- Vandermonde matrix with entries that are powers of $$x_1, ... , x_n$$."/>
    <outline text="So:&#xA;$$V({x_1,\ldots, x_n}) = \begin{bmatrix}1 &amp; \cdots &amp; 1 \\ x_1 &amp; \cdots  &amp; x_n \\ x_{1}^2 &amp; \cdots &amp; x_{n}^2 \\ \vdots &amp; &amp; \vdots \\ x_{1}^{n-1} &amp; \cdots &amp; x_{n}^{n-1} \end{bmatrix}$$"/>
</outline>
<outline text="Sylvester Equation #slide #arman">
    <outline text="These are matrix equations $$AX - XB = C$$ where $$A$$ and $$B$$ are square matrices of order $$m$$ and $$n$$."/>
    <outline text="Goal is to find the $$m$$ by $$n$$ matrix $$X$$."/>
    <outline text="The following is a well-known fact:">
        <outline text="The sylvester equation admits a unique solution $$X$$, iff $$A$$ and $$B$$ have no eigenvalues in common."/>
        <outline text="In this case, the solution is $$x = (I \otimes A - B^t \otimes I)^{-1} \cdot c$$ where $$x$$ and $$c$$ are the matrices $$X$$ and $$C$$ rearranged as single column vectors."/>
    </outline>
</outline>
<outline text="Conjecture #slide #arman">
    <outline text="Informally:">
        <outline text="Vandermonde-matrices with pairwise different index sequences $$x_1, ..., x_n$$ and $$y_1, ... , y_m$$ have no eigenvalues in common."/>
    </outline>
    <outline text="Formally:">
        <outline text="$$x = (x, ..., x_n), y = (y_1, ... , y_n)$$ and $$x_i \neq y_j (\forall i, j)\Leftrightarrow$$ spec($$V_x$$) $$\cap$$ spec($$V_y$$) = $$\emptyset$$."/>
    </outline>
</outline>
                            </outline>
                            <outline text="Notations #slide #arman ">
<outline text="Let denote $$\mathcal{P} =\{P_1, P_2, ...,P_n\}$$ be a set of parties."/>
                            </outline>
                            <outline text="Interpolation #h">
<outline text="Bivariate #h">
    <outline text="$$l_j(x) = \frac{(x - x_0)}{(x_j - x_0)} \ldots \frac{(x - x_k)}{(x_j - x_k)} = \displaystyle\prod_{\substack{0 \leq m \leq k\\ m \neq j}} \frac{x - x_m}{x_j - x_m}$$"/>
    <outline text="$$L(x) = \displaystyle \sum^k_{j=0} y_j l_j(x)$$"/>
    <outline text="$$L(x,z) = \sum^{k^2}_{j=0} (y_j l_j(x))  l_e(z)$$"/>
</outline>
                            </outline>
                            <outline text="On Access Structures #h #arman ">
<outline text="Access Structures #slide #arman">
    <outline text="Given a set of players $$\mathcal{P} = \{{P}_1, \ldots , {P}_n\}$$, the family $$\Gamma  \subset 2^\mathcal{P}$$ of __authorized sets__ is the __access structure__ of the secret sharing scheme."/>
    <outline text="Example: for $$n=3$$ parties $$P_1 , P_2, P_3$$ that participate in a secret sharing scheme with threshold $$k=2$$,  the authorised sets are $$\{P_1, P_2\}$$, $$\{P_1 , P_3\}$$, $$\{P_2, P_3\}$$ and $$\{P_1, P_2, P_3\}$$."/>
    <outline text="A collection $$\Gamma \subseteq 2^\mathcal{P}$$ is __monotone__ if: $$\mathcal{V} \in \Gamma$$ and $$\mathcal{V} \subseteq \mathcal{W} \Rightarrow \mathcal{W} \in \Gamma $$."/>
    <outline text="Usually, access structures are monotone collections."/>
</outline>
<outline text="Compartmented Access Structures #slide #arman ">
    <outline text="Denote $$\mathcal{C} = \{\mathcal{C}_1,...,\mathcal{C}_m \}$$ a partition of $$\mathcal{P}$$ into $$m$$ disjoint subsets, or __compartments__: $$\mathcal{P} = \bigcup^m_{i=1} \mathcal{C}_i$$."/>
    <outline text="Let ">
        <outline text="$$t_i \in \mathbb{N}$$ ($$1 \leq i \leq m$$), and $$\sum^m_{i=1} t_i \le t \in \mathbb{N}$$,"/>
        <outline text="$$s_i \in \mathbb{N}$$ ($$1 \leq i \leq m$$), and $$\sum^m_{i=1} s_i \ge s \in \mathbb{N}$$. "/>
    </outline>
    <outline text="A __compartemented access structure__ with __lower__ (__upper__ respectively) __bounds__ consists of all subsets containing at least $$t_i$$ (at most $$s_i$$) participants from $$C_i$$ for $$1 \leq i \leq m$$, and a total of at least $$t$$ ($$s$$ respectively) participants."/>
    <outline text="Formally: ">
        <outline text="$$\Gamma = \{\mathcal{V} \subseteq \mathcal{P} : \exists \mathcal{W} \subseteq \mathcal{V}$$ such that $$|\mathcal{W} \cap \mathcal{C}_i | \geq t_i, 1 \leq i \leq m$$, and $$ |\mathcal{W}| = t \}$$."/>
        <outline text="$$\Delta= \{\mathcal{V} \subseteq \mathcal{P} : \exists \mathcal{W} \subseteq \mathcal{V}$$ such that $$|\mathcal{W} \cap \mathcal{C}_i | \le s_i, 1 \leq i \leq m$$, and $$ |\mathcal{W}| = s \}$$."/>
    </outline>
    <outline text="Original notion by @Simmons had $$\sum^m_{i=1} t_i = t $$, later generalised by @Brickell. "/>
    <outline text="Boolean Algebra:">
        <outline text="__Minterm is a product (AND) of all variables in a function where the result is True only for one variable. __"/>
        <outline text="__Maxterm is a sum (OR) of all variables in a function where the result is False only for one variable.__"/>
    </outline>
    <outline text="Types of Compartments:">
        <outline text="$$m = 1$$ $$\text{--}$$ standard threshold access structure of Shamir."/>
        <outline text="$$m = 2$$">
            <outline text="Lower bounds $$t_1, t_2$$, threshold $$t$$."/>
            <outline text="Upper bounds $$s_1 = t - t_2, s_2 = t - t_1$$ and $$s = t$$."/>
            <outline text="$$t_1 = s - s_2, t_2 = s - s_1$$ and $$t = s$$."/>
        </outline>
        <outline text="$$m \geq 3$$">
            <outline text="$$t_1 = 1, t_2 = 1, t_3 = 1$$ and $$t = 4$$ has minterms $$\mathcal{V}$$ of types $$(1,1,2)$$ (namely, $$|\mathcal{V}\cap \mathcal{C}_1| = 1, |\mathcal{V} \cap \mathcal{C}_2 | = 1, $$ and $$|\mathcal{V} \cap \mathcal{C}_3| = 2$$)."/>
            <outline text="$$(1,2,1)$$ or $$(2, 1, 1)$$"/>
            <outline text=""/>
        </outline>
    </outline>
</outline>
<outline text="Multipartite Access Structures #slide #arman ">
    <outline text="Let $$\Gamma \in 2^\mathcal{P}$$ be a compartmented access structure."/>
    <outline text="An $$m$$-__partite__ (or __multipartite__) access structure on $$\mathcal{P}$$ with respect to partition $$\mathcal{C}$$ is any access structure that does not distinguish between members of the same compartment."/>
    <outline text="Formally:">
        <outline text="Assume that for all permutations $$\pi : \mathcal{P} \rightarrow \mathcal{P}$$ such that $$\pi(\mathcal{C}_i) =\mathcal{C_i}\;(1 \leq i \leq m), \;\mathcal{V} \in \Gamma$$ if and only if $$\pi(\mathcal{V}) \in \Gamma$$. "/>
        <outline text="Then $$\Gamma$$ is called $$m$$-__partite__ or __multipartite__ with respect to partition $$\mathcal{C}$$."/>
    </outline>
    <outline text="Given any subset $$\mathcal{W} \subseteq \mathcal{U}$$, its __type__ with respect to partition (1) is the vector $$(t_1,...,t_m) \in \mathbb{N}^m $$, where $$t_i = |\mathcal{W} \cap \mathcal{C}_i |, 1 \leq i \leq m.$$"/>
</outline>
                            </outline>
                            <outline text="Secret Sharing Schemes #h">
<outline text="Univariate #h">
    <outline text="Interpolation #h">
        <outline text=""/>
    </outline>
    <outline text="Shamir's Secret Sharing (SSS) [cited: 16821] #h ">
        <outline text="Lagrange Interpolation Version">
            <outline text="Description #slide">
                <outline text="Alice has a secret $$s$$ and wants to share it out to $$n$$ others. The secret is split up so that only $$k$$ pieces can recover $$s$$."/>
            </outline>
            <outline text="Notation #slide">
                <outline text="$$s =$$ secret"/>
                <outline text="$$p =$$ prime"/>
                <outline text="$$a_i \in \{a_1,...,a_i\}$$ random integers"/>
                <outline text="$$k =$$ threshold to recover $$s$$"/>
                <outline text="$$n =$$ number of shares"/>
                <outline text="$$y =$$ secret share"/>
                <outline text="$$l =$$ lagrange basis polynomial"/>
            </outline>
            <outline text="Generating shares #slide">
                <outline text="Objective is to create $$n$$ shares using random integers $$a_i$$."/>
                <outline text="$$a_0 = s$$"/>
                <outline text="$$f(x) = \sum_{i=0}^{k-1} a_i \cdot x^i \pmod{p}$$"/>
                <outline text="Using $$f(x_i) = y$$ where $$x_i \in \{1,...,n\}$$"/>
                <outline text="This creates shares $$(x_i, y_i)$$"/>
            </outline>
            <outline text="Recovering a Secret #slide ">
                <outline text="Objective is to find $$a_0$$ using $$k$$ number of shares $$(x_i,y_i)$$ using Lagrange polynomial interpolation."/>
                <outline text="Lagrange basis polynomial $$l_j(x) = \prod_{m=0;m\neq j}^{k-1} \frac{x_m}{x_m-x_j}$$"/>
                <outline text="Secret $$= \sum_{j=0}^{k} y_j \cdot l_j$$"/>
                <outline text="Therefore:">
                    <outline text="$$a_0 = \lceil ( \sum_{j=0}^{k-1} y_j \cdot \prod_{ m=0; m\neq j }^{k-1}\frac{x_m}{x_m - x_j}) + p \pmod{p}\rceil$$"/>
                </outline>
            </outline>
        </outline>
        <outline text="Matrix Version">
            <outline text="Principle #slide">
                <outline text="View the evaluation of Shamir polynomial $$f(x)$$ at point $$x_i$$ as vector multiplication:">
                    <outline text="$$f(x_i) = (1, x_i , x_i^2, ..., x_i^{k-1}) \cdot \begin{bmatrix}s \\ a_1 \\ a_2 \\ \vdots \\ a_{k-1} \end{bmatrix}$$. "/>
                </outline>
                <outline text="Hence, the following matrix equations contains all shares $$(x_i, f(x_i) = y_i)$$ for $$i = 1, ..., n$$:">
                    <outline text="$$V_{(x_1,...,x_n)} := \begin{bmatrix} 1 &amp; x_1 &amp; x_1^2 &amp; \cdots &amp; x_1^{k-1} \\ 1 &amp; x_2 &amp; x_2^2 &amp; \cdots &amp; x_2^{k-1} \\ \vdots &amp; \vdots &amp; \vdots &amp; &amp;\vdots \\ 1 &amp; x_n &amp; x_n^2 &amp; \cdots &amp; x_n^{k-1} \end{bmatrix} \cdot \begin{bmatrix} s \\ a_1 \\ a_2 \\ \vdots \\ a_{k-1} \end{bmatrix} = \begin{bmatrix} y_1 \\ y_2 \\ \vdots \\ \\ y_{k-1} \end{bmatrix}$$. "/>
                </outline>
            </outline>
            <outline text="Reconstruction of Secret #slide ">
                <outline text="This is possible if the Vandermonde matrix is square and invertible."/>
                <outline text="Choose a coalition $$\{x_i,...,x_{in}\}$$ of distinct points. Then:">
                    <outline text="$$\begin{bmatrix} s \\ a_1 \\ a_2 \\ \vdots \\ a_{k-1} \end{bmatrix} = \begin{bmatrix} 1 &amp; x_1 &amp; x_1^2 &amp; \cdots &amp; x_1^{k-1} \\ 1 &amp; x_2 &amp; x_2^2 &amp; \cdots &amp; x_2^{k-1} \\ \vdots &amp; \vdots &amp; \vdots &amp; &amp;\vdots \\ 1 &amp; x_n &amp; x_n^2 &amp; \cdots &amp; x_n^{k-1} \end{bmatrix}^{-1} \cdot \begin{bmatrix} y_1 \\ y_2 \\ \vdots \\ \\ y_{k-1} \end{bmatrix}$$. "/>
                </outline>
            </outline>
        </outline>
    </outline>
    <outline text="SSS with ECC #h">
        <outline text="Using ECC a $$(t,n)$$ threshold signature scheme is possible:">
            <outline text="The participants establish a shared key by exchanging public keys:">
                <outline text="Party $$A$$ sends $$aG \pmod{p}$$, Party $$B$$ sends $$bG \pmod{p}$$."/>
                <outline text="Parties compute shared key: $$abG \pmod{p}$$."/>
            </outline>
            <outline text="Using SSS, a secret message is split into $$n$$ of threshold $$t$$. These shares are converted into EC points:">
                <outline text="Message $$m_i$$ is converted into Point $$P_i = m_i + abG$$."/>
            </outline>
            <outline text="If Part $$A$$ is the dealer and gives $$t$$ points to Party $$B$$, the points can be turned back to shares:">
                <outline text="$$m_i = P_i - abG$$."/>
            </outline>
        </outline>
    </outline>
    <outline text="Blakley $$\text{--}$$ Secret Sharing [cited: 5248] #h ">
        <outline text="Principle #slide ">
            <outline text="Threshold $$t$$."/>
            <outline text="Prime $$P$$."/>
            <outline text="Random integer vectors $$a$$ and $$b$$."/>
            <outline text="Secret point $$x_0$$."/>
            <outline text="Random points $$y_0,z_0$$."/>
            <outline text="$$z_i = z_0 - a_i x_0 - b_i y_0 \pmod{P}$$"/>
            <outline text="$$\begin{bmatrix} a_1 &amp; b_1 &amp; -1 \\ \vdots &amp; &amp; \vdots \\ a_i &amp; b_i &amp; -1 \end{bmatrix} \cdot \begin{bmatrix} z_1 \\ \vdots \\ z_i \end{bmatrix} = \begin{bmatrix} x_0 &amp; y_0 &amp; z_0 \end{bmatrix}$$"/>
        </outline>
        <outline text="Example #slide ">
            <outline text="Parameters">
                <outline text="$$t = 3$$ "/>
                <outline text="$$P = 73$$"/>
                <outline text="$$x_0 = 13, y_0 = 21, z_0 = 5$$"/>
                <outline text="$$a = \begin{bmatrix}3 &amp; 68 &amp; 10 \end{bmatrix}$$"/>
                <outline text="$$b = \begin{bmatrix}71 &amp; 54 &amp; 23\end{bmatrix}$$"/>
            </outline>
            <outline text="Calculating Shares:">
                <outline text="$$z_1 = 5 - (3\times 13) - (71\times 21) \bmod{73} = 8$$ "/>
                <outline text="$$z_2 = 5 - (68 \times 13) - (54 \times 21) \bmod{73} = 31$$"/>
                <outline text="$$z3 = 5 - (10 \times 13) - (23 \times 21) \bmod{73} = 49$$"/>
            </outline>
            <outline text="Recovering Shares:">
                <outline text="$$\begin{bmatrix} 3 &amp; 71 &amp; -1 \\ 68 &amp; 54 &amp; -1 \\ 10 &amp; 23 &amp; -1 \end{bmatrix}^{-1} \cdot \begin{bmatrix} 8 \\ 31 \\ 49 \end{bmatrix} = \begin{bmatrix} 13 &amp; 21 &amp; 5 \end{bmatrix} \pmod{73}$$ "/>
            </outline>
        </outline>
    </outline>
    <outline text="Herzberg et al. $$\text{--}$$ Proactive Secret Sharing [cited:1034] #h ">
        <outline text="Introduction">
            <outline text="Secrets that are shared and are expected to persist may give enough time for adversaries to attack the secret sharing scheme. A periodic refreshing of shares is proposed"/>
        </outline>
        <outline text="Constraints">
            <outline text="&quot;Can support up to $$k = n/2 - 1$$ corrupted parties at any time period.&quot;"/>
        </outline>
        <outline text="Principle">
            <outline text="Dealer coefficients vector $$a \in \mathbb{Z}_q$$ of length threshold $$k$$ where $$a_0$$ is the secret."/>
            <outline text="Participants generate their own random value vector $$r \in \mathbb{Z}_q$$ although will set the secret to $$0$$."/>
            <outline text="Dealer Poly: $$f_0(x) = a_0 + a_1x + a_2x^2 +... + a_ix^i$$ "/>
            <outline text="Participant Poly: $$f_i(x) = 0 + r_1x + r_2x^2 + ... + r_ix^i$$"/>
            <outline text="Refreshed Shares: $$f'_i(x) = f_0(x) + f_1(x) + ... + f_i(x)$$"/>
            <outline text="Recovering Secret: $$\begin{bmatrix} 1 &amp; 1 &amp; 1  \\ 1 &amp; 2 &amp; 4 \\ \vdots &amp; &amp; \vdots \\ i^0 &amp; \dots &amp; i^k \end{bmatrix}^{-1} \cdot \begin{bmatrix} f'(1) \\ f'(2) \\ \vdots \\ f'(i) \end{bmatrix} = f'(0)_{[0,0]}$$ "/>
        </outline>
    </outline>
</outline>
<outline text="Bivariate #h ">
    <outline text="Interpolation #h">
        <outline text="For a function $$F(x,y)$$ the coefficients may be found by inverting a vandermonde matrix of $$x$$ and $$y$$ and multiplying with the respective results of the $$F(x,y)$$."/>
        <outline text="$$F(x,y) = a_{00} + a_{10}x + a_{01}y + a"/>
        <outline text="$$\begin{bmatrix} F( \end{bmatrix}"/>
    </outline>
    <outline text="Shah $$\text{--}$$ Secret Share Dissemination [cited: 4] #h ">
        <outline text="Notations and Definitions #h">
            <outline text="General #slide">
                <outline text="$$\mathbb{F}_q$$ -- finite field of characteristic $$q$$ where $$q &gt; n$$"/>
                <outline text="$$\mathcal{A} = \mathbb{F}^{d-k+1}_{q}$$ -- input alphabet"/>
            </outline>
            <outline text="Network #slide">
                <outline text="$$n$$ -- overall number of nodes/shares"/>
                <outline text="$$i$$ -- unique node index $$(1 \leq i \leq n)$$"/>
                <outline text="$$\mathcal{N}(j)$$ -- set of neighbours for any node $$j$$ $$(1 \leq j \leq n)$$"/>
                <outline text="$$d$$ -- parameter for propagating dealer property"/>
            </outline>
            <outline text="Shamir #slide">
                <outline text="$$k$$ -- number of different shares required to recover secret"/>
                <outline text="$$s$$ -- secret"/>
                <outline text="$$f(x)$$ -- share polynomial function"/>
                <outline text="$$\psi_{i}^{T} = [1,i,i^2,...,i^{d-1}]$$ -- encoding vector for node $$i$$"/>
                <outline text="$$\Psi$$ -- Vandermonde matrix of dimension $$n \times d$$ (each row being $$\psi_{i}^{T}$$)"/>
            </outline>
            <outline text="Shah et al #h">
                <outline text="Assumption: propagating dealer property $$d \geq k$$ "/>
                <outline text="Fact: $$d &gt; k$$: increases communication efficiency "/>
                <outline text="$$s^T = [s_1, s_2,...,s_{d-k+1}]$$ -- secret vector"/>
                <outline text="$$M = \begin{bmatrix} s_a &amp; r_a^T &amp; s_b^T \\ r_a &amp; R_b &amp; R_c^T \\ s_b &amp; R_c &amp; 0\end{bmatrix}$$ -- secret matrix">
                    <outline text="$$s_a = s_{d-k+1}$$"/>
                    <outline text="$$r_a$$ is a $$((k - 1) \times 1)$$ is a vector of length $$(k - 1)$$."/>
                    <outline text="$$s_b = [s_1, ... , s_{d-k}]^T$$"/>
                    <outline text="$$R_b$$ is a $$(k - 1) \times (k - 1)$$ symmetric matrix with its $$\frac{k(k - 1)}{2}$$ entries populated by random values"/>
                    <outline text="$$R_c$$ is a $$(d - k) \times (k - 1)$$ matrix with its $$(d - k)(k - 1)$$ entries populated by random values"/>
                </outline>
                <outline text="$$t_j^T = \psi_j^T\begin{bmatrix}s_a &amp; s_b^T\\r_a &amp; R_c^T \\ s_b &amp; 0\end{bmatrix}$$ -- participant share"/>
                <outline text="$$\begin{bmatrix}\sigma_1  \\ \vdots \\ \sigma_d\end{bmatrix} = \begin{bmatrix} \psi^T_{j_{1}} \\ \vdots \\ \psi^T_{j_{d}}\end{bmatrix} M\psi_{l} $$ -- preliminary values to recreate share"/>
                <outline text="$$v = \begin{bmatrix}\psi^T_{i_1} \\ \vdots \\ \psi^T_{i_d}\end{bmatrix}^{-1} \begin{bmatrix}\sigma_1 \\ \vdots \\ \sigma_d \end{bmatrix}$$ -- recovered vector that is the intended share"/>
            </outline>
        </outline>
        <outline text="Protocol Summary #h">
            <outline text="Aim #slide">
                <outline text="Dissemination i.e. &quot;To disperse throughout&quot; MW of secret shares in a conventional way is subject to eavesdropping of nodes. "/>
                <outline text="This scheme allows participants to receive their intended share without others obtaining it."/>
                <outline text="These shares can then proceed to be used as such in a Shamir's Secret Sharing Scheme $$(k,n)$$."/>
            </outline>
            <outline text="Conditions #slide" listStyle="arabic">
                <outline text="($$k$$-connected-dealer) Out of $$n$$ participants, each is either directly connected to each other or have at least $$k$$ vertex-disjoint paths from itself to the dealer."/>
                <outline text="($$k$$-propagating-dealer) The way the $$n$$ participants are organised in the topology is that every vertex is either directly connected to the dealer or $$k$$ nodes that make a path to it."/>
            </outline>
            <outline text="Dissemination Algorithm #h ">
                <outline text="Parameters #slide">
                    <outline text="$$k$$ -- secret recovery threshold"/>
                    <outline text="$$n$$ -- number of participants to obtain a share"/>
                    <outline text="$$d$$ -- Condition 2's d-propagating-dealer">
                        <outline text="$$d$$ $$(\geq k)$$"/>
                    </outline>
                </outline>
                <outline text="Preamble #slide">
                    <outline text="A vector containing $$(d-k+1)$$ secrets is subject to finite field $$\mathbb{F}_q$$."/>
                </outline>
                <outline text="Dealer Setup #slide ">
                    <outline text="The dealer has functionality to produce the following:">
                        <outline text="$$\psi_{i}$$">
                            <outline text="Vector of geometric progression belonging to node $$i$$ $$(1 \leq i \leq n)$$."/>
                            <outline text="$$\psi_{i}^{T} = [1,i,i^2,...,i^{d-1}]$$"/>
                        </outline>
                        <outline text="$$M$$">
                            <outline text="Symmetric matrix that is a minimum bandwidth regeneration code."/>
                            <outline text="$$M = \begin{bmatrix} s_a &amp; r_a^T &amp; s_b^T \\ r_a &amp; R_b &amp; R_c^T \\ s_b &amp; R_c &amp; 0\end{bmatrix}$$">
<outline text="$$s_a = s_{d-k+1}$$"/>
<outline text="$$r_a$$ is a $$((k - 1) \times 1)$$ is a vector of length $$(k - 1)$$."/>
<outline text="$$s_b = [s_1, ... , s_{d-k}]^T$$"/>
<outline text="$$R_b$$ is a $$(k - 1) \times (k - 1)$$ symmetric matrix with its $$\frac{k(k - 1)}{2}$$ entries populated by random values"/>
<outline text="$$R_c$$ is a $$(d - k) \times (k - 1)$$ matrix with its $$(d - k)(k - 1)$$ entries populated by random values"/>
                            </outline>
                        </outline>
                    </outline>
                </outline>
                <outline text="**share_dissemination**($$l, k, d$$):">
                    <outline text="**if** $$l=D$$ **then**">
                        <outline text="// Node $$l$$ is dealer. //"/>
                        <outline text="Create the code matrix $$M$$;"/>
                        <outline text="**send** share vector data $$\psi_{j}^T M$$ to all neighbours $$j \in \mathcal{N}(D)$$;"/>
                    </outline>
                    <outline text="**elif** $$l \in \mathcal{N}(D)$$ **then**">
                        <outline text="// Node $$l$$ is direct neighbour of dealer. //"/>
                        <outline text="**receive** share vector $$\psi_l^T M$$ from the dealer;"/>
                        <outline text="**for all** $$j \in \mathcal{N}(l)$$ **do**">
                            <outline text="**send** scalar data $$\psi_{l}^T M \psi_{j}$$ to neighbour node $$j$$;"/>
                        </outline>
                    </outline>
                    <outline text="**else**">
                        <outline text="// Now $$l \not\in \mathcal{N}(D)$$ -- node $$l$$ is not a direct neighbour of dealer. //"/>
                        <outline text="**receive** scalars $$\sigma_{j_1},\ldots \sigma_{j_d}$$ from any $$d$$ neighbours $$j_1,\ldots,j_d$$;"/>
                        <outline text="Compute vector $$v = \begin{bmatrix} \quad &amp; \psi_{j_1}^T &amp; \quad \\ \quad &amp; \vdots &amp; \quad\\ \quad &amp; \psi_{j_d}^T &amp; \quad \end{bmatrix}^{-1} \begin{bmatrix} \sigma_{j_1} \\ \vdots \\ \sigma_{j_d} \end{bmatrix}$$;"/>
                        <outline text="**for all** $$j \in \mathcal{N}(l) \setminus \{{j_1},\ldots {j_d}\}$$ **do** ">
                            <outline text="**send** scalar data $$v^T\psi_{j}$$ to neighbour node $$j$$;"/>
                        </outline>
                    </outline>
                    <outline text="**fi**;"/>
                </outline>
            </outline>
            <outline text="Scheme Properties #slide">
                <outline text="$$k$$-secret-recovery">
                    <outline text="Any $$k$$ shares can recover the secret."/>
                </outline>
                <outline text="$$(k - 1)$$-collusion-resistance">
                    <outline text="No knowledge can be gained from $$k - 1$$ shares."/>
                </outline>
                <outline text="$$M$$ matrix symmetry">
                    <outline text="$$\psi_j M \psi_l = \psi_l M \psi_j$$"/>
                    <outline text="This allows nodes to pass on a regenerative code  to a node."/>
                    <outline text="After enough aggregates of such code, the intended share is recovered."/>
                </outline>
            </outline>
        </outline>
        <outline text="Addition of New Participant">
            <outline text="A participant that replaces the dealer"/>
            <outline text="Must be approved by $$d$$ existing participants."/>
            <outline text="$$k$$ parameter is the threshold to recover the secret whilst $$d$$ is the threshold consensus to add a new participant."/>
            <outline text=""/>
        </outline>
        <outline text="Handover share to another">
            <outline text="$$\begin{bmatrix} 1 &amp; 2 &amp; 4 \\ 1 &amp; 3 &amp; 9 \\ 1 &amp; 4 &amp; 16 \end{bmatrix}^{-1} \cdot \begin{bmatrix} \psi_1 M \psi_2^T \\  \psi_1 M \psi_3^T \\ \psi_1 M \psi_4^T\end{bmatrix} = \psi_1 M$$"/>
        </outline>
        <outline text="Applications">
            <outline text="Given by Paper">
                <outline text="Layered Network"/>
                <outline text="Backbone Network"/>
                <outline text="One-Dimensional Geometric Network"/>
            </outline>
            <outline text="Cryptocurrency">
                <outline text="Shared and Proactive Asset Ownership">
                    <outline text="Participants can use Shah Secret Share Dissemination to share ownership with a new participant without the dealer's intervention."/>
                </outline>
            </outline>
        </outline>
    </outline>
    <outline text="Tamir Tassa $$\text{--}$$ Secret Sharing Scheme 1 #h ">
        <outline text="~~Notes~~">
            <outline text="&quot;What makes bivariate interpolation suitable for multipartite settings is the ability to associate each compartment with a different line in the plane. Namely, participants from a given compartment are associated with points that lie on the same line, where each compartment is associated with a different line.&quot; "/>
            <outline text="$$P_i(0) = $$secret, $$i \in \{1,...,m\}$$ of $$m$$ compartments, the Lagrange Polynommials are of degree $$m - 1$$."/>
            <outline text="Description #h #slide">
                <outline text="Parameters">
                    <outline text="$$m$$ Compartments "/>
                </outline>
                <outline text="Secret $$S \in \mathbb{F}$$ to be shared."/>
                <outline text="Let $$x_i, 1 \leq i \leq m$$, be $$m$$ distinct random points in $$\mathbb{F}$$."/>
                <outline text="Let $$P_i(y) = \sum^{s_i - 1}_{j=0} a_{i,j} y^j, 1 \leq i \leq m$$, be random polynomials over $$\mathbb{F} \ni S = \sum^{m}_{i=1} \sum^{s_i - 1}_{j=0} a_{i,j}$$. "/>
                <outline text="Maximum number of participants in compartment is $$s_i$$."/>
                <outline text="Upper bounds from set of participants is $$s$$, where $$s \in \mathbb{N}, s \leq \sum^m_{i=1}s_i$$."/>
                <outline text="$$P(x,y) = \sum^{m}_{i=1} P_i(y) L_i(x) = \sum^{m}_{i=1} \sum^{s_i - 1}_{j=0} a_{i,j} y^j L_i(x)$$ where $$L_i(x)$$ are the Lagrange polynomials of degree $$m - 1$$ over $$\{ x_i : 1 \leq i \leq m\}$$, namely $$L_i(x) = \prod_{1 \leq j \leq m, j \neq i} \frac{x - x_j}{x_i - x_j}$$."/>
                <outline text="These polynomials have the property that $$L_i(x_j) = \delta_{i,j} \forall 1 \leq i,j \leq m$$."/>
                <outline text="$$\therefore P(x,y) = \displaystyle \sum^{m}_{i=1} \sum^{s_i - 1}_{j=0} a_{i,j}y^j  \prod_{1 \leq j \leq m, j \neq i} \frac{x - x_j}{x_i - x_j}$$."/>
            </outline>
            <outline text="Steps" listStyle="arabic"/>
            <outline text=""/>
        </outline>
        <outline text="Description">
            <outline text="The access structure contains Participants $$\mathcal{U} = \{u_1,...,u_n\}$$ which are partitioned into $$m$$ compartments $$\mathcal{P} = \{\mathcal{C_1},...,\mathcal{C_m}\}$$. Therefore a participants can be assigned to compartment as denoted by $$u_{i,j}$$ from Compartment $$i$$. The scheme is evaluted in a finite field $$\mathbb{F}_p$$ of prime $$p$$."/>
            <outline text="The Access Structure $$\Gamma$$ contains only authorised sets of participants $$\mathcal{V} \subseteq \mathcal{U}$$. An authorised set $$\mathcal{V} \in \Gamma$$ and $$\mathcal{V} \subseteq \mathcal{W}$$ implies that $$\mathcal{W} \in \Gamma$$."/>
            <outline text="Shamir's secret sharing scheme is a lower bound access structure where an authorised subset must be at least some threshold $$t$$.">
                <outline text="Threshold $$t_i \leq |\mathcal{W} \cap \mathcal{C_i}|$$ where $$1 \leq i \leq m$$ and $$|\mathcal{W}| = t$$."/>
            </outline>
            <outline text="This scheme is however an upper bound access structure which is denoted as $$\Delta$$ instead of $$\Gamma$$.">
                <outline text="The threshold $$s_i \geq |\mathcal{W} \cap \mathcal{C}_i |$$ where $$1 \leq i \leq m$$ and $$|\mathcal{W}| = s$$. Each compartment $$\mathcal{C}_i$$ is attributed with the corresponding threshold $$s_i$$. "/>
                <outline text="This thresholds limit the number of participants in the authorised subset where $$s \leq \sum^{m}_{i=1}s_i$$."/>
                <outline text="If the threshold is greater than the number of authorised participants then there must be additional public information in order to meet the threshold denoted by $$k = (\sum^{m}_{i=1}s_i) - s$$."/>
            </outline>
            <outline text="Each Participant $$u_{i,j}$$ from Compartment $$\mathcal{C}_i$$ is identified by a public point $$(x_i, y_{i,j})$$, where $$y_{i,j} \neq 1$$ is random, and his private is $$P(x_i, y_{i,j})$$.">
                <outline text="Co-ordinate $$x_i$$ corresponds to the compartment $$\mathcal{C}_i$$ which will contain at most $$s_i$$ participants. "/>
                <outline text=" $$P_i(y) = \displaystyle \sum^{s_i -1}_{j=0} a_{i,j} y^j, 1 \leq i \leq m$$, $$a_{i,j}$$ are uniformly chosen random integer except $$a_{i,0}$$ which corresponds to the secret of the compartment."/>
                <outline text="$$L_i(x) = \displaystyle \prod_{\substack{ 1 \leq j \leq m \\ j \neq i}} \frac{x - x_j}{x_i - x_j}, 1 \leq i \leq m$$. This function has the property of the kronecker delta $$\delta_{i,j} = L_i(x_j)$$.">
                    <outline text="With modular arithmetic it may be computed as:">
                        <outline text="$$L_i(x) = \displaystyle \prod^{s_i -1}_{\substack{ 1 \leq j \leq m \\ j \neq i}} (x - x_j) \times (x_i - x_j)^{p-2} \pmod{p}$$"/>
                    </outline>
                </outline>
                <outline text="$$P(x,y) = \displaystyle \sum^{m}_{i=1} P_i(y) L_i(x) \pmod{p}$$."/>
            </outline>
            <outline text="Additionally, the value of $$P$$ at $$k$$ random points are shared publicly at $$(x_i',z_i), 1 \leq i \leq k$$ where $$x_i' \not \in \{x_1,...,x_m\}$$ and $$z_i$$ are random uniformly chosen integer.">
                <outline text="When computing the Lagrange polynomial $$L_i(x), x \in \{x_1,...,x_m\}$$ even when inputing $$x_j'$$."/>
            </outline>
            <outline text="The scheme may be constructed with square matrix $$M$$ which must be invertible:"/>
            <outline text="$$M = \begin{bmatrix} M_1 &amp; 0 &amp; \dots &amp; 0 \\ 0 &amp; M_2 &amp; \dots &amp; 0  \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp; \dots &amp; M_m \\ H_1 &amp; H_2 &amp; \dots &amp; H_m \end{bmatrix}$$"/>
            <outline text="Block $$M_i$$ of size $$k_i \times s_i$$ is a vandermonde matrix representing the authorised set containing participants $$\mathcal{V} \cap \mathcal{C}_i = \{u_{i,1},...,u_{i,k_i}\}, 1 \leq i \leq m$$. $$k_i$$ must not be confused with a relation to $$k$$ as $$k$$ still denotes the additional public shares:"/>
            <outline text="The authorised set can be organised in different combinations of $$| \mathcal{V} \cap \mathcal{C}_i | \leq s_i$$ where $$s_i - | \mathcal{V} \cap \mathcal{C}_i|$$ is the number of public points to use in order to recover the secret. Therefore an authorised set where $$m = 3, s_1 = s_2 = s_3 = 3$$ and $$s = 6\therefore k = 3$$ can have authorised set access structure of $$|\mathcal{V} \cap \mathcal{C}_1| = 3, |\mathcal{V} \cap \mathcal{C}_2 = 2, |\mathcal{V} \cap \mathcal{C}_3| = 1, (3,2,1), (2,3,1)$$ or $$(1,3,2)$$, etc..."/>
            <outline text="$$M_i = \begin{bmatrix}1 &amp; y_{i,1} &amp; y_{i,1}^2 &amp;\dots &amp;y_{i,1}^{s_i -1} \\ 1 &amp; y_{i,2} &amp; y_{i,2}^2 &amp; \dots &amp; y_{i,2}^{s_i-1} \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 1 &amp; y_{i,k_i} &amp; y_{i,k_i}^2 &amp; \dots &amp; y_{i,k_i}^{s_i-1} \end{bmatrix}$$"/>
            <outline text="$$H_i = \begin{bmatrix} L_i (x'_1) &amp; L_i (x'1) z_1 &amp; L_i (x'1) z_1^2 &amp; \dots &amp; L_i(x'1) z_1^{s_i -1}  \\ L_i (x'_2) &amp; L_i (x'_2) z_2 &amp; L_i(x'2) z_2^2 &amp; \dots &amp; L_i(x'_2) z_2^{s_i-1}   \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ L_i(x_k') &amp; L_i(x_k')z_k &amp; L_i(x_k') z_k^2 &amp; \dots &amp; L_i(x_k') z_k^{s_i - 1}\end{bmatrix}$$"/>
            <outline text="The coefficients containing the secret and random values are organised in a vector such as:">
                <outline text="$$A = \begin{bmatrix}\text{secret}_1 &amp; a_{1,1} &amp; a_{1,2} &amp; \dots &amp; a_{1,s_i-1} &amp; \dots &amp; \text{secret}_m &amp; a_{m,1} &amp; a_{2,m} &amp; \dots a_{m,s_i - 1}\end{bmatrix}^T$$"/>
            </outline>
            <outline text="Therefore computing shares is multiplication of $$M \times A = R$$."/>
            <outline text="And recovering a compartment may be done by inverting $$M$$ or some $$M_i$$ combined with the corresponding $$H_i$$."/>
            <outline text=""/>
        </outline>
        <outline text="Example">
            <outline text="$$m = 2, s = \{3,3\}, $$"/>
            <outline text="$$x = \{1,4\}$$"/>
            <outline text="$$k = 2$$"/>
            <outline text="$$x' = \{2,3\},z = \{5,3\}$$"/>
            <outline text="$$p = 47$$"/>
            <outline text="Matrix Construction $$M$$:">
                <outline text="$$M = \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\ 1 &amp; 2 &amp; 4 &amp; 0 &amp; 0 &amp; 0 \\ 1 &amp; 3 &amp; 9 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 4 &amp; 16 \\ L_1(2) &amp; L_1(2) 5 &amp; L_1(2) 5^2 &amp; L_2(2) &amp; L_2(2) 5 &amp; L_2(2) 5^2 \\ L_1(3) &amp; L_1(3) 3 &amp; L_1(3) 3^2 &amp; L_2(3) &amp; L_2(3) 3 &amp; L_2(3) 3^2 \end{bmatrix}$$"/>
            </outline>
            <outline text="Coefficient Vector where $$5$$ is compartment $$C_1$$'s secret and $$8$$ is compartment $$C_2$$'s secret:">
                <outline text="$$A = \begin{bmatrix} 5 \\ 10 \\ 15 \\ 8 \\ 12 \\ 18 \end{bmatrix}$$"/>
            </outline>
            <outline text="Creation of Shares is a multiplication of matrices $$M \times A$$:">
                <outline text="$$M \times A = \begin{bmatrix} 30 \\ 38 \\ 29 \\ 15 \\ 5 \\ 6 \end{bmatrix} \pmod{p}$$"/>
            </outline>
            <outline text="Therefore the secrets may be recovered by computing the inverse of $$M$$ or some $$M_i$$ and multiplying with the corresponding shares:">
                <outline text="Compartment 1 secret $$= M_1^{-1} \times \begin{bmatrix} 30 \\ 38 \\ 29 \end{bmatrix} =  \begin{bmatrix} 5 &amp; 10 &amp; 15 \end{bmatrix} \pmod{p}$$"/>
                <outline text="Compartment 2 lacks authorised participants which means it will need to use the public points to recover the secret. In order to create an invert matrix, $$M_2$$ and $$H_2$$ are combined:">
                    <outline text="$$\begin{bmatrix} M_2 \\ H_2 \end{bmatrix}^{-1} \times \begin{bmatrix} 15 \\ 5 \\ 6 \end{bmatrix} = \begin{bmatrix} 8 &amp; 12 &amp; 18 \end{bmatrix} \pmod{p}$$"/>
                </outline>
                <outline text="The whole matrix $$M$$ can also be inverted providing it is multiplied with all the shares originally produced:">
                    <outline text="$$M^{-1} \times \begin{bmatrix} 30 \\ 38 \\ 29 \\ 15 \\ 5  \\6  \end{bmatrix} = \begin{bmatrix} 5 &amp; 10 &amp; 15 &amp; 8 &amp; 12 &amp; 18\end{bmatrix} \pmod{p}$$ "/>
                </outline>
            </outline>
        </outline>
    </outline>
    <outline text="Lein Harn Extended $$\text{-- }(t,n)$$ Secure Share Reconstruction [cited: 11] #h ">
        <outline text="Archive">
            <outline text="Related Work #slide ">
                <outline text="Proactive secret sharing scheme by Ostrovasky and Yung 1991">
                    <outline text="Update shares periodically so that tampering or shares lost can still be recovered but also updated without changing the secret"/>
                </outline>
                <outline text="Threshold changeable secret sharing scheme (TCSSs) by Martin et al. 1999">
                    <outline text="Shareholders can work together to to refresh original shares from the dealer so that the threshold of the same secret can be changed. "/>
                    <outline text="There are three categories of TCSSs:">
                        <outline text="Linear polynomial"/>
                        <outline text="Geometry"/>
                        <outline text="Chinese Remainder Theorem"/>
                    </outline>
                    <outline text="TCSSs require a pairwise secure channels between shareholders due to the protocol being interactive."/>
                    <outline text="There is also a lattice based TCSSs called &quot;TCSS without a dealer&quot; by Steinfield et. al in 2004 that does not need any secure channels."/>
                </outline>
            </outline>
            <outline text="Contributions">
                <outline text="A new definition of secure secret reconstruction introduced"/>
                <outline text="A basic SSR scheme based on Shamir's $$(t,n)$$ threshold secret sharing scheme"/>
                <outline text="An SSR scheme based on symmetric bivariate polynomials"/>
                <outline text="An SSR scheme based on asymmetric bivariate polynomials"/>
            </outline>
            <outline text="Models and Definitions">
                <outline text="System model">
                    <outline text="$$n$$ shareholders $$\{U_1, U_2, ..., U_n\}$$"/>
                    <outline text="Among $$n$$ shareholders, at least $$t$$ of them are assumed to be honest, where $$n = 2t - 1$$"/>
                </outline>
                <outline text="Security Definitions">
                    <outline text="**Correctness**, the secret will be successfully reconstructed if all participants are legitimate shareholders and act honestly according to the protocol."/>
                    <outline text="**Secure Secret Reconstruction**, when shares are put together in a $$(t,n)$$ where the number of participants $$j$$ satisfies $$t \leq j \leq n$$, the secret cannot be recovered when as $$j - 1$$"/>
                    <outline text="**Univariate polynomial**, A univariate polynomial is given as $$f(x) = a_0 + a_1x + a_2x^2 + ... + a_{t-1}x^{t-1} \bmod{p}$$ where $$a_i \in GF(p)$$."/>
                    <outline text="**Symmetric bivariate polynomial**, A symmetric bivariate polynomial is given as $$f(x,y) = a_{0,0} + a_{1,0}x + a_{0,1}y + a_{2,0}x^2 + a_{1,1}xy + ... + a_{t-1,0}x^{t-1} + a_{t-2,1}x^{t-1} + ... + a_{t-1,t-1}x^{t-1}y^{t-1} \bmod{p}$$ where $$a_{i,j} \in GF(p)$$, and $$\forall i,j, a_{i,j} = a_{j,i}$$."/>
                    <outline text="**Asymmetric bivariate polynomial**, An asymmetric bivariate polynomial is given as $$f(x,y) = a_{0,0} + a_{1,0}x + a_{0,1}y + a_{2,0}x^2 + a_{1,1}xy + a_{0,2}y^2 + ... + a_{t-1,0}x^{t-1} + a_{t-2}x^{t-2}y + ... + a_{t-1,t-1}x^{t-1}y^{r-1} \bmod{p}$$, where $$a_i,j \in GF(p)$$.">
                        <outline text=""/>
                    </outline>
                    <outline text="**Lagrange Component (LC)**, If shares are generated by a univariate polynomial $$f(x)$$ as $$s_i = f(ID_i), i = 1,2,...,n$$, where $$ID_i$$ is the public information associated with each shareholder."/>
                    <outline text="**Secure secret reconstruction**"/>
                </outline>
            </outline>
            <outline text="Share generation">
                <outline text="If $$r &gt; 2(t -1)$$ and $$tr &gt; n(n-1)$$ then the secret sharing scheme satisfies the SSR property."/>
                <outline text="Dealer selects asymmetric bivariate polynomial $$f(x,y) = a_{0,0} + a_{1,0}x + a_{0,1}y + a_{2,0}x^2 + a_{1,1}xy + a_{0,2}y^2 + ... + a_{t-1,0}x^{t-1} + a_{t-2,1}x^{t-2}y + ... + a_{t-1,t-1}x^{t-1}y^{r-1} \bmod {p}$$, where $$a_{i,j} \in GF(p)$$ and $$a_{0,0} = s$$."/>
                <outline text="Generate shares $$f(x,ID_i), i=1,2,...,n$$"/>
                <outline text="$$x$$ has degree $$t-1$$, $$y$$ has degree $$r-1$$."/>
                <outline text="$$f(ID_i, y), f(x,ID_i)$$ are both univariate polynomials of degree $$r-1$$ in $$y$$ and degree $$t-1$$ in x respectively."/>
            </outline>
            <outline text="Secure secret reconstruction">
                <outline text="$$j$$ participants $$U_l = 1,2,...,j$$ participate to reconstruct the secret where $$n \geq j \geq t$$."/>
                <outline text="Two different pairwise shared keys are computed for $$U_i$$ and $$U_j$$ using shares as $$k_{i,j} = f(ID_i, ID_j)$$ and $$K_{j,i} = f(ID_j,ID_i)$$ where $$k_{i,j} \neq k_{j,i}$$."/>
                <outline text="Each shareholder must have t+r coefficients, so that the total storage requirements"/>
            </outline>
        </outline>
        <outline text="Ref: https://jwcn-eurasipjournals.springeropen.com/track/pdf/10.1186/s13638-018-1086-5.pdf">
            <outline text="(t,n)multi-secrets sharing scheme extended from Harn-Hsu's scheme">
                <outline text="Tong Zhang , Xizheng Ke and Yanxiao Liu "/>
            </outline>
        </outline>
        <outline text="Contributions / Scheme Objectives:" listStyle="arabic">
            <outline text="The polynomials received by the shareholders can be used to construct pairwise keys in order to create a secure channel."/>
            <outline text="Even if participants obtain $$k-1$$ secrets, no $$t-1$$ shareholders can get information about the final secret."/>
        </outline>
        <outline text="Share Construction">
            <outline text="Dealer selects an asymmetric bivariate polynomial $$F(x,y)$$ of degree $$t-1$$ which exists in $$\mathbb{F}_p$$:">
                <outline text="$$ F(x,y) = \\  a_{0,0} +  a_{0,1}y +  \dots +  a_{0,t-1}   y^{t-1}+ \\ a_{1,0}x + a_{1,1}xy + \dots + a_{1,t-1} xy^{t-1}+ \\ \dots + \\ a_{t-1,0}x^{t-1} + a_{t-1,1}x^{t-1}y + \dots + a_{t-1,t-1} x^{t-1}y^{t-1}$$"/>
                <outline text="The polynomial is said to be asymmetric due to the coefficients $$a_{i,j}$$ that form matrix $$A \neq A^T$$."/>
                <outline text="The shares that allow the recovery of the secrets i.e $$\{a_{0,0},a_{1,0},\dots,a_{t-1,0}\}$$ are $$s_1 = F(1,0), s_2 = F(2,0), \dots, s_t = F(t,0)$$. Where Lagrange polynomial interpolation can recover the secrets."/>
            </outline>
            <outline text="The dealer also selects a symmetric bivariate polynomial $$G(x,y)$$ of degree $$t-1$$ which exists in $$\mathbb{F}_p$$:">
                <outline text="The useful property of the symmetric biviariate polynomial where $$A = A^T$$ is that $$G(x,y) = G(y,x)$$ which allows the computation of pairwise keys between shareholders. Therefore, the keys can be used to create a secure channel with their common value."/>
                <outline text="If the dealer partially evaluates $$G(x, y)$$ by inputting $$y$$ and sending the remaining polynomial $$G(x,y) = u_y(x)$$ to a participant corresponding to the value $$y$$ (this value would be the participants ID) then some two participants $$u_i(x)$$ and $$u_j(x)$$ can input $$x$$ as the other participants ID to compute the same common value $$u_i(j) = u_j(i)$$."/>
            </outline>
            <outline text="The scheme is performed as an asynchronous secret reconstruction where the shares $$s_1, s_2, \dots, s_t$$ must be reconstructed in a preceding round of share exchanges. The shares can then be interpolated to find the original coefficients $$a$$."/>
            <outline text="For $$n$$ shareholders, a shareholder $$P_i$$ has an identity $$v_i, 1 \leq i \leq n$$ which is public to all participants."/>
            <outline text="The Dealer partially evaluates the polynomial $$F(x,y)$$ as $$F(x,v_i) = f_i(x)$$ corresponding to some $$P_i$$. That is a univariate polynomial $$f_i(x)$$ which the shareholder $$P_i$$ receives and can proceed to evaluate it by inputting $$x$$.">
                <outline text="For example $$t = 3, i = 3, v_i = 3$$:">
                    <outline text="$$A = \begin{bmatrix} 5 &amp; 4 &amp; 3 \\ 10 &amp; 8 &amp; 9 \\ 15 &amp; 12 &amp; 7 \end{bmatrix}$$"/>
                    <outline text="Dealer computes a univariate polynomial $$F(x,v_i) = F(x,3) = 44 + 115x + 114x^2$$"/>
                    <outline text="The participant can then receive these coefficients to build the function $$F(x,3) = f_3(x)$$."/>
                    <outline text="Participant $$3$$ can use this function $$f_3(x)$$ to compute a share that is finally a scalar value. "/>
                </outline>
            </outline>
            <outline text="In addition the Dealer computes $$u_i(x) = G(x,v_i), 1 \leq i \leq n$$ which is also derived from a symmetric bivariate polynomial that the participant $$P_i$$ can use to compute a common key with another participant."/>
        </outline>
        <outline text="Share Reconstruction">
            <outline text="Participants compute their common key $$K_{i,j} = G(v_i,v_j)$$ by using their received univariate polynomial $$u_i(v_j)$$ where $$u_j(v_i) = u_i(v_j) = K_{i,j} $$."/>
            <outline text="This common key can be used by participants $$P_i$$ and $$P_j$$ to create a secure channel"/>
            <outline text="To begin recovering the secret, the participants need to recover shares $$s_r \in [s_1,s_2,\dots,s_k]$$ using their function $$e_i = f_i(r)$$:">
                <outline text="$$s_r = \displaystyle \sum^{t}_{i=1} (e_i \prod^{t}_{\substack{j=1\\j \neq i}} \frac{-v_j}{v_i - v_j})$$"/>
            </outline>
            <outline text="Upon obtaining $$s_1, s_2, \dots, s_k$$, the shares may be interpolated again to recover the coefficients $$a_{0,0}, a_{1,0}, \dots, a_{t-1,0}$$."/>
        </outline>
    </outline>
    <outline text="Harn-Hsu $$\text{--}$$ Bivariate Secret Sharing [cited: 17] #h ">
        <outline text="Introduction">
            <outline text="The secret is (part of) a bivariate polynomial $$f(x, y)$$."/>
            <outline text="We have:">
                <outline text="Symmetric bivariate SS - the poly is symmetric ($$f(x,y) = f(y,x)$$)."/>
                <outline text="Asymmetric BSS otherwise."/>
            </outline>
            <outline text="The are several applications of BSS:">
                <outline text="Multi-secret sharing"/>
                <outline text="Key agreement"/>
                <outline text="Implementing advanced SS with special access structures"/>
            </outline>
        </outline>
        <outline text="Matrix Notations">
            <outline text="Principle: write $$f(x,y)$$ as a matrix $$A = ((a_{i,j}))$$ where $$f(x, y) = \sum^m_{i=0} \sum^m_{i=0} a_{ij} x^i y^j$$."/>
            <outline text="Create shares by evaluating $$f$$ at various points, e.g. $$f(x_i,y), f(x,y_i)$$ or $$f(x_i,y_i)$$. [Depending on application]"/>
            <outline text="Reconstruct $$f$$ by creating invertible Vandermonde matrix from a coalition of shares/players."/>
        </outline>
    </outline>
    <outline text="Arman &amp; Supervisor $$\text{--}$$ Novel Secret Sharing Scheme [?] #h">
        <outline text="Introduction #slide #arman"/>
        <outline text="Properties #slide #arman">
            <outline text="There are two sets of players:">
                <outline text="$$\mathcal{P} = \{P_1, ..., P_n\}$$ and $$\mathcal{Q} = \{Q_1,...,Q_n\}$$"/>
            </outline>
            <outline text="Each set has associated thresholds $$k$$ and $$l$$."/>
            <outline text="A coalition of at least $$k$$ players of $$P$$ and at least $$l$$ players of $$Q$$ can reconstruct the secret."/>
            <outline text="Any coalition with less than these players do not gain (any? all?) information about the secret."/>
        </outline>
        <outline text="Notations #slide #arman ">
            <outline text="Given a secret $$s$$, we create a bivariate polynomial $$f(x,y)$$ with $$\deg_x f = k-1$$ and $$\deg_y f = l-1$$."/>
            <outline text="We set $$f(0,0) = s$$ and $$f(i,j)$$ is random $$(i,j \neq 0)$$."/>
            <outline text="Furthermore, we form the matrix $$B := ((b_{ij}))$$ where $$1 \leq i \leq n, 1 \leq j \leq n$$, and ">
                <outline text="$$b_{ij} = \begin{bmatrix} 1 &amp; x_i &amp;  \cdots &amp; x_i^{k-1} \end{bmatrix} \cdot \begin{bmatrix} a_{0j} \\ a_{1j} \\ \vdots \\ a_{kj} \end{bmatrix} - \begin{bmatrix}a_{i0} &amp; a_{i1} &amp; \cdots &amp; a_{il} \end{bmatrix} \cdot \begin{bmatrix} 1 \\ y_j \\ \vdots \\ y^{l-1}_j \end{bmatrix}$$."/>
                <outline text="Here $$B = V_x A - A V_y$$. "/>
            </outline>
        </outline>
        <outline text="Share Creation #slide #arman">
            <outline text="Each player $$P_i$$ has public value $$x_i$$."/>
            <outline text="A public value $$y_j$$ is associated with $$Q_j$$."/>
            <outline text="The shares distributed to the players in $$\mathcal{P}$$ and  $$\mathcal{Q}$$ are as follows:">
                <outline text="$$P_i$$ receives the row vector $$\begin{bmatrix} b_{i0} &amp; b_{i1} &amp; \dots &amp; b_{in} \end{bmatrix}$$."/>
                <outline text="$$Q_j$$ receives the column vector $$\begin{bmatrix} b_{0j} \\ b_{1j} \\ \vdots \\ b_{nj} \end{bmatrix}$$."/>
            </outline>
        </outline>
        <outline text="Share Reconstruction #slide #arman ">
            <outline text="In order to reconstruct $$f$$, a coalition of $$k$$ players $$\{P_{i_1},...,P_{i_k}\}$$ and $$l$$ players $$\{Q_{j_i}, ..., Q_{j_l}\}$$ proceed as follows:">
                <outline text="The first coalition constructs the matrix $$V{(x_{i_1},...,x_{i_k})}$$."/>
                <outline text="The second coalition forms the matrix $$V^t{(y_{j_1}, ..., y_{j_l})}$$."/>
                <outline text="Together, they build the matrix $$W(k,l) = \begin{bmatrix} b_{i_1,j_1} &amp; b_{i_1,j_2} &amp; \dots &amp; b_{i,j_l} \\ b_{i_2,j_1} &amp; b_{i_2,j_2} &amp; \dots &amp;b_{i_2,j_l} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ b_{i_k,j_1} &amp; b_{i_k,j_2} &amp; \dots &amp; b_{i_k,j_l}\end{bmatrix}$$. "/>
                <outline text="They find the unique solution of the Sylvester equation $$V{(x_{i_1}, ..., x_{i_k})} F - F V^t{(y_{i_1}, ..., y_{i_l})} = W(k,l)$$."/>
            </outline>
        </outline>
        <outline text="Example #h">
            <outline text="Parameters #slide ">
                <outline text="$$k = 2$$"/>
                <outline text="$$l = 3$$"/>
                <outline text="$$A = \begin{bmatrix}15 &amp; 10 &amp; 5\\1 &amp; 2 &amp; 3 \end{bmatrix}$$"/>
                <outline text="$$V{(x_1, x_2)} = \begin{bmatrix}1 &amp; 1 \\1 &amp; 2\end{bmatrix}$$, $$V{(y_1,y_2,y_3)}^T = \begin{bmatrix}1 &amp; 1 &amp; 1\\1 &amp; 2 &amp; 3 \\1 &amp; 4 &amp; 9\end{bmatrix}$$"/>
            </outline>
            <outline text="Share Creation #slide ">
                <outline text="Calculation of $$B = V{(x_1,x_2)}  A - A  V{(y_1,y_2,y_3)} = ((b_{ij}))$$:">
                    <outline text="$$b_{1,1} = \begin{bmatrix}1 &amp; 1\end{bmatrix}  \begin{bmatrix}15 \\ 1 \end{bmatrix} - \begin{bmatrix}15 &amp; 10 &amp; 5 \end{bmatrix}  \begin{bmatrix} 1 \\ 1 \\ 1 \end{bmatrix} = -14$$ "/>
                    <outline text="$$b_{2,1} = \begin{bmatrix} 1 &amp; 2 \end{bmatrix}  \begin{bmatrix} 15 \\ 1 \end{bmatrix} - \begin{bmatrix}1 &amp; 2 &amp; 3\end{bmatrix}  \begin{bmatrix}1 \\ 1 \\ 1 \end{bmatrix} = 11$$"/>
                    <outline text="$$b_{1,2} = \begin{bmatrix}1 &amp; 1\end{bmatrix}  \begin{bmatrix} 10 \\ 2 \end{bmatrix} - \begin{bmatrix}15 &amp; 10 &amp; 5\end{bmatrix}  \begin{bmatrix} 1 \\ 2 \\ 4 \end{bmatrix} = -43$$"/>
                    <outline text="$$b_{2,2} = \begin{bmatrix}1 &amp; 2\end{bmatrix}  \begin{bmatrix} 10 \\ 2\end{bmatrix} - \begin{bmatrix}1 &amp; 2 &amp; 3\end{bmatrix}  \begin{bmatrix}1 \\ 2 \\ 4 \end{bmatrix} = -3$$"/>
                    <outline text="$$b_{1,3} = \begin{bmatrix}1 &amp; 1\end{bmatrix}  \begin{bmatrix}5 \\ 3\end{bmatrix} - \begin{bmatrix}1 &amp; 2 &amp; 3\end{bmatrix}  \begin{bmatrix}1 \\ 3 \\ 9\end{bmatrix} = -23$$"/>
                    <outline text="$$b_{2,3} = \begin{bmatrix}1 &amp; 2\end{bmatrix}  \begin{bmatrix} 5 \\ 3\end{bmatrix} - \begin{bmatrix}1 &amp; 2 &amp; 3\end{bmatrix}  \begin{bmatrix}1 \\ 3 \\ 9 \end{bmatrix} = -23$$"/>
                    <outline text="$$\therefore B = \begin{bmatrix} -14 &amp; -43 &amp; -82 \\ 11 &amp; -3 &amp; -23 \end{bmatrix} = \begin{bmatrix} b_{1,1} &amp; b_{1,2} &amp; b_{1,3} \\ b_{2,1} &amp; b_{2,2} &amp; b_{2,3} \end{bmatrix}$$"/>
                </outline>
            </outline>
            <outline text="Secret Recovery #slide  ">
                <outline text="Objective">
                    <outline text="$$vec(A) = (I_l \otimes V{(x_1, x_2)} - V{(y_1, y_2, y_3)}^T \otimes I_k)^{-1} \cdot vec(B)^T$$"/>
                    <outline text="$$vec(B) = \begin{bmatrix} b_{1,1} &amp; b_{2,1} &amp; b_{1,2} &amp; b_{2,2} &amp; b_{1,3} &amp; b_{2,3}\end{bmatrix}$$"/>
                </outline>
                <outline text="Calculation">
                    <outline text="$$vec(B) = \begin{bmatrix} -14 &amp; 11 &amp; -43 &amp; -3 &amp; -82 - 23\end{bmatrix}$$"/>
                    <outline text="$$vec(A) = \begin{bmatrix} 0 &amp; 1 &amp; -1 &amp; 0 &amp; -1 &amp; 0 \\ 1 &amp; 1 &amp; 0 &amp; -1 &amp; 0 &amp; -1 \\ -1 &amp; 0 &amp; -1 &amp; 1 &amp; -4 &amp; 0\\ 0  &amp; -1 &amp; 1 &amp; 0 &amp; 0 &amp; -4\\-1 &amp; 0 &amp; -3 &amp; 0 &amp; -8 &amp; 1 \\ 0 &amp; -1 &amp; 0 &amp; -3 &amp; 1 &amp; -7\end{bmatrix}^{-1} \cdot \begin{bmatrix} -14 \\ 11 \\ -43 \\ -3 \\ -82 \\ -23\end{bmatrix} = \begin{bmatrix} 15 \\ 1 \\ 10 \\ 2 \\ 5 \\ 3 \end{bmatrix}$$"/>
                </outline>
            </outline>
        </outline>
    </outline>
</outline>
<outline text="Notes #h">
    <outline text="Factorisation of Vandermonde Matrix (Bivariate / Multivariate Interpolation)">
        <outline text="$$S^{(3)}$$ indicates a simple matrix which is a Vandermonde matrix in the case of the third order."/>
        <outline text="$$S^{(3)} = \begin{pmatrix} 1 &amp; 1 &amp; 1 &amp; 1\\x_0 &amp; x_1 &amp; x_2 &amp; x_3 \\ x^2_0 &amp; x^2_1 &amp; x^2_2 &amp; x^2_3 \\ x^3_0 &amp; x^3_1 &amp; x^3_2 &amp; x^3_3 \end{pmatrix} = L^{(3)}U^{(3)},$$"/>
        <outline text="where"/>
        <outline text="$$L^{(3)} = \begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ x_0 &amp; 1 &amp; 0 &amp; 0 \\ x^2_0 &amp; x_0 + x_1 &amp; 1 &amp; 0 \\ x^3_0 &amp; x^2_0 + x_0 x_1 + x^2_1 &amp; x_0 + x_1 + x_2 &amp; 1\end{pmatrix}$$"/>
        <outline text="$$U^{(3)} = \begin{pmatrix} 1 &amp; 1 &amp; 1 &amp; 1 \\ 0 &amp; x_1 - x_0 &amp; x_2 - x_0 &amp; x_3 - x_0 \\ 0 &amp; 0 &amp; (x_2 - x_0)(x_2 - x_1) &amp; (x_3 - x_0)(x_3 - x_1) \\ 0 &amp; 0 &amp; 0 &amp; (x_3 - x_0)(x_3 - x_1)(x_3 - x_2)\end{pmatrix}$$"/>
        <outline text=""/>
    </outline>
</outline>
                            </outline>
                            <outline text="Applications #slide">
<outline text="Distributed Storage"/>
<outline text="Content Distribution"/>
<outline text="Layered multicast"/>
<outline text="Wireless networks"/>
<outline text="Erasure correcting code"/>
<outline text="Fault tolerance"/>
<outline text="Content distribution"/>
<outline text="P2P system"/>
<outline text="Link loss rate interference"/>
<outline text="Topology interference"/>
<outline text="Defence against eaves dropping"/>
<outline text="Secret Key Sharing"/>
<outline text="Distributed Authorities"/>
<outline text="Fair Exchange (Optimistic Fair Exchange based on publicly verifiable secret sharing schemes)"/>
<outline text="Electronic Voting"/>
<outline text="Priced Oblivious Transfer (Messages have cost and can be accessible when paid amount greater than)."/>
                            </outline>
                        </outline>
                        <outline text="COMMITMENT #h ">
                            <outline text="Introduction #h">
<outline text="Definition #slide">
    <outline text="An entity wants to reveal information in the future but keep it confidential for now. "/>
    <outline text="A commitment can represent the proof of this information whilst preserving the privacy. When it is revealed, the commitment will verify the revealed information."/>
</outline>
<outline text="Verification #slide">
    <outline text="A protocol allows the verifier to produce a challenge for the information provided by the prover. "/>
    <outline text="The challenge in conjuction with the verifier’s information can be used to produce a result."/>
    <outline text="This result determines if the prover’s information has a relationship with the verifier’s."/>
</outline>
                            </outline>
                            <outline text="Pedersen Commitment #h ">
<outline text="Description #slide">
    <outline text="Peggy makes a bet that a certain person will win a race. "/>
    <outline text="Before the race starts Peggy makes a commitment and sends it to Victor. "/>
    <outline text="After the race has finished, Peggy can reveal who she thought was going to win which allows Victor to verify the truth."/>
</outline>
<outline text="Parameters #slide">
    <outline text="$$p =$$ prime integer"/>
    <outline text="$$s =$$ secret"/>
    <outline text="$$g =$$ generator"/>
    <outline text="$$m =$$ message"/>
    <outline text="$$r =$$ random integer"/>
</outline>
<outline text="Setup #slide">
    <outline text="Peggy computes preliminary values in order to create commitments as well as have certain sets of size $$i$$ for the number of messages Peggy wishes to send:">
        <outline text="$$q = 2p + 1$$"/>
        <outline text="$$h = g^s \bmod q$$"/>
        <outline text="Set of messages $$\{m_1,...,m_i\}$$"/>
        <outline text="Set of random integers $$\{r_1,...,r_i\}$$"/>
    </outline>
</outline>
<outline text="Creating commitments #slide">
    <outline text="Peggy now creates the commitments $$c_i$$ in $$\{c_1,...,c_i\}$$ for $$i$$ messages:">
        <outline text="$$c_i = g^{m_i} \cdot h^{r_i} \pmod{q}$$"/>
    </outline>
</outline>
<outline text="Exchange #slide">
    <outline text="Peggy sends her commitments $$c_i$$ to Victor."/>
    <outline text="Later, when Peggy wants to reveal her messages she sends her messages $$m_i$$ and random values $$r_i$$. "/>
    <outline text="Victor will also need values $$g$$, $$h$$ and $$q$$."/>
    <outline text="Commitments can be added together at different points in time:">
        <outline text="For adding messages $$m_1 + m_2$$ is equivalent of $$c_1 \times c_2 \bmod q$$. "/>
    </outline>
</outline>
<outline text="Verification #slide">
    <outline text="Victor now verifies the commitments Peggy sent earlier by comparing the $$c$$ she has sent with his computation of $$c'$$:">
        <outline text="$$c' = g^m \cdot h^r \pmod{q}$$"/>
        <outline text="$$c_1 \times ... \times c_i = g^{m_1+...+m_i}\cdot h^{r_1+...+r_i} \pmod{q}$$"/>
        <outline text="$$(c' = c) \xrightarrow{} \text{Verified}$$"/>
    </outline>
</outline>
<outline text="Reference #slide">
    <outline text="Authors | Torben Prdys Pedersen"/>
    <outline text="Title   | Non-Interactive and Information-Theoretic Secure Verifiable Secret Sharing"/>
    <outline text="Year    | 1992"/>
    <outline text="DOI     | 10.1007/3-540-46766-1_9"/>
</outline>
                            </outline>
                        </outline>
                        <outline text="ZERO-KNOWLEDGE PROOF #h">
                            <outline text="Introduction #h ">
<outline text="Advantages">
    <outline text="Interactive protocol is a more convincing protocol as other party can be confident about matched value. Meanwhile hashes could be a collision."/>
    <outline text="Won't see the same hash again."/>
    <outline text="https://en.wikipedia.org/wiki/Merkle–Damgård_construction"/>
</outline>
<outline text="Description #slide">
    <outline text="Involves Peggy (prover) and Victor (verifier)"/>
    <outline text="Peggy attempts to prove she knows $$x$$ to Victor but without revealing $$x$$ at any point."/>
    <outline text="$$x$$ can represent any data especially as it can be represented through a hash."/>
</outline>
<outline text="Characteristics #slide">
    <outline text="Peggy usually computes a proof where Victor creates a challenge in order to verify it derived by their  respective secret values."/>
    <outline text="There are 3 main properties:">
        <outline text="Zero-knowledgeness - Confidentiality is kept for the information that needs to be proved."/>
        <outline text="Completeness - The verifier will have confidence that the prover knows the information that they didn't reveal."/>
        <outline text="Soundness - There cannot be an instance where false information can be verified."/>
    </outline>
    <outline text="They are secure for in terms of Discrete Logarithm Problem for classical computers. "/>
    <outline text="Potential vulnerable to Schor's Algorithm"/>
</outline>
                            </outline>
                            <outline text="Ali Baba Cave (How to Explain Zero-Knowledge Protocols to Your Children)">
<outline text="In the classic tale of Ali Baba and the Forty Thieves, the cave is used to demonstrate knowledge of some secret."/>
<outline text="The cave has two forks A and B which are at first glance a dead end. The thieves are able to evade their pursuers by using they secret pass phrase which opens a wall between the two passages A and B."/>
<outline text="One can demonstrate knowing this secret by having an observer at the fork flip a coin to decide which side the prover must appear from. "/>
<outline text="Each time this is tested, the chance of success by someone not knowing the secret is halved. "/>
<outline text="In this version of the story, there are some reporters that want to film the prover successfully knowing the secret 40 times. As 40 Thieves were involved in the original story, the test was done 40 times to prove the secret which can take some time."/>
<outline text="A jealous reporter (who does not have someone that knows the secret) can cheat by only keeping scenes of a successful test. This can make it difficult for some authority to distinguish between the a genuine test and a fabrication. "/>
<outline text="In order to reduce the time taken to prove this knowledge and film it, the filming can be done in parallel, i.e. an apartment building with one cave per floor, each having its own magic words. One extra actor is required per cave. This may not be optimal as a better solution is to have a single secret and a single scene. "/>
<outline text="For both serial and parallel tests, the verifier and prover can pretend to choose random selections but have had a prior agreement to knowing the answers in advance."/>
<outline text="It is possible to reduce the number of tests while keeping the same level of security. A cave with an increased level of security would have a greater number of passages. Although it is not physically possible to build a cave with a million million passages, it gives the verifier a million million questions to choose from for which leaves the prover such chance to be correct without knowing the answer in a single test. The size of the question is large enough that the demonstration does not show the knowledge of the secret's value."/>
<outline text="Ref: http://pages.cs.wisc.edu/~mkowalcz/628.pdf"/>
<outline text="Jean-Jacques Quisquater, Louis Guillou - How to Explain Zero-Knowledge Protocols to Your Children"/>
                            </outline>
                            <outline text="I Fiat-Shamir Heuristic #h ">
<outline text="Description #slide">
    <outline text="Peggy wants to prove to Victor that she knows a certain value __secret__ $$x$$. "/>
    <outline text="If Victor doesn't know the value then he will not be able to infer or convey what she has."/>
</outline>
<outline text="Parameters #slide">
    <outline text="$$g =$$ generator"/>
    <outline text="$$p =$$ prime"/>
    <outline text="$$v =$$ Peggy's random integer"/>
    <outline text="$$c =$$ Victor's random integer"/>
    <outline text="$$x =$$ potentially mutual secret"/>
</outline>
<outline text="Steps #slide" listStyle="arabic">
    <outline text="Peggy starts by calculating $$t = g^v \bmod p$$ given to Victor."/>
    <outline text="Meanwhile Victor does $$y = g^x \bmod p$$ but return his $$c$$ to Peggy."/>
    <outline text="Peggy calculates $$r = v-cx$$ and sends it to Victor"/>
    <outline text="Bob does the following to verify Peggy's proof given by $$t$$ and $$r$$:">
        <outline text="$$t' = (g^r \bmod p)\cdot (y^c \bmod p) \bmod p$$"/>
        <outline text="$$(t = t') \xrightarrow{} \text{Verified}$$"/>
    </outline>
</outline>
<outline text="Reference #slide">
    <outline text="Authors | Jan Stadler Camenisch and Markus"/>
    <outline text="Title   | Proof Systems for General Statements about Discrete Logarithms"/>
    <outline text="Year    | 1997"/>
    <outline text="DOI     | 10.1.1.56.1208"/>
</outline>
                            </outline>
                            <outline text="NI Fiat-Shamir Heuristic #h ">
<outline text="Description #slide">
    <outline text="Peggy wants to prove to Victor that she knows a certain value __secret__ $$x$$. "/>
    <outline text="If Victor doesn't know the value then he will not be able to infer or convey what she has."/>
</outline>
<outline text="Scheme (Modular Exponentiation) #section">
    <outline text="Parameters #slide">
        <outline text="$$g =$$ generator "/>
        <outline text="$$p =$$ prime integer"/>
        <outline text="$$v =$$ Peggy's random integer/private key"/>
        <outline text="$$x =$$ potentially mutual secret"/>
    </outline>
    <outline text="Steps Rev #slide" listStyle="arabic">
        <outline text="Both Peggy and Victor compute their own $$y = g^x \bmod{p}$$, $$y_p,y_v$$."/>
        <outline text="Peggy computes the following pair of values $$(r, c)$$ which is sent to Victor">
            <outline text="$$t = g^v \bmod{p}$$"/>
            <outline text="$$c = $$ Hash$$(g,y_p,t)$$"/>
            <outline text="$$r = v - cx \bmod{p-1}$$"/>
        </outline>
        <outline text="Victor uses $$(r, c)$$ to reconstruct some values using his own $$y$$ which then checks the correctness of $$c$$.">
            <outline text="$$\hat t = g^r \times y_v^c \pmod{p}$$"/>
            <outline text="$$\hat c = $$ Hash$$(g,y_v,\hat t)$$"/>
            <outline text="$$(\hat c = c) \xrightarrow{}$$ **Verified**"/>
            <outline text="Important Notes:">
                <outline text="If $$y_p,y_v$$ are the same (they used the same $$x$$ value) then $$c = \hat c$$."/>
                <outline text="Recall that $$g^r = g^{v - cx}$$ and that $$y^c = (g^x)^c$$."/>
                <outline text="Victor effectively computes $$g^{v - cx} \times g^{cx} = g^{v-cx+cx}$$"/>
                <outline text="Therefore $$g^{v-cx+cx} = g^v = t$$ that only Peggy knows the value of $$v$$."/>
            </outline>
        </outline>
    </outline>
</outline>
<outline text="Reference #slide">
    <outline text="Authors | Jan Stadler Camenisch and Markus"/>
    <outline text="Title   | Proof Systems for General Statements about Discrete Logarithms"/>
    <outline text="Year    | 1997"/>
    <outline text="DOI     | 10.1.1.56.1208"/>
</outline>
                            </outline>
                            <outline text="ECC NI Fiat-Shamir Heuristic #h ">
<outline text="Prover wants to prove knowledge of $$x$$ using a uniformly chosen random integer $$v$$."/>
<outline text="Steps" listStyle="arabic">
    <outline text="Prover sends values $$V, r, c$$ to Verifier:">
        <outline text="$$c = \text{Hash}(G,x,xG)$$ "/>
        <outline text="$$V = vG$$"/>
        <outline text="$$r = (v - cx)$$"/>
    </outline>
    <outline text="Verifier produces a challenge and compares the result with the received values:">
        <outline text="$$\hat V = rG + c(xG)$$"/>
        <outline text="Check $$\hat V = V$$"/>
    </outline>
</outline>
                            </outline>
                            <outline text="ZK-SNARK">
<outline text="ZCash Article">
    <outline text="https://z.cash/technology/zksnarks/"/>
    <outline text="Homomorphic Hidings">
        <outline text="__Homomorphic Hiding__ (HH) for most $$x$$, given $$E(x)$$, it is hard to find $$x$$."/>
        <outline text="Different inputs result in different outputs, $$E(x) \neq E(y)$$"/>
        <outline text="If someone knows $$E(x)$$ and $$E(y)$$, they can generate the HH of __arithmetic expressions in__ $$x$$ __and__ $$y$$.  For example, it is possible to compute $$E(x+y)$$ from $$E(x)$$ and $$E(y)$$."/>
        <outline text="Example exercise, Alice wants to prove to Bob she knows numbers $$x,y \ni x+y = 7$$."/>
        <outline text="Using __finite groups__ $$\mathbb{Z}_p^*$$ where $$p$$ is prime:">
            <outline text="Cyclic group, meaning some element $$g \in \mathbb{Z}^*_p$$ is a __generator__ such that all elements of $$\mathbb{Z}^*_p$$ can be written as $$g^a$$ for some $$a \in \{0,...,p-2\}$$ where $$g^0 = 1$$."/>
            <outline text="The __discrete logarithm problem__ is believed to be hard in $$\mathbb{Z}^*_p$$. Meaning when $$p$$ is large, an element $$h \in \mathbb{Z}^*_p$$ is difficult to find  integer $$a \in \{0,...,p-2\} \ni g^a = h \pmod{p}$$."/>
            <outline text="Exponents added up are equivalent to elements being multiplied. For $$a,b \in \{0,...,p-2\}, g^a \times g^b = g^{a+b} \pmod{p-1}$$."/>
        </outline>
        <outline text="This can be translated to $$E(x+y)$$ being derived from $$E(x) + E(y)$$. ">
            <outline text="This implies $$E(x) = g^x$$ where $$E(x+y) = g^{x+y \bmod{p-1}} = g^x \times g^y = E(x) \times E(y)$$."/>
        </outline>
    </outline>
    <outline text="Blind Evaluation of Polynomials">
        <outline text="Polynomials and linear combinations">
            <outline text="$$\mathbb{F}_p$$ denotes the field of size $$p$$ with elements $$\{0,...,p-1\}$$ where addition and multiplication are done $$\bmod{p}$$."/>
            <outline text="Polynomials $$P$$ of degree $$d$$ over $$\mathbb{F}_p$$ is expressed as:">
                <outline text="$$P(X) = a_0 + a_1 X + a_2 X^2 + ... + a_d X^d \pmod{p}$$"/>
            </outline>
            <outline text="The value of polynomial $$P$$ is a linear combination of values $$1,X,...,X^d$$ which linear combination means weighted sum as the weights are elements $$a_0,...,a_d$$."/>
            <outline text="The Homomorphic Hiding supports linear combinations in the form of $$E(ax+by) = g^{ax+by} = g^{ax} \times g^{by} = (g^x)^a \times (g^y)^b = E(x)^a \times E(y)^b$$."/>
        </outline>
        <outline text="Blind evaluation of a polynomial">
            <outline text="Alice has polynomial $$P$$ of degree $$d$$, and Bob has a point $$s \in \mathbb{F}_p$$ that was  chosen randomly. Bob wishes to learn $$E(P(s))$$, that is, the HH of the evaluation of $$P$$ at $$s$$. Two simple ways do this are:">
                <outline text="Alice sends $$P$$ to Bob, and he computes $$E(P(s))$$ by himself."/>
                <outline text="Bob sends $$s$$ to Alice, she computes $$E(P(s))$$ and sends it to Bob."/>
            </outline>
            <outline text="In the __blind evaluation problem__ it is desired for Bob to learn E(P(s)) without learning $$P$$, so blind evaluation can be done as:">
                <outline text="Bob sends Alice the hidings $$E(1),E(s),...,E(s^d)$$."/>
                <outline text="Alice computes $$E(P(s))$$ from the first step and sends $$E(P(s))$$ to Bob."/>
            </outline>
        </outline>
    </outline>
    <outline text="The Knowledge of Coefficient Test and Assumption">
        <outline text="Previous protocol is missing a way to force Alice into correctly sending $$E(P(s)$$. This can be done by doing the __Knowledge of Coefficient (KC) Test__."/>
        <outline text="Define generator $$g$$ of group $$G$$ of order $$|G| = p$$. For $$\alpha \in \mathbb{F}_p, \alpha \times g$$ denotes the result of summing $$\alpha$$ copies of $$g$$."/>
        <outline text="The KC Test">
            <outline text="For $$\alpha \in \mathbb{F}^*_p$$, a pair of elements $$(a,b) \in G$$ an $$\alpha$$-pair if $$a,b \neq 0$$ and $$b = \alpha \times a$$"/>
            <outline text="The KC Test proceeds as follows:">
                <outline text="Bob chooses a random $$\alpha \in \mathbb{F}_p^*$$ and $$a \in G$$. He computes $$b = \alpha \times a$$."/>
                <outline text="He sends to Alice the &quot;challenge&quot; pair $$(a,b)$$. "/>
                <outline text="Alice must now respond with a different pair $$(a',b')$$ that is also an $$\alpha$$-pair."/>
                <outline text="Bob accepts Alice's response only if $$(a',b')$$ is indeed an $$\alpha$$-pair. (He can check $$b' = \alpha \times a'$$)."/>
            </outline>
            <outline text="Alice does not know $$\alpha$$ so to be able to respond, Alice will choose some $$\gamma \in \mathbb{F}^*_p$$, and responds with $$(a',b') = (\gamma \times a, \gamma \times b)$$. "/>
            <outline text="So $$b' = \gamma \times b = \gamma \alpha \times a = \alpha ( \gamma \times a) = \alpha \times a'$$."/>
            <outline text="Therefore Bob can compute $$\alpha \times a' = b'$$ to verify that Alice has used the correct values."/>
        </outline>
    </outline>
    <outline text="How to make Blind Evaluation of Polynomials Verifiable">
        <outline text="When Alice has a polynomial $$P$$ of degree $$d$$ and Bob has a point $$s \in \mathbb{F}_p$$ that was chosen randomly, Bob can learn $$E(P(s))$$, i.e. the hiding of $$P$$ evaluated at $$s$$ which have the properties:">
            <outline text="Blindness - Alice will __not__ learn $$s$$ (and Bob will not learn $$P$$)"/>
            <outline text="Verifiability - Probability that Alice sends a value not of the form $$E(P(s))$$ for $$P$$ of degree $$d$$ that is know to her, but Bob still accepts it - is negligible."/>
        </outline>
        <outline text="An Extended KCA">
            <outline text="KCA previously defined: If Bob gives Alice some $$\alpha-pair (a,b = \alpha \times a)$$ "/>
            <outline text="Bob sends several $$\alpha$$ pairs $$(a_i,b_i)$$ to Alice which multiplies both elements by some $$c \in \mathbb{F}^*_p;$$ so an $$\alpha$$-pair would also be $$(c \cdot a_i, c \cdot b_i)$$. "/>
            <outline text="Alice can compute multiple pairs at once by doing $$(a',b') = (c_1 \cdot a_1 + c_2 \cdot a_2, c_1 \cdot b_1 + c_2 \cdot b_2)$$"/>
            <outline text="$$b' = c_1 \cdot b_1 + c_2 \cdot b_2 = c_1 \alpha \cdot a_1 + c_2 \alpha \cdot a_2 = \alpha ( c_1 \cdot a_1 + c_2 \alpha \cdot a_2) = \alpha \cdot a'.$$"/>
            <outline text="given $$d$$ pairs, choose any $$c_1,...,c_d \in \mathbb{F}_p$$ for which $$(a',b') = (\displaystyle \sum^d_{i=1} c_i a_i, \displaystyle \sum^d_{i=1} c_i b_i)$$"/>
            <outline text="**d-KCA**: Bob chooses random $$\alpha \in \mathbb{F}^*_p$$ and sends to Alice the $$alpha$$-pairs $$(g, \alpha \cdot g), (s \cdot g, \alpha s \cdot g),...,(s^d \cdot, \alpha s^d \cdot g)$$. Alice then outputs another $$\alpha$$-pair $$(a',b')$$ where Alice knows $$c_0,...,c_d \in \mathbb{F}_p \ni \displaystyle \sum^d_{i=0} c_i s^i \cdot g = a'$$."/>
        </outline>
    </outline>
    <outline text="The Verifiable Blind Evaluation Protocol">
        <outline text="Homomorphic Hiding mapping $$E(x) = x \cdot g$$ for a generator $$g$$ of $$G$$."/>
        <outline text="Protocol $$E$$:" listStyle="arabic">
            <outline text="Bob chooses a random $$\alpha \in \mathbb{F}^*_p$$, and sends to Alice the hidings $$g, s \cdot g,...,s^d \cdot g ($$of $$s,...,s^d)$$ and also the hidings $$\alpha \cdot g, \alpha s \cdot g, ..., \alpha s^d \cdot g($$of $$\alpha, \alpha s,..., \alpha s^d)$$."/>
            <outline text="Alice computes $$a = P(s) \cdot g$$ and $$b = \alpha P(s) \cdot g$$ using the elements sent in the first step, and sends both to Bob."/>
            <outline text="Bob checks that $$b = \alpha \cdot a$$, and accepts if and only if this equality holds."/>
        </outline>
        <outline text="Given the coefficients of $$P, P(s) \cdot g$$ is a linear combination of $$g, s,..., s^d \cdot g;$$ and $$\alpha P(s) \cdot g$$ is a linear combination of $$\alpha \cdot g, \alpha s \cdot g$$. Alice can then compute these  values from Bob's messages for a polynomial $$P$$ that she knows."/>
        <outline text="By the d-KCA if Alice sends $$a,b \ni b = \alpha \cdot a$$ then Alice must know $$c_0,...,c_d \mathbb{F}_p \ni a = \displaystyle \sum^d_{i=0} c_i s^i \cdot g$$. In that case, $$a = P(s) \cdot g$$$ for the polynomial $$P(X) = \displaystyle \sum^d_{i=0} c_i \cdot X^i$$ known to Alice. The probability that Bob accepts step 3 while at the same time Alice does not know such a $$P$$ is negligible."/>
        <outline text=""/>
    </outline>
    <outline text="From Computations to Polynomials">
        <outline text=""/>
    </outline>
</outline>
<outline text="Vitalik Posts">
    <outline text="https://medium.com/@VitalikButerin/zk-snarks-under-the-hood-b33151a013f6"/>
    <outline text="Quadratic Arithmetic Programs">
        <outline text="https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649"/>
        <outline text="Pipeline">
            <outline text="Computation"/>
            <outline text="Algebraic Circuit"/>
            <outline text="R1CS"/>
            <outline text="QAP"/>
            <outline text="Linear PCP"/>
            <outline text="Linear Interactive Proof"/>
            <outline text="zkSNARK"/>
        </outline>
        <outline text="Selecting a problem">
            <outline text="A problem must be converted into a correct form for it to be operated on. This is with a Quadratic Arithmetic Program (QAP). This transforms code of a function into a QAP. Meanwhile another process is done that creates the solution of the code, otherwise called the witness to the QAP."/>
            <outline text="Example: prove knowledge of the solution to $$x^3 + x + 5 == 35$$"/>
            <outline text="```def qeval(x):&#xA;   y = x**3&#xA;   return x + y + 5```"/>
            <outline text="This computation is bounded which requires to have no loops. Modulo and comparison operators not supported."/>
        </outline>
        <outline text="Flattening">
            <outline text="Convert original code containing arbitrarily compelx statements and expressions into a sequence of statements that are two forms $$x=y$$ ($$y$$ can be a variable or number) and $$x = y \text{ (op) } z$$ where op can be +,-,*,/ and $$y$$ and $$z$$ can be variables, numbers and sub-expressions)."/>
            <outline text="`qeval(x)` flattened:&#xA;```sym_1 = x * x&#xA;y = sym_1 * x&#xA;sym_2 = y + x&#xA;~out = sym_2 + 5```"/>
        </outline>
        <outline text="Gates to R1CS">
            <outline text="R1CS is a sequence of groups of three vectors $$(a,b,c)$$ and the solution to an R1CS vector $$s$$, where $$s$$ must satisfy the equation $$s.a \times s.b - s.c = 0$$"/>
            <outline text="A $$\begin{bmatrix} 1 \\ 3 \\ 35 \\ 9 \\ 27 \\ 30 \end{bmatrix} \begin{bmatrix} 5 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \end{bmatrix}$$ B $$\begin{bmatrix} 1 \\ 3 \\35 \\ 9 \\27 \\ 30 \end{bmatrix} \begin{bmatrix} 1 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0\end{bmatrix}$$ C $$\begin{bmatrix} 1 \\ 3 \\35 \\ 9 \\ 27 \\ 30 \end{bmatrix} \begin{bmatrix} 0 \\ 0 \\ 1 \\ 0 \\ 0 \\ 0 \end{bmatrix}$$"/>
            <outline text="      35    *       1    -     35     = 0"/>
            <outline text="Now the flattened code / gates are mapped:"/>
            <outline text="`sym_1 = x * x`">
                <outline text="$$a = \begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}$$&#xA;$$b = \begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}$$&#xA;$$c = \begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix}$$"/>
            </outline>
            <outline text="`y = sym_1 * x`">
                <outline text="$$a = \begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \end{bmatrix}$$&#xA;$$b = \begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}$$&#xA;$$c = \begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix}$$"/>
            </outline>
            <outline text="`sym_2 = y + x`">
                <outline text="$$a = \begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix}$$&#xA;$$b = \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}$$&#xA;$$c = \begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}$$"/>
            </outline>
            <outline text="`~out = sym_2 + 5`">
                <outline text="$$a = \begin{bmatrix}5 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}$$&#xA;$$b = \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}$$&#xA;$$c = \begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}$$"/>
            </outline>
            <outline text="Witness is the assignment of all the variables, input, output and internal variables:">
                <outline text="$$\begin{bmatrix} 1 &amp; 3 &amp; 35 &amp; 9 &amp; 27 &amp; 30 \end{bmatrix}$$"/>
            </outline>
            <outline text="Therefore the complete R1CS is:">
                <outline text="A&#xA;$$\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}$$&#xA;$$\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \end{bmatrix}$$&#xA;$$\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix}$$&#xA;$$\begin{bmatrix}5 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}$$"/>
                <outline text="B&#xA;$$\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}$$&#xA;$$\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}$$&#xA;$$\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}$$&#xA;$$\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}$$"/>
                <outline text="C&#xA;$$\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix}$$&#xA;$$\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix}$$&#xA;$$\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}$$&#xA;$$\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}$$"/>
            </outline>
            <outline text=""/>
        </outline>
        <outline text="R1CS to QAP">
            <outline text="Go from vectors to polynomials, transformation using Lagrange interpolation. "/>
            <outline text="Take ith element of each vector in every group and interpolate."/>
            <outline text="A&#xA;$$\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}$$&#xA;$$\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \end{bmatrix}$$&#xA;$$\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix}$$&#xA;$$\begin{bmatrix}5 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}$$"/>
            <outline text="P_1 = Points (1,0),(2,0),(3,0),(4,5) = [-5.0,9.166,-5.0, 0.833]"/>
            <outline text="P_2 = Points (1,1),(2,0),(3,1),(4,0) = [8.0, -11.333,5.0, -0.666]"/>
            <outline text="P_3 = Points (1,0),(2,0),(3,0),(4,0) = [0.0,0.0,0.0,0.0]"/>
            <outline text="etc..."/>
            <outline text="Poly expression of P_2 $$= -0.666 + 5x -11.333x^2 + 8x^3$$"/>
        </outline>
        <outline text="Checking the QAP">
            <outline text="A(x) $$\begin{bmatrix} 1 \\ 3 \\ 35 \\ 9 \\ 27 \\ 30 \end{bmatrix} \begin{bmatrix} A_1(x) \\ A_2(x)\\ A_3(x)\\ A_4(x)\\ A_5(x) \\ A_6(x) \end{bmatrix}$$ B(x) $$\begin{bmatrix} 1 \\ 3 \\35 \\ 9 \\27 \\ 30 \end{bmatrix} \begin{bmatrix} B_1(x) \\ B_2(x)\\ B_3(x) \\ B_4(x) \\ B_5(x) \\ B_6(x)\end{bmatrix}$$ C(x) $$\begin{bmatrix} 1 \\ 3 \\35 \\ 9 \\ 27 \\ 30 \end{bmatrix} \begin{bmatrix} C_1(x) \\ C_2(x) \\ C_3(x) \\ C_4(x) \\ C_5(x) \\ C_6(x) \end{bmatrix}$$"/>
            <outline text="          A(x)        *     B(x)        -        c(x)    = H * Z(x)"/>
            <outline text="Correctness is checked by dividing $$t = A.s * B.s - C.s$$ by $$Z$$. That is $$t/Z$$ should not give any remainders."/>
            <outline text="Evaluating the polynomials gives coefficients:"/>
            <outline text="$$A.s = [43.0, -73.333, 38.5,-5.166]$$"/>
            <outline text="$$B.s = [-3.0, 10.333, -5.0, 0.666]$$"/>
            <outline text="$$C.s = [-41.0, 71.666, -24.5,2.833]$$"/>
            <outline text="$$t = A.s \times B.s - C.s = [-88.0,592.66,-1063.777,805.833,-294.777,51.5,-3.444]$$"/>
            <outline text="$$Z = (x-1) (x-2) (x-3) (x-4) =[24,-50,35,-10,1]$$"/>
            <outline text="$$h = t/z = [-3.666,17.055,-3.444]$$ with no remainder."/>
            <outline text="A remainder where(x=3 is -1 instead of 0) would give a remainder of [-5.0, 8.8333, -4.5, 0.666]."/>
        </outline>
    </outline>
    <outline text="Elliptic Curve Pairings">
        <outline text="Bilinear Maps ">
            <outline text="Choose generator e.g. $$2 \mid e(3,4+5) = 2^{3 * 9}$$"/>
            <outline text="$$\therefore e(3,4) \times e(3,5) = 2^{3 \times 4} \times 2^{3 \times 5} = 2^{12} \times 2^{15} = 2^{27}$$"/>
            <outline text="$$e(P, Q+R) = e(P,Q) \times e(P,R)$$"/>
            <outline text="$$e(P+Q,R) = e(P,R) \times e(Q,R)$$"/>
        </outline>
        <outline text="Elliptic Curve Mapping">
            <outline text="$$(P_1, Q_1), (P_2, Q_2) ... (P_{10}, Q_{10})$$"/>
            <outline text="$$P_i \times k = Q_i$$"/>
            <outline text="$$R = P_1 \times i_1 + P_2 \times i_2 + ... + P_{10} \times i_{10}$$"/>
            <outline text="$$R \times k = S$$"/>
            <outline text="$$e(R,Q) = e(P,S)$$"/>
            <outline text=""/>
        </outline>
    </outline>
</outline>
                            </outline>
                            <outline text="Integer Comparison Hash Chains (?) #h ">
<outline text="Description #slide">
    <outline text="Verifies Peggy's value is above the threshold that Victor has set, without Victor know Peggy's value."/>
</outline>
<outline text="Parameters #slide">
    <outline text="seed $$=$$ random value"/>
    <outline text="$$t =$$ threshold value"/>
    <outline text="$$a =$$ Peggy's value"/>
</outline>
<outline text="Pre-broadcast #slide">
    <outline text="Peggy computes the following:">
        <outline text="$$s = \text{Hash}(\text{seed})$$"/>
        <outline text="$$x_0 = s \text{ where } x_i+1 = \text{Hash}(x_i)$$"/>
        <outline text="$$p = x_{a-t}$$"/>
        <outline text="$$v = x_{a}$$"/>
    </outline>
</outline>
<outline text="Broadcasting #slide">
    <outline text="Peggy then sends $$(p, v)$$ to Victor."/>
    <outline text="Victor attempts to verify Peggy's proof:">
        <outline text="$$c_0 = p \text{ where } c_{i+1} = \text{Hash}(c_i)$$"/>
        <outline text="$$(c_t = v) \xrightarrow{} \text{Verified}$$"/>
    </outline>
</outline>
<outline text="Reference #slide">
    <outline text="Authors | Sebastian Angel and Michael Walfish"/>
    <outline text="Title   | Verifiable auctions for online ad exchanges"/>
    <outline text="Year    | 2013"/>
    <outline text="ISBN    | 9781450320566"/>
    <outline text="DOI     | 10.1145/2486001.2486038"/>
</outline>
                            </outline>
                            <outline text="Cryptographic Pairing">
<outline text="Two cryptographic groups are used to form a third group , i.e. mapping $$e: G_1 \times G_2 \xrightarrow{} G_T$$"/>
<outline text=""/>
                            </outline>
                        </outline>
                        <outline text="KEY AGREEMENT #h">
                            <outline text="ITU-T X.1035"/>
                            <outline text="SRP-6 (RFC5054) (Secure Remote Password Protocol)">
<outline text="Links">
    <outline text="http://srp.stanford.edu | [White Paper](http://srp.stanford.edu/ndss.html)"/>
    <outline text="https://en.wikipedia.org/wiki/Secure_Remote_Password_protocol"/>
    <outline text="https://tools.ietf.org/html/rfc2945"/>
</outline>
<outline text="Info from: https://tools.ietf.org/html/rfc5054"/>
<outline text="Introduction">
    <outline text="TLS uses public key certificates for authentication."/>
    <outline text="&quot;SRP is an authentication method that allows the use of user names and passwords over unencrypted channels without revealing the password to an eavesdropper.&quot;"/>
    <outline text="&quot;SRP also upplies a shared secret at the end of the authentication sequence that can be used to generate encryption keys.&quot;"/>
</outline>
<outline text="Notation and Terminology">
    <outline text="$$N, g:$$ group parameters (prime and generator)"/>
    <outline text="$$s:$$ salt"/>
    <outline text="$$B, b:$$ server's public and private values"/>
    <outline text="$$A, a:$$ client's public and private values"/>
    <outline text="$$I:$$ user name (aka &quot;identity&quot;)"/>
    <outline text="$$P: $$ password"/>
    <outline text="$$v: $$ verifier"/>
    <outline text="$$k:$$ SRP-6 multiplier"/>
    <outline text="PAD: integer converted to byte-string then left-padded with zeroes to the length of $$N$$"/>
</outline>
<outline text="Handshake Protocol Overview">
    <outline text="$$\begin{array}{ccc} Client &amp;   ~~~~~~   &amp; Server  \\ \hline \text{Client Hello } (I) &amp; \xrightarrow{\hspace*{2cm}} &amp;  \\ &amp; &amp; \text{Server Hello} \\ &amp; &amp; \text{Certificate*} \\ &amp; &amp; \text{Server Key Exchange } (N, g, s, B) \\ &amp; \xleftarrow{\hspace*{2cm}} &amp; \text{Server Hello Done} \\  \text{Client Key Exchange } (A) &amp; \xrightarrow{\hspace*{2cm}} &amp;  \\ \text{[Change cipher spec]} &amp; &amp; \\ \text{Finished} &amp; \xrightarrow{\hspace*{2cm}} &amp; \\ &amp; &amp; \text{[Change cipher spec]} \\ &amp; \xleftarrow{\hspace*{2cm}}&amp; \text{Finished} \\ \text{Application Data} &amp; \xleftrightarrow{\hspace*{2cm}} &amp; \text{Application Data} \end{array}$$"/>
    <outline text="* Indicates an optional message that is not always sent."/>
</outline>
<outline text="Handshake Steps">
    <outline text="SRP Verifier Creation">
        <outline text="The verifier $$(v)$$ is computed based on the salt $$(s)$$, user name $$(I)$$, password $$(P)$$, and group parameters $$(N, g)$$. The computation uses SHA1 hash algorithm:">
            <outline text="$$\begin{alignedat}{2} x&amp;= \text{SHA1}(s \text{ | SHA1}(I \text{ | &quot;:&quot; | }P)) \\ v &amp;= g^x \bmod{N}\end{alignedat}$$"/>
        </outline>
    </outline>
    <outline text="Client Hello"/>
    <outline text="Server Certificate"/>
    <outline text="Server Key Exchange">
        <outline text="The server key exchange message contains the prime $$(N)$$, the generator $$(g)$$, and the salt value $$(s)$$ read from the SRP password file based on the user name $$(I)$$ received in the client hello extension (Extended from TLS Client Hello Enum)."/>
        <outline text="The server key exchange message also contains the server's public value $$(B)$$. The server calculates this value as $$B = k \times v + g^b \bmod{N}$$, where $$b$$ is a random number that SHOULD be at least 256 bits in length and $$k = \text{SHA1}(N \text{ | PAD}(g))$$."/>
        <outline text="If the server has sent a certificate message, the server key exchange message MUST be signed."/>
        <outline text="The group parameters $$(N,g)$$ sent in this message MUST have N as a safe prime (a prime of the form $$N=2q +1$$, where $$q$$ is also prime). The integers from $$1$$ to $$N-1$$ will form a group under multiplication $$\bmod{N}$$, and $$g$$ MUST be a generator of this group. In addition, the group parameters MUST NOT be specially chosen to allow efficient computation of discrete logarithms."/>
        <outline text="Client MUST abort the handshake if $$B \bmod{N} = 0$$."/>
    </outline>
    <outline text="Client Key Exchange">
        <outline text="The client key exchange message carries the client's public value $$(A)$$. The client calculates this value as $$A = g^a \bmod {N}$$, where $$a$$ is a random number that SHOULD be at least 256 bits in length."/>
        <outline text="Server MUST abort the hanshake if $$A \bmod{N} = 0$$."/>
    </outline>
    <outline text="Calculating the Premaster Secret">
        <outline text="Client calculation:">
            <outline text="$$I, P$$ = &lt;read from user&gt;"/>
            <outline text="$$N,g,s,B =$$ &lt;read from server&gt;"/>
            <outline text="$$a =$$ random()"/>
            <outline text="$$A = g^a \bmod{N}$$"/>
            <outline text="$$u = \text{SHA1}(\text{PAD}(A) \text{ | PAD}(B))$$"/>
            <outline text="$$k = \text{SHA1}(N \text{ | PAD}(g))$$ "/>
            <outline text="$$x = \text{SHA1}(s \text{ | SHA1}(I \text{ | &quot;:&quot; | }P))$$"/>
            <outline text="&lt;premaster secret&gt; $$= (B - (k \times g^x))^{(a + (u \times x))} \bmod{N}$$"/>
        </outline>
        <outline text="Server calculation:">
            <outline text="$$N, g, s, v =$$ &lt;read from password file&gt;"/>
            <outline text="$$b = random()$$"/>
            <outline text="$$k = \text{SHA1}(N \text{ | PAD}(g))$$"/>
            <outline text="$$B = k \times v + g^b \bmod{N}$$"/>
            <outline text="$$A =$$ &lt;read from client&gt;"/>
            <outline text="$$u = \text{SHA1}(\text{PAD}(A) \text{ | PAD}(B))$$"/>
            <outline text="&lt;premaster secret&gt; $$= (A \times v^u)^b \bmod{N}$$"/>
            <outline text=""/>
        </outline>
    </outline>
</outline>
<outline text="Implementation Values">
    <outline text="SRP Group Parameters">
        <outline text="1024-bit Group">
            <outline text="Prime: `EEAF0AB9 ADB38DD6 9C33F80A FA8FC5E8 60726187 75FF3C0B 9EA2314C &#xA;9C256576 D674DF74 96EA81D3 383B4813 D692C6E0 E0D5D8E2 50B98BE4&#xA;8E495C1D 6089DAD1 5DC7D7B4 6154D6B6 CE8EF4AD 69B15D49 82559B29&#xA;7BCF1885 C529F566 660E57EC 68EDBC3C 05726CC0 2FD4CBF4 976EAA9A&#xA;FD5138FE 8376435B 9FC61D2F C0EB06E3`"/>
            <outline text="Generator: $$2$$"/>
        </outline>
        <outline text="1536-bit Group">
            <outline text="Prime: `9DEF3CAF B939277A B1F12A86 17A47BBB DBA51DF4 99AC4C80 BEEEA961&#xA;4B19CC4D 5F4F5F55 6E27CBDE 51C6A94B E4607A29 1558903B A0D0F843&#xA;80B655BB 9A22E8DC DF028A7C EC67F0D0 8134B1C8 B9798914 9B609E0B&#xA;E3BAB63D 47548381 DBC5B1FC 764E3F4B 53DD9DA1 158BFD3E 2B9C8CF5&#xA;6EDF0195 39349627 DB2FD53D 24B7C486 65772E43 7D6C7F8C E442734A&#xA;F7CCB7AE 837C264A E3A9BEB8 7F8A2FE9 B8B5292E 5A021FFF 5E91479E &#xA;8CE7A28C 2442C6F3 15180F93 499A234D CF76E3FE D135F9BB`"/>
            <outline text="Generator: $$2$$"/>
        </outline>
        <outline text="2048-bit Group">
            <outline text="Prime: `AC6BDB41 324A9A9B F166DE5E 1389582F AF72B665 1987EE07 FC319294&#xA;3DB56050 A37329CB B4A099ED 8193E075 7767A13D D52312AB 4B03310D&#xA;CD7F48A9 DA04FD50 E8083969 EDB767B0 CF609517 9A163AB3 661A05FB&#xA;D5FAAAE8 2918A996 2F0B93B8 55F97993 EC975EEA A80D740A DBF4FF74&#xA;7359D041 D5C33EA7 1D281E44 6B14773B CA97B43A 23FB8016 76BD207A&#xA;436C6481 F1D2B907 8717461A 5B9D32E6 88F87748 544523B5 24B0D57D&#xA;5EA77A27 75D2ECFA 032CFBDB F52FB378 61602790 04E57AE6 AF874E73&#xA;03CE5329 9CCC041C 7BC308D8 2A5698F3 A8D0C382 71AE35F8 E9DBFBB6&#xA;94B5C803 D89F7AE4 35DE236D 525F5475 9B65E372 FCD68EF2 0FA7111F&#xA;9E4AFF73`"/>
            <outline text="Generator: $$2$$"/>
        </outline>
        <outline text="3072-bit Group">
            <outline text="Prime: `FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 29024E08&#xA;8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD EF9519B3 CD3A431B&#xA;302B0A6D F25F1437 4FE1356D 6D51C245 E485B576 625E7EC6 F44C42E9&#xA;A637ED6B 0BFF5CB6 F406B7ED EE386BFB 5A899FA5 AE9F2411 7C4B1FE6&#xA;49286651 ECE45B3D C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8&#xA;FD24CF5F 83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D&#xA;670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B E39E772C&#xA;180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9 DE2BCBF6 95581718&#xA;3995497C EA956AE5 15D22618 98FA0510 15728E5A 8AAAC42D AD33170D&#xA;04507A33 A85521AB DF1CBA64 ECFB8504 58DBEF0A 8AEA7157 5D060C7D&#xA;B3970F85 A6E1E4C7 ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226&#xA;1AD2EE6B F12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200C&#xA;BBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB31 43DB5BFC&#xA;E0FD108E 4B82D120 A93AD2CA FFFFFFFF FFFFFFFF`"/>
            <outline text="Generator: $$5$$"/>
        </outline>
        <outline text="4096-bit Group">
            <outline text="Prime: `FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 29024E08&#xA;8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD EF9519B3 CD3A431B&#xA;302B0A6D F25F1437 4FE1356D 6D51C245 E485B576 625E7EC6 F44C42E9&#xA;A637ED6B 0BFF5CB6 F406B7ED EE386BFB 5A899FA5 AE9F2411 7C4B1FE6&#xA;49286651 ECE45B3D C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8&#xA;FD24CF5F 83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D&#xA;670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B E39E772C&#xA;180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9 DE2BCBF6 95581718&#xA;3995497C EA956AE5 15D22618 98FA0510 15728E5A 8AAAC42D AD33170D&#xA;04507A33 A85521AB DF1CBA64 ECFB8504 58DBEF0A 8AEA7157 5D060C7D&#xA;B3970F85 A6E1E4C7 ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226&#xA;1AD2EE6B F12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200C&#xA;BBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB31 43DB5BFC&#xA;E0FD108E 4B82D120 A9210801 1A723C12 A787E6D7 88719A10 BDBA5B26&#xA;99C32718 6AF4E23C 1A946834 B6150BDA 2583E9CA 2AD44CE8 DBBBC2DB&#xA;04DE8EF9 2E8EFC14 1FBECAA6 287C5947 4E6BC05D 99B2964F A090C3A2&#xA;233BA186 515BE7ED 1F612970 CEE2D7AF B81BDD76 2170481C D0069127&#xA;D5B05AA9 93B4EA98 8D8FDDC1 86FFB7DC 90A6C08F 4DF435C9 34063199&#xA;FFFFFFFF FFFFFFFF`"/>
            <outline text="Generator: $$5$$"/>
        </outline>
        <outline text="6144-bit Group">
            <outline text="Prime: `FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 29024E08&#xA;8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD EF9519B3 CD3A431B&#xA;302B0A6D F25F1437 4FE1356D 6D51C245 E485B576 625E7EC6 F44C42E9&#xA;A637ED6B 0BFF5CB6 F406B7ED EE386BFB 5A899FA5 AE9F2411 7C4B1FE6&#xA;49286651 ECE45B3D C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8&#xA;FD24CF5F 83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D&#xA;670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B E39E772C&#xA;180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9 DE2BCBF6 95581718&#xA;3995497C EA956AE5 15D22618 98FA0510 15728E5A 8AAAC42D AD33170D&#xA;04507A33 A85521AB DF1CBA64 ECFB8504 58DBEF0A 8AEA7157 5D060C7D&#xA;B3970F85 A6E1E4C7 ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226&#xA;1AD2EE6B F12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200C&#xA;BBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB31 43DB5BFC&#xA;E0FD108E 4B82D120 A9210801 1A723C12 A787E6D7 88719A10 BDBA5B26&#xA;99C32718 6AF4E23C 1A946834 B6150BDA 2583E9CA 2AD44CE8 DBBBC2DB&#xA;04DE8EF9 2E8EFC14 1FBECAA6 287C5947 4E6BC05D 99B2964F A090C3A2&#xA;233BA186 515BE7ED 1F612970 CEE2D7AF B81BDD76 2170481C D0069127&#xA;D5B05AA9 93B4EA98 8D8FDDC1 86FFB7DC 90A6C08F 4DF435C9 34028492&#xA;36C3FAB4 D27C7026 C1D4DCB2 602646DE C9751E76 3DBA37BD F8FF9406&#xA;AD9E530E E5DB382F 413001AE B06A53ED 9027D831 179727B0 865A8918&#xA;DA3EDBEB CF9B14ED 44CE6CBA CED4BB1B DB7F1447 E6CC254B 33205151&#xA;2BD7AF42 6FB8F401 378CD2BF 5983CA01 C64B92EC F032EA15 D1721D03&#xA;F482D7CE 6E74FEF6 D55E702F 46980C82 B5A84031 900B1C9E 59E7C97F&#xA;BEC7E8F3 23A97A7E 36CC88BE 0F1D45B7 FF585AC5 4BD407B2 2B4154AA&#xA;CC8F6D7E BF48E1D8 14CC5ED2 0F8037E0 A79715EE F29BE328 06A1D58B&#xA;B7C5DA76 F550AA3D 8A1FBFF0 EB19CCB1 A313D55C DA56C9EC 2EF29632&#xA;387FE8D7 6E3C0468 043E8F66 3F4860EE 12BF2D5B 0B7474D6 E694F91E&#xA;6DCC4024 FFFFFFFF FFFFFFFF`"/>
            <outline text="Generator: 5"/>
        </outline>
        <outline text="8192-bit Group">
            <outline text="Prime: `FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 29024E08&#xA;8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD EF9519B3 CD3A431B&#xA;302B0A6D F25F1437 4FE1356D 6D51C245 E485B576 625E7EC6 F44C42E9&#xA;A637ED6B 0BFF5CB6 F406B7ED EE386BFB 5A899FA5 AE9F2411 7C4B1FE6&#xA;49286651 ECE45B3D C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8&#xA;FD24CF5F 83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D&#xA;670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B E39E772C&#xA;180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9 DE2BCBF6 95581718&#xA;3995497C EA956AE5 15D22618 98FA0510 15728E5A 8AAAC42D AD33170D&#xA;04507A33 A85521AB DF1CBA64 ECFB8504 58DBEF0A 8AEA7157 5D060C7D&#xA;B3970F85 A6E1E4C7 ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226&#xA;1AD2EE6B F12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200C&#xA;BBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB31 43DB5BFC&#xA;E0FD108E 4B82D120 A9210801 1A723C12 A787E6D7 88719A10 BDBA5B26&#xA;99C32718 6AF4E23C 1A946834 B6150BDA 2583E9CA 2AD44CE8 DBBBC2DB&#xA;04DE8EF9 2E8EFC14 1FBECAA6 287C5947 4E6BC05D 99B2964F A090C3A2&#xA;233BA186 515BE7ED 1F612970 CEE2D7AF B81BDD76 2170481C D0069127&#xA;D5B05AA9 93B4EA98 8D8FDDC1 86FFB7DC 90A6C08F 4DF435C9 34028492&#xA;36C3FAB4 D27C7026 C1D4DCB2 602646DE C9751E76 3DBA37BD F8FF9406&#xA;AD9E530E E5DB382F 413001AE B06A53ED 9027D831 179727B0 865A8918&#xA;DA3EDBEB CF9B14ED 44CE6CBA CED4BB1B DB7F1447 E6CC254B 33205151&#xA;2BD7AF42 6FB8F401 378CD2BF 5983CA01 C64B92EC F032EA15 D1721D03&#xA;F482D7CE 6E74FEF6 D55E702F 46980C82 B5A84031 900B1C9E 59E7C97F&#xA;BEC7E8F3 23A97A7E 36CC88BE 0F1D45B7 FF585AC5 4BD407B2 2B4154AA&#xA;CC8F6D7E BF48E1D8 14CC5ED2 0F8037E0 A79715EE F29BE328 06A1D58B&#xA;B7C5DA76 F550AA3D 8A1FBFF0 EB19CCB1 A313D55C DA56C9EC 2EF29632&#xA;387FE8D7 6E3C0468 043E8F66 3F4860EE 12BF2D5B 0B7474D6 E694F91E&#xA;6DBE1159 74A3926F 12FEE5E4 38777CB6 A932DF8C D8BEC4D0 73B931BA&#xA;3BC832B6 8D9DD300 741FA7BF 8AFC47ED 2576F693 6BA42466 3AAB639C&#xA;5AE4F568 3423B474 2BF1C978 238F16CB E39D652D E3FDB8BE FC848AD9&#xA;22222E04 A4037C07 13EB57A8 1A23F0C7 3473FC64 6CEA306B 4BCBC886&#xA;2F8385DD FA9D4B7F A2C087E8 79683303 ED5BDD3A 062B3CF5 B3A278A6&#xA;6D2A13F8 3F44F82D DF310EE0 74AB6A36 4597E899 A0255DC1 64F31CC5&#xA;0846851D F9AB4819 5DED7EA1 B1D510BD 7EE74D73 FAF36BC3 1ECFA268&#xA;359046F4 EB879F92 4009438B 481C6CD7 889A002E D5EE382B C9190DA6&#xA;FC026E47 9558E447 5677E9AA 9E3050E2 765694DF C81F56E8 80B96E71&#xA;60C980DD 98EDD3DF FFFFFFFF FFFFFFFF`"/>
            <outline text="Generator: 19 (decimal)"/>
        </outline>
    </outline>
    <outline text="SRP Test Vectors">
        <outline text="$$I =$$ &quot;alice&quot;"/>
        <outline text="$$P =$$ &quot;password123&quot;"/>
        <outline text="$$s =$$ `BEB25379 D1A8581E B5A72767 3A2441EE` "/>
        <outline text="$$N, g =$$ &lt;1024-bit Group Parameter&gt;"/>
        <outline text="$$k =$$ `7556AA04 5AEF2CDD 07ABAF0F 665C3E81 8913186F`"/>
        <outline text="$$x =$$ ` 94B7555A ABE9127C C58CCF49 93DB6CF8 4D16C124`"/>
        <outline text="$$v =$$ `7E273DE8 696FFC4F 4E337D05 B4B375BE B0DDE156 9E8FA00A 9886D812&#xA;9BADA1F1 822223CA 1A605B53 0E379BA4 729FDC59 F105B478 7E5186F5&#xA;C671085A 1447B52A 48CF1970 B4FB6F84 00BBF4CE BFBB1681 52E08AB5&#xA;EA53D15C 1AFF87B2 B9DA6E04 E058AD51 CC72BFC9 033B564E 26480D78&#xA;E955A5E2 9E7AB245 DB2BE315 E2099AFB`"/>
        <outline text="$$a =$$ `60975527 035CF2AD 1989806F 0407210B C81EDC04 E2762A56 AFD529DD&#xA;DA2D4393`"/>
        <outline text="$$b =$$ `E487CB59 D31AC550 471E81F0 0F6928E0 1DDA08E9 74A004F4 9E61F5D1&#xA;05284D20`"/>
        <outline text="$$A =$$ `61D5E490 F6F1B795 47B0704C 436F523D D0E560F0 C64115BB 72557EC4&#xA;4352E890 3211C046 92272D8B 2D1A5358 A2CF1B6E 0BFCF99F 921530EC&#xA;8E393561 79EAE45E 42BA92AE ACED8251 71E1E8B9 AF6D9C03 E1327F44&#xA;BE087EF0 6530E69F 66615261 EEF54073 CA11CF58 58F0EDFD FE15EFEA&#xA;B349EF5D 76988A36 72FAC47B 0769447B`"/>
        <outline text="$$B =$$ `BD0C6151 2C692C0C B6D041FA 01BB152D 4916A1E7 7AF46AE1 05393011&#xA;BAF38964 DC46A067 0DD125B9 5A981652 236F99D9 B681CBF8 7837EC99&#xA;6C6DA044 53728610 D0C6DDB5 8B318885 D7D82C7F 8DEB75CE 7BD4FBAA&#xA;37089E6F 9C6059F3 88838E7A 00030B33 1EB76840 910440B1 B27AAEAE&#xA;EB4012B7 D7665238 A8E3FB00 4B117B58`"/>
        <outline text="$$u =$$ `CE38B959 3487DA98 554ED47D 70A7AE5F 462EF019`"/>
        <outline text="&lt;premaster secret&gt; = `B0DC82BA BCF30674 AE450C02 87745E79 90A3381F 63B387AA F271A10D&#xA;233861E3 59B48220 F7C4693C 9AE12B0A 6F67809F 0876E2D0 13800D6C&#xA;41BB59B6 D5979B5C 00A172B4 A2A5903A 0BDCAF8A 709585EB 2AFAFA8F&#xA;3499B200 210DCC1F 10EB3394 3CD67FC8 8A2F39A4 BE5BEC4E C0A3212D &#xA;C346D7E4 74B29EDE 8A469FFE CA686E5A`"/>
        <outline text=""/>
    </outline>
</outline>
                            </outline>
                            <outline text="J-PAKE (RFC8236) (Password-Authenticated Key Exchange by Juggling)">
<outline text="Advantage over SRP: has security proofs."/>
<outline text="Key Exchange without PKI"/>
<outline text="https://tools.ietf.org/html/rfc8236 | [White Paper](https://eprint.iacr.org/2010/190.pdf)"/>
<outline text="Security Requirements">
    <outline text="Off-line dictionary attack resistance">
        <outline text="No information leakage that allows either a passive or active attacker to perform an exhaustive search of the password."/>
    </outline>
    <outline text="Forward secrecy">
        <outline text="It produces session keys that remain secure even when the password is later disclosed."/>
    </outline>
    <outline text="Known-session security">
        <outline text="Prevents a disclosed session from affecting the security of other established session keys."/>
    </outline>
    <outline text="On-line dictionary attack resistance">
        <outline text="It limits an active attacker to test only one password per protocol execution."/>
    </outline>
</outline>
<outline text="Augmented PAKE (SPAKE2)">
    <outline text="Has the same security requirements has balanced PAKE but has server compromise resistance."/>
    <outline text="The requirement that attackers should not be able to impersonate users to a server after he has stolen the password verification files. (But has not done a dictionary attack)."/>
</outline>
                            </outline>
                        </outline>
                        <outline text="OBLIVIOUS TRANSFER #h">
                            <outline text="1-out-of-2 Oblivious Transfer #h ">
<outline text="Description #slide">
    <outline text="Alice gives Bob a choice of 1-out-of-2 messages to decrypt but Alice doesn't know which one Bob has read."/>
</outline>
<outline text="Parameters #slide">
    <outline text="$$g =$$ generator"/>
    <outline text="$$p =$$ prime"/>
    <outline text="$$a =$$ Alice's random integer"/>
    <outline text="$$b =$$ Bob's random integer"/>
    <outline text="Encrypt function $$E(x)$$"/>
    <outline text="Decrypt function $$D(x)$$"/>
</outline>
<outline text="Setup #slide">
    <outline text="Alice and Bob compute an $$A$$ and $$B$$ value which they give to each other:">
        <outline text="$$A = g^a \bmod p$$"/>
        <outline text="$$B = g^b \bmod p$$"/>
    </outline>
    <outline text="Bob chooses $$c \in \{0,1\}$$ for the message to decrypt and calculates $$B$$ depending on his choice which is sent to Alice:">
        <outline text="$$(c = 0) \xrightarrow{} B = g^b \bmod p$$"/>
        <outline text="$$(c = 1) \xrightarrow{} B =Ag^b \bmod p$$"/>
    </outline>
</outline>
<outline text="Blindly Encrypting #slide">
    <outline text="From Bob's value of $$B$$ Alice creates the following keys $$K_c$$:">
        <outline text="$$K_0 = \text{Hash}(B^a \bmod p)$$"/>
        <outline text="$$K_1 = \text{Hash}((B/A)^a \bmod p)$$"/>
    </outline>
    <outline text="Alice sends the followng Encrypted message $$M_c$$:">
        <outline text="$$E_{K_0}(M_0)$$,$$E_{K_1}(M_1)$$"/>
    </outline>
</outline>
<outline text="Reading 1-out-of-2 Messages #slide">
    <outline text="Finally Bob finds his chosen message after a successful decryption of either:">
        <outline text="$$\kappa = \text{Hash}(A^b \bmod p)$$"/>
        <outline text="$$D_{\kappa}(E_{K_0}(M_0))$$"/>
        <outline text="$$D_{\kappa}(E_{K_1}(M_1))$$"/>
    </outline>
</outline>
<outline text="Reference #slide"/>
                            </outline>
                            <outline text="Elliptic Curve - Verifiable Oblivious Pseudo-Random Function">
<outline text="Notations and Definitions">
    <outline text="Description">
        <outline text="Alice can create values that are verifiable by Bob even though these values are not necessarily from Alice. Alice sends an elliptic curve point that has been multiplied by a blinding factor to Bob. Bob uses his secret on the value and sends it back. Alice now divides the blinding factor out and may use the result to prove that Bob used his secret on it."/>
    </outline>
    <outline text="Notation">
        <outline text="Blinding factor $$b$$"/>
        <outline text="Secret key $$k$$"/>
        <outline text="Parameters $$(p, a, b, G, n)$$">
            <outline text="Elliptic Curve secp256k1 - https://www.secg.org/sec2-v2.pdf"/>
            <outline text="Curve $$E:y^2 = x^3 + ax + b$$ over $$\mathbb{F}_p$$">
                <outline text="$$a = $$ **0**"/>
                <outline text="$$b =$$ **7**"/>
            </outline>
            <outline text="Finite Field $$\mathbb{F}_p$$ where">
                <outline text="$$p =$$ **FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE FFFFFC2F**"/>
                <outline text="  $$= 2^{256} - 2^{32} - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1$$"/>
            </outline>
            <outline text="Base point $$G = $$">
                <outline text="$$x= $$ **79BE667E F9DCBBAC 55A06295 CE870B07 029BFCBD 2DCE28D9 59F2815B 16F81798**"/>
                <outline text="$$y= $$ **483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8**"/>
            </outline>
            <outline text="Order $$n$$ of $$G = $$ **FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141**"/>
        </outline>
    </outline>
</outline>
<outline text="Protocol">
    <outline text="Alice generates a blinding factor $$b$$ and multiplies by point $$G$$ to produce $$bG$$."/>
    <outline text="Bob generates a secret $$k$$ and receives $$bG$$. Bob multiplies $$bG$$ with $$k$$ to get $$kbG$$."/>
    <outline text="Alice gets back $$kbG$$ and removes the blinding factor to get $$kG$$. Alice uses modular inverse $$kbG \times b^{-1} \pmod{n} = kG$$."/>
    <outline text="Alice can now prove to Bob by sending $$(\text{Message},G,\text{MAC}(kG))$$ so that Bob can use his secret $$k$$ on G to verify the MAC given."/>
</outline>
                            </outline>
                        </outline>
                        <outline text="PUBLIC KEY #h">
                            <outline text="Paillier Cryptosystem (HOMOMORPHIC) #h">
<outline text="Pascal Paillier 1999"/>
<outline text="Parameters">
    <outline text="prime $$p,q$$ where gcd$$(pq,(p-1)(q-1) ) = 1$$"/>
    <outline text="$$n = pq$$"/>
    <outline text="$$g \in \mathbb{Z}^{*}_{n^2}$$ where $$g$$ is relatively prime to $$n^2 $$ so gcd$$(g,n^2) = 1$$"/>
    <outline text="$$\lambda = $$lcm$$(p-1,q-1) = \frac{(p-1) * (q-1)}{\text{gcd}(p-1,q-1)} $$"/>
    <outline text="$$L(x) = \frac{x-1}{n}$$ which is not a modular inverse operation"/>
    <outline text="$$\mu = L(g^{\lambda} \bmod{n^2}) \times 1^{n-2} \bmod{n}$$"/>
    <outline text="Key Management">
        <outline text="Public Key $$(n, g)$$"/>
        <outline text="Private Key $$(\lambda, \mu)$$"/>
    </outline>
</outline>
<outline text="Encrypt E$$(m)$$">
    <outline text="Input ($$m$$ message) | Output ($$c$$ ciphertext)"/>
    <outline text="Find Uniformly Random $$r$$"/>
    <outline text="$$c = g^{m} \times r^{n} \pmod{n^2}$$"/>
</outline>
<outline text="Decrypt E$$(c)$$">
    <outline text="Input ($$c$$ ciphertext) | Output ($$m$$ message)"/>
    <outline text="$$m = L(c^{\lambda} \bmod{n^2}) \times \text{modInv}(\mu, n) \bmod{n}$$"/>
</outline>
<outline text="Addition">
    <outline text="$$E(m_1 + m_2) = E(m_1) \times E(m_2) \bmod{n^2}$$ "/>
</outline>
<outline text="Subtraction">
    <outline text="$$E(m_1 - m_2) = E(m_1) \times \text{modInv}(E(m_2), n^2) \bmod{n^2}$$"/>
</outline>
<outline text="Multiplication">
    <outline text="$$E(m_1 \times m_2) = E(m_1)^{m_2} \pmod{n^2}$$"/>
</outline>
<outline text="Division">
    <outline text="$$E(m_1 \div m_2) = E(m_1)^ {\text{modInv}(m_2, n^2)} \bmod{n^2} $$"/>
</outline>
                            </outline>
                            <outline text="Elliptic Curve Digital Signature #h">
<outline text="**Description**">
    <outline text="Popular alternative to RSA public key cryptography with smaller key size for equivalent security. E.g 384-bit ECC key is equivalent to 7680-bit RSA/DH key. NIST Guidelines"/>
</outline>
<outline text="**Operations**">
    <outline text="Choose Curve">
        <outline text="Curve $$E: y^2 = x^3 + ax + b$$"/>
        <outline text="Base Point $$G$$ must be on the curve."/>
        <outline text="Parameters also choose variables $$a,b$$, prime $$p$$ and $$n$$ that is the order of $$G$$."/>
    </outline>
    <outline text="Generating Keys">
        <outline text="Secret Key $$k_{priv}$$ is randomly selected."/>
        <outline text="Public Key $$k_{pub} = G \times k_{priv} = (x,y)$$."/>
    </outline>
    <outline text="Signing">
        <outline text="$$z$$ leftmost (length of $$n$$) bits of Hash$$($$__message__$$)$$."/>
        <outline text="$$r = x \bmod n$$ where $$r \neq 0$$"/>
        <outline text="$$s = k^{-1}(z+ rk_{priv}) \bmod{n}$$"/>
        <outline text="Signature pair $$(r,s)$$"/>
    </outline>
    <outline text="Verifying">
        <outline text="$$z$$ leftmost (length of $$n$$) bits of Hash$$($$__message__$$)$$."/>
        <outline text="$$u_1 = zs^-1 \bmod{n}$$"/>
        <outline text="$$u_2 = rs^-1 \bmod{n}$$"/>
        <outline text="Point $$(x,y) = u_1 \times G + u_2 \times k_{pub}$$"/>
        <outline text="Signature valid if $$r \equiv x_1 \pmod{n}$$"/>
    </outline>
</outline>
<outline text="Reference"/>
                            </outline>
                            <outline text="Elliptic Curves">
<outline text="Finding a Base Point in Finite Field">
    <outline text="Calculate $$x^3 + ax + b \pmod{p}$$ which is equal to $$y^2$$"/>
    <outline text="Find all congruences of $$y^2 \pmod{p}$$ "/>
</outline>
<outline text=""/>
                            </outline>
                            <outline text="Schnorr's Signature Scheme">
<outline text="https://link.springer.com/content/pdf/10.1007/BF00196725.pdf"/>
<outline text="https://link.springer.com/content/pdf/10.1007%2F3-540-45708-9_11.pdf"/>
<outline text="Preprocessing">
    <outline text="Prime $$p$$, Generator $$g$$, Secret $$x$$"/>
    <outline text="$$X = g^x \bmod{p}$$"/>
    <outline text="Public Key $$(p,g,X)$$"/>
    <outline text="Private Key $$(p,x)$$"/>
</outline>
<outline text="Protocol" listStyle="arabic">
    <outline text="Prover computes Y and sends to Verifier">
        <outline text="Select random value $$y$$."/>
        <outline text="Compute $$Y = g^y \bmod{p}$$"/>
    </outline>
    <outline text="Verifier selects random value $$c$$ and sends to Prover">
        <outline text="Select random value $$c$$."/>
    </outline>
    <outline text="Prover computes $$z$$ and sends to Verifier">
        <outline text="$$z = y + cx \bmod{p}$$"/>
    </outline>
    <outline text="Verifier attempts to validate Prover inputs">
        <outline text="Check that $$g^z = YX^c \pmod{p}$$"/>
    </outline>
</outline>
                            </outline>
                        </outline>
                    </outline>
                    <outline text="DISTRIBUTED LEDGERS #h">
                        <outline text="Bitcoin (2008) #h">
                            <outline text="Philosophy #slide">
<outline text="Security for the seller by producing non-reversible transactions."/>
<outline text="Security for the buyer with routine escrow systems."/>
<outline text="Proof replacing trust in the secure third party model."/>
<outline text="Peer-to-peer exchange of money like physically handing cash."/>
                            </outline>
                            <outline text="Transactions #h">
<outline text="Description #slide ">
    <outline text="Electronic coin is a chain of digital signatures."/>
    <outline text="Transferring a coin requires to digitally sign a hash of the previous transaction and the public key of the new owner. This signature is added at the end of the coin."/>
    <outline text="Signatures allow public keys belonging to the previous owners to verify the chain of ownership."/>
</outline>
<outline text="Double-Spending #slide ">
    <outline text="Double-spending is when a single coin may be used for multiple transaction."/>
    <outline text="The conventional solution is to use a central authority, i.e. the mint."/>
    <outline text="Solve the problem of the next owner being able to know that the previous owners haven't signed earlier transactions."/>
</outline>
<outline text="Public Transactions #slide ">
    <outline text="To solve double-spending the transactions have to be announced publicly, i.e. `to confirm the absence of a transaction is to be aware of all transactions'."/>
    <outline text="Participants agree on a single history of the order in which the transactions have been received."/>
    <outline text="The new owner requires proof that the majority of participants agree that each transaction at the time was the first received."/>
</outline>
                            </outline>
                            <outline text="Timestamp Server #slide ">
<outline text="Proof that transactions existed at a time is solved with a timestamp server. The server computes a hash of a block of items and publishes the hash."/>
<outline text="This server allows data to be proven to exist at a certain time with confidence."/>
<outline text="Timestamps are linked with previous timestamps in its hash therefore creating this chain reinforces the previous timestamps."/>
                            </outline>
                            <outline text="Proof-of-Work #h">
<outline text="Description #slide ">
    <outline text="In a peer-to-peer network, the timestamp server will need to generate this hash that requires to invest time computing the hash of the block. "/>
    <outline text="The way of seeing a majority consensus is represented as the longest chain because this is most amount of work done. Essentially voting with CPU power required to proceed."/>
    <outline text="A hash beginning with a number zero bits is required to be computed but with an added challenge that it needs a nonce applied. The input to produce this value is the proof-of-work. Increasing the zero bits requires exponential amount of work."/>
    <outline text="Note that the timestamp server links these hashes together."/>
</outline>
<outline text="Properties #slide ">
    <outline text="The longest chain means more participants are invested to make an effort in doing the proof-of-work."/>
    <outline text="An attacker that wants to modify a block will need to redo the work for the block and the ones afterwards, attempting to surpass with `honest' participants."/>
    <outline text="The probability of a slow attacker catching up are drastically low  and get lower as subsequent blocks are added."/>
    <outline text="The difficulty of the proof-of-work is adjusted to how many blocks are generated at a time. If blocks are generated quickly, the difficulty increases."/>
</outline>
                            </outline>
                            <outline text="Network #h">
<outline text="Protocol Summary #slide">
    <outline text="A series of steps are taken for participants to communicate:" listStyle="arabic">
        <outline text="New transactions are broadcast to all nodes."/>
        <outline text="Each node collects new transactions into a block."/>
        <outline text="Each node works on finding a difficult proof-of-work for its block."/>
        <outline text="When a node finds a proof-of-work, it broadcasts the block to all nodes."/>
        <outline text="Nodes accept the block only if all transactions in it are vaalid and not already spent."/>
        <outline text="Nodes express their acceptance of the block by working on creating the next block in the chain, using the hash of the accepted block as the previous hash."/>
    </outline>
    <outline text="Reminder that the longest chain, representing the majority vote, is always considered to be the valid one. "/>
    <outline text="Transactions don't need to reach every node but as long as a majority has these transactions a block containing them will be produced."/>
</outline>
<outline text="Inconsistent block broadcasting #slide">
    <outline text="Two nodes that broadcast different versions of the next block at the same time means some nodes receive one or the other first. "/>
    <outline text="A race begins to work on a new block based on the first one received and gain the proof-of-work."/>
    <outline text="When the first proof-of-work is found, the participants will switch to this branch."/>
    <outline text="In the case that a node doesn't get a block, it will request this additional information when it next receives a block."/>
</outline>
                            </outline>
                            <outline text="Incentive #slide ">
<outline text="The first transaction of the new block is a transaction that belongs to the creator of the new block."/>
<outline text="Therefore the creator of this new block earns a new coin which is the incentive to perform this task."/>
<outline text="This adds new coins into circulation which costs time and electricity."/>
<outline text="Honesty is rewarded by being more profitable than defrauding because honest participants will not validate the value of coins held by attackers."/>
                            </outline>
                            <outline text="Reclaiming Disk Space #slide ">
<outline text="Spent transactions can be discarded to save disk space. "/>
<outline text="Hash of Merkle is still valid after pruning some transactions."/>
                            </outline>
                            <outline text="Simplified Payment Verification #slide ">
<outline text="Verifying payments doesn't require running a `full' network node. Only block headers of the longest proof-of-work chain is needed. "/>
<outline text="A Merkle branch linking transactions can be seen that the network node has accepted it and additional blocks reinforce this."/>
<outline text="Detected invalid blocks manipulated by attackers would be alerted to other nodes which prompts them to update the full block."/>
                            </outline>
                            <outline text="Combining and Splitting Value #slide ">
<outline text="Transactions contain multiple inputs and outputs so that a single transactions doesn't correspond to a single cent."/>
<outline text="Inputs consist of a single large transactions or multiple small ones."/>
<outline text="Outputs contain at most two outputs, the payment and the change."/>
<outline text="A fan-out transaction relationship, where one transaction depends on multiple transactions and those also depend on other multiple transactions do not cause issues."/>
<outline text="It is never required to get the complete copy of a transaction history."/>
                            </outline>
                            <outline text="Privacy #slide ">
<outline text="All transactions are publicly announced but public keys associated are anonymous."/>
<outline text="Revealing the owner of the key would reveal which transactions they belonged to."/>
                            </outline>
                            <outline text="Evidence of effectiveness #slide ">
<outline text="$$p =$$ probability an honest node finds the next block."/>
<outline text="$$q =$$ probability the attacker finds the next block."/>
<outline text="$$z =$$ blocks that have been linked afterwards."/>
<outline text="Attacker's potential progress defined by Poisson distribution:">
    <outline text="$$\lambda = z \frac{q}{p}$$"/>
</outline>
<outline text="Probability the attacker could catchup"/>
                            </outline>
                            <outline text="Conclusion #slide ">
<outline text="Control of ownership with digital signatures."/>
<outline text="Double-spending solved with peer-to-peer network using proof-of-work to make it impractical for an attacker to manipulate."/>
<outline text="Network requires little maintenance as no particular routing is needed, no identification or co-ordination."/>
<outline text="Framework will continue normally despite nodes joining and leaving the network."/>
<outline text="Majority of CPU power directs the validity of transactions and value of currency."/>
                            </outline>
                        </outline>
                        <outline text="Ethereum #h">
                            <outline text="Smart Contracts"/>
                        </outline>
                    </outline>
                    <outline text="NIST STANDARD #h">
                        <outline text=""/>
                        <outline text="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf"/>
                        <outline text="Abbreviations #h">
                            <outline text="AES - Advanced Encryption Standard"/>
                            <outline text="DSA - Digital Signature Algorithm"/>
                            <outline text="ECDSA - Elliptic Curve Digital Signature Algorithm"/>
                            <outline text="len$$(n)$$ - The bit length of $$n$$."/>
                            <outline text="DRBG - Deterministic Random Bit Generator"/>
                            <outline text="CMAC - Message Authentication Code"/>
                            <outline text="HMAC - Keyed-Hash Message Authentication Code"/>
                            <outline text="CTR - Counter-mode block cipher algorithm"/>
                            <outline text="MQV - Menezes-Qu-Vanstone algorithm"/>
                            <outline text="DH - Diffie-Hellman"/>
                            <outline text="FIPS - Federal Information Processing Standard"/>
                            <outline text="KDF - Key Derivation Function"/>
                            <outline text="PRF - Pseudorandom Function"/>
                            <outline text="SHA - Secure Hash Algorithm"/>
                            <outline text="Shall - A requirement for Federal Government use. This may be coupled with not to become shall not."/>
                        </outline>
                        <outline text="Approved Algorithms #h ">
                            <outline text="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar2.pdf"/>
                            <outline text="Symmetric Algorithms for Encryption and Decryption #h">
<outline text="AES-128"/>
<outline text="AES-192"/>
<outline text="AES-256"/>
                            </outline>
                            <outline text="Digital Signature Algorithms for Generation and Verification #h">
<outline text="DSA: $$(L, N) = (2048,224),(2048,256),(3072,256)$$"/>
<outline text="ECDSA: len$$(n) \geq 224$$ "/>
<outline text="RSA: len$$(n) \geq 2048$$"/>
                            </outline>
                            <outline text="Random Bit Generation #h">
<outline text="Hash_DRBG and HMAC_DRBG"/>
<outline text="CTR_DRBG with AES-128,AES-192,AES-256"/>
                            </outline>
                            <outline text="Key Agreement using Diffie-Hellman and MQV">
<outline text="SP-800-56A Compliant DH and MQV schemes using finite fields: ">
    <outline text="$$\geq 112$$ bits of security strength using listed safe-prime groups"/>
    <outline text="or"/>
    <outline text="FIPS-186-type domain parameters (112-bit security strength only): $$(\text{len}(p),\text{len}(q)) = (2048,224),(2048,256)$$"/>
</outline>
<outline text="SP-800-56A Compliant DH and MQV schemes using elliptic curves:">
    <outline text="$$\geq 112$$ bits of security strength"/>
</outline>
                            </outline>
                            <outline text="RSA Key Agreement and Key Transport #h">
<outline text="SP-800-56B Key Agreement and Key Transport Schemes: len$$(n) \geq 2048$$"/>
                            </outline>
                            <outline text="Key Wrapping #h" _note="Encrypting a key with another key to securely store or transmit it">
<outline text="AES-128,AES-192,AES-256"/>
                            </outline>
                            <outline text="Deriving Additional Keys from Cryptographic Key" _note="KDF is an algorithm that derives one or several keys from a secret vlue.">
<outline text="Length of key-derivation **shall** be at least 112 bits."/>
<outline text="HMAC-based KDF - With approved hash functions"/>
<outline text="CMAC-based KDF - With AES"/>
                            </outline>
                            <outline text="Hash Functions">
<outline text="SHA-1 is only acceptable for Non-digital signature applications"/>
<outline text="SHA-2 family: SHA-224,SHA-256,SHA-384,SHA-512,SHA-512/224 and SHA-512/256"/>
<outline text="SHA-3 family: SHA3-224,SHA3-256,SHA3-384,SHA3-512"/>
<outline text="TupleHash and ParallelHash 128 / 256-bit acceptable for their purposes" _note="TupleHash produces a hash digest from multiple inputs, its a misuse-resistant way of combining a sequence of strings for hashing.&#xA;ParallelHash efficiently produces a hash digest of long strings with parallelism."/>
                            </outline>
                            <outline text="Message Authentication Codes">
<outline text="HMAC Generation and Verification: Key lengths $$\geq$$ 112 bits"/>
<outline text="CMAC Generation and Verification: AES"/>
<outline text="GMAC Generation and Verification: AES"/>
<outline text="KMAC Generation and Verification: Key lengths $$\geq$$ 112 bits"/>
                            </outline>
                            <outline text=""/>
                        </outline>
                    </outline>
                </outline>
                <outline text="MATHEMATICS #h " _note="#h ">
                    <outline text="Polynomial Arithmetic* Needs Revision">
                        <outline text="Python Coding">
                            <outline text="A simple structure to store the prime, exponents and coefficients of the polynomial terms can be done like so:"/>
                            <outline text="```from __future__ import annotations&#xA;from typing import Tuple&#xA;&#xA;class polynomial:&#xA;    def __init__(self, terms: dict[int,int], p: int) -&gt; None:&#xA;        self.terms = terms&#xA;        self.p = p```"/>
                        </outline>
                        <outline text="Addition">
                            <outline text="Two polynomials of the same mod are have their coefficients added as normal mod $$m$$. E.g:"/>
                            <outline text="$$(2x^4 +3x^3 +10x + 3) + (3x^5 + 14x^3 + 10x+4) \bmod{17} =$$"/>
                            <outline text="$$3x^5 + 2x^4 + 3x+ 7$$"/>
                            <outline text="```def __add__(self, other: polynomial) -&gt; polynomial:&#xA;    if other.p != self.p:&#xA;        raise Exception(&quot;Cannot add two polynomials in different fields.&quot;)&#xA;    new_terms = self.terms.copy()&#xA;    for other_exponent in other.terms:&#xA;        if other_exponent in new_terms:&#xA;            result = (new_terms[other_exponent] + other.terms[other_exponent]) % self.p&#xA;            new_terms[other_exponent] = result&#xA;            if(result == 0):&#xA;                del(new_terms[other_exponent])&#xA;        else:&#xA;            new_terms[other_exponent] = other.terms[other_exponent]&#xA;    return polynomial(dict(sorted(new_terms.items(), reverse=True)), self.p)```"/>
                        </outline>
                        <outline text="Subtraction">
                            <outline text="Two of polynomials of the same have their coefficients subtracted as normal mod $$m$$. E.g:"/>
                            <outline text="$$(10x^3 + 3x + 2) - (x^3 + 2x + 13) \bmod{17} =$$"/>
                            <outline text="$$9x^3 + x + 6$$"/>
                            <outline text="```def __sub__(self, other: polynomial) -&gt; polynomial:&#xA;    if other.p != self.p:&#xA;        raise Exception(&quot;Cannot subtract two polynomials in different fields.&quot;)&#xA;    new_terms = self.terms.copy()&#xA;    for other_exponent in other.terms:&#xA;        if other_exponent in new_terms:&#xA;            result = (new_terms[other_exponent] - other.terms[other_exponent]) % self.p&#xA;            new_terms[other_exponent] = result&#xA;            if(result == 0):&#xA;                del(new_terms[other_exponent])&#xA;        else:&#xA;            new_terms[other_exponent] = (-other.terms[other_exponent]) % self.p&#xA;    return polynomial(dict(sorted(new_terms.items(), reverse=True)), self.p)```" _note="&#x9;"/>
                        </outline>
                        <outline text="Multiplication">
                            <outline text="Brackets are multiplied out in mod $$m$$:"/>
                            <outline text="$$(10x^4 + 3x + 2) (x^3 + 2x + 13) \bmod{17}=$$"/>
                            <outline text="$$(10x^7 + 3x^5 + 11x^4) +$$"/>
                            <outline text="$$(3x^4 + 6x2 + 5x) + $$"/>
                            <outline text="$$(2x^3 + 4x + 9)$$"/>
                            <outline text="The terms are collected with the same power and the result is thus:"/>
                            <outline text="$$10x^7 + 3x^5 + 14x^4 + 2x^3 + 6x^2 + 9x + 9 \pmod{17}$$"/>
                            <outline text="```def __mul__(self, other: polynomial) -&gt; polynomial:&#xA;    if other.p != self.p:&#xA;        raise Exception(&quot;Cannot multiply two polynomials in different fields.&quot;)&#xA;    result_poly = polynomial({}, self.p)&#xA;    for s_expon in self.terms:&#xA;        new_terms = {}&#xA;        for o_expon in other.terms:&#xA;            new_terms[s_expon+o_expon] = (self.terms[s_expon] * other.terms[o_expon]) % self.p&#xA;        result_poly = result_poly + polynomial(new_terms, self.p)&#xA;    return result_poly```"/>
                        </outline>
                        <outline text="Division">
                            <outline text="Division is more complicated which can be done with long division. However, the Euclidean polynomial division algorithm can be used which goes as follows:"/>
                            <outline text="```def __truediv__(self, other: polynomial) -&gt; Tuple[polynomial, polynomial]:&#xA;    '''Euclidean Polynomial Division Algorithm'''&#xA;    if other.p != self.p:&#xA;        raise Exception(&quot;Cannot divide two polynomials in different fields.&quot;)&#xA;    q = {}&#xA;    o_exponents = list(other.terms.keys())&#xA;    r = polynomial(self.terms.copy(), self.p)&#xA;    d = o_exponents[0]&#xA;    c = other.terms[d]&#xA;    while (max(r.terms) &gt;= d):&#xA;        s_coeff = (r.terms[max(r.terms)] * pow(c, -1, self.p)) % self.p&#xA;        s_expon = max(r.terms) - d&#xA;        q[s_expon] = s_coeff&#xA;        r = r - (polynomial({s_expon: s_coeff}, self.p) * other)&#xA;        if(len(r.terms) == 0):&#xA;            break&#xA;    return (polynomial(q, self.p), r)```"/>
                        </outline>
                    </outline>
                    <outline text="Ring Theory">
                        <outline text="Definition">
                            <outline text="$$R = \{ 0, 1 \}$$"/>
                            <outline text="Axioms">
<outline text="Addition">
    <outline text="Closure">
        <outline text="$$\forall x,y \in R$$"/>
        <outline text="$$x+y \in R$$ "/>
    </outline>
    <outline text="Associativity">
        <outline text="$$(x + y) + z = x + (y + z)$$ $$\forall x,y,z \in R$$"/>
    </outline>
    <outline text="Additive Identity">
        <outline text="$$\exist$$ $$0 \in R$$"/>
        <outline text="$$\left.\begin{aligned} 0+x=x\\ x+0=x \end{aligned}\right\} \forall x \in R$$"/>
    </outline>
    <outline text="Additive Inverse">
        <outline text="$$\forall x \in R, \exist -x \in R$$"/>
        <outline text="$$\ni x + (-x) = 0$$"/>
        <outline text="$$(-x) + x = 0$$"/>
    </outline>
    <outline text="Commutativity">
        <outline text="$$\forall x,y \in R$$"/>
        <outline text="$$x+y = y+x$$"/>
    </outline>
</outline>
<outline text="Multiplication">
    <outline text="Closure">
        <outline text="$$\forall x,y \in R$$"/>
        <outline text="$$xy \in R$$"/>
    </outline>
    <outline text="Associativity">
        <outline text="$$(xy)z = x(yz)$$ $$\forall x,y,z \in R$$"/>
    </outline>
    <outline text="Multiplicative Identity">
        <outline text="$$\exist$$ $$1 \in R$$"/>
        <outline text="$$\left.\begin{aligned} 1x=x\\ x\times 1=x \end{aligned}\right\} \forall x \in R$$"/>
    </outline>
    <outline text="Distributivity">
        <outline text="$$\forall x,y,z \in R$$"/>
        <outline text="Left - $$x(y+x) = xy+xz$$"/>
        <outline text="Right - $$(y+z)x = yx + zx$$"/>
        <outline text="$$x(y+0) = xy + x0$$"/>
        <outline text="$$x(y_1 + y_2 + ... + y_n) = xy_1 + x(y_2 + ... + y_n)$$"/>
        <outline text="$$= xy_1 + xy_2 + ... + xy_n$$ "/>
        <outline text="$$(x_1 + x_2 + ... + x_m)(y_1 + y_2 + ... + y_n)$$  $$x_i,y_j \in R$$">
            <outline text="$$(x_1 + x_2 + ... + x_m)y_1$$">
                <outline text="$$+ (x_1 + x_2 + ... + x_m)y_2$$">
                    <outline text="...">
                        <outline text="$$+ (x_1 + x_2 + ... + x_m) y_n$$"/>
                    </outline>
                </outline>
            </outline>
        </outline>
    </outline>
    <outline text="Multiplicative Inverse">
        <outline text="Unit $$x \in R$$ $$x$$ is unit if $$\exist \frac{1}{x} = x^{-1} \in R$$"/>
        <outline text="$$\ni x \times \frac{1}{x} = 1$$"/>
        <outline text="$$\frac{1}{x} \times x = 1$$"/>
    </outline>
    <outline text="Commutativity">
        <outline text="$$\forall x,y \in R$$"/>
        <outline text="$$xy = yx$$"/>
    </outline>
</outline>
                            </outline>
                            <outline text="Set of integers denoted by $$\mathbb{Z} = \{0, 1, -1, 2, -2, 3, -3, ...\}$$"/>
                            <outline text="Subring $$S\subseteq R$$"/>
                        </outline>
                        <outline text="Polynomials"/>
                        <outline text="Modular Arithmetic">
                            <outline text="Properties">
<outline text="Reflexivity:  $$a \equiv a \pmod{n}$$"/>
<outline text="Symmetry:     $$a \equiv b \pmod{n}$$ if $$b \equiv a \pmod{n}$$ for all $$a$$,$$b$$ and $$n$$"/>
<outline text="Transitivity: If $$a \equiv b \pmod{n}$$ and $$b \equiv c \pmod{n}$$, then $$a \equiv c \pmod{n}$$"/>
<outline text="If $$a_1 \equiv b_1 \pmod{n}$$ and $$a_2 \equiv b_2 \pmod{n}$$, or if $$a \equiv b \pmod{n}$$, then:">
    <outline text="Translation:    $$a+k \equiv b+k \pmod{n}$$ for any integer $$k$$"/>
    <outline text="Scaling:        $$k a \equiv k b \pmod{n}$$ for any integer $$k$$"/>
    <outline text="Addition:       $$a_1 + a_2 \equiv b_1 + b_2 \pmod{n}$$ "/>
    <outline text="Subtraction:    $$a_1 - a_2 \equiv b_1 - b_2 \pmod{n}$$"/>
    <outline text="Multiplication: $$a_1 a_2 \equiv b_1 b_2 \pmod{n}$$"/>
    <outline text="Exponentiation: $$a^k \equiv b^k \pmod{n}$$"/>
    <outline text="Polyn. Eval.:   $$p(a) \equiv p(b) \pmod{n}$$ for any polynomial $$p(x)$$ with integer coefficients"/>
</outline>
<outline text="If $$a \equiv b \pmod{n}$$, then it is false, in general, that $$k^a \equiv k^b \pmod{n}$$. However:">
    <outline text="If $$c \equiv d \pmod{\phi{(n)}}$$, where $$\phi$$ is Euler's totient function, then $$a^c \equiv a^d \pmod{n}$$ provided $$a$$ is coprime with $$n$$."/>
</outline>
<outline text=""/>
                            </outline>
                            <outline text="$$\equiv$$"/>
                            <outline text="$$ \not\equiv$$"/>
                        </outline>
                    </outline>
                    <outline text="Circuit Complexity">
                        <outline text="Classes">
                            <outline text="P - TIME(poly($$n$$))"/>
                            <outline text="E - TIME($$2^{O(n)}$$)"/>
                            <outline text="EXP- TIME($$2$$poly($$n$$))"/>
                        </outline>
                        <outline text="Notation">
                            <outline text="$$O$$ - Order"/>
                            <outline text="TM - Turing Machine"/>
                            <outline text="L - Language"/>
                        </outline>
                        <outline text="Time Hierachy Theorem">
                            <outline text="More time = more power"/>
                            <outline text="TIME($$n^2$$) $$\subsetneq$$ TIME($$n^3$$) "/>
                            <outline text="$$\exists$$ L $$\in$$ TIME($$n^3$$) such that L $$\not\in$$ TIME($$n^2$$)"/>
                            <outline text="P $$\subsetneq$$ E $$\subsetneq$$ EXP"/>
                        </outline>
                    </outline>
                </outline>
                <outline text="MACHINE LEARNING #h">
                    <outline text="Core (With tensorflow)">
                        <outline text="The Perceptron: Forward Propagation">
                            <outline text="Inputs $$x_1,x_2,...,x_m$$ have corresponding weights $$w_1,w_2,...,w_m$$ that propagate information into a summation."/>
                            <outline text="A non-linear activation function $$g(z)$$ turns the sum into a probabilistic value that gives the final output $$\hat y$$."/>
                            <outline text="$$\hat y = g(\displaystyle\sum^{m}_{i=1}{x_i w_i})$$"/>
                            <outline text="$$\hat y = g(\displaystyle\sum^{m}_{i=1}{x_i w_i})$$"/>
                            <outline text="A bias term $$w_0$$ is added in order to shift the activation function to the left or right regardless of input."/>
                            <outline text="$$\hat y = g(w_0 + \displaystyle\sum^{m}_{i=1}{x_i w_i})$$"/>
                            <outline text="This can also be written alternatively where inputs and weights are vectors so that the dot product is computed:"/>
                            <outline text="$$\hat y = g(w_0 + X^T W)$$"/>
                            <outline text="$$g(z)$$ Activation Function">
<outline text="Example is Sigmoid function."/>
<outline text="$$g(z) = \sigma(z) = \frac{1}{1+e^{-z}}$$"/>
<outline text="Transforms any number into a scalar number between $$0$$ and $$1$$ as to get a probability distribution."/>
                            </outline>
                        </outline>
                        <outline text="Common Activation Functions (Non-linear)">
                            <outline text="Sigmoid Function">
<outline text="$$g(z) = \frac{1}{1+e^{-z}}$$"/>
<outline text="$$g'(z) = g(z)(1 - g(z))$$"/>
<outline text="```tf.math.sigmoid(z)```"/>
                            </outline>
                            <outline text="Hyperbolic Tangent">
<outline text="$$g(z) = \frac{e^z - e^{-z}}{e^z + e^{-z }}$$"/>
<outline text="$$g'(z) = 1 - g(z)^2$$"/>
<outline text="```tf.math.tanh(z)```"/>
                            </outline>
                            <outline text="Rectified Linear Unit (ReLU)">
<outline text="$$g(z) =$$ max$$(0,z)$$"/>
<outline text="g'(z) = $$\begin{cases}1, &amp; z &gt; 0 \\0, &amp; \text{otherwise} \end{cases}$$"/>
<outline text="```tf.nn.relu(z)```"/>
                            </outline>
                        </outline>
                        <outline text="Importance of Activation Functions">
                            <outline text="Non-linearities allow approximation of arbitrarily complex functions."/>
                            <outline text="Linear functions constrained by production linear decisions on data that is non-linear."/>
                            <outline text="Example:">
<outline text="$$w_0 = 1$$ and $$W = \begin{bmatrix} 3 \\ -2 \end{bmatrix}$$"/>
<outline text="$$\begin{alignedat}{2} \hat y &amp;= g(w_0 + X^T W) \\  &amp;= g(1 + \begin{bmatrix} x_1 \\ x_2 \end{bmatrix}^T \begin{bmatrix}3\\-2\end{bmatrix}) \\ \hat y &amp;= g(1+ 3x_1 - 2x_2) \end{alignedat}$$"/>
<outline text="The above $$1 + 3x_1 - 2x_2 = 0$$ is a 2D that can be plotted."/>
<outline text="Plotting another vector input $$X = \begin{bmatrix} -1 \\ 2 \end{bmatrix}$$ gives:"/>
<outline text="$$\begin{alignedat}{2}\hat y &amp;= g(1 + (3 \times - 1) - (2 \times 2)) \\ &amp;= g(-6) \approx 0.002 \end{alignedat}$$"/>
<outline text="Therefore on the graph, a $$z &lt; 0, y &lt; 0.5$$ would place the co-ordinates on the left hand side whilst $$z &gt; 0, y &gt; 0.5$$ would be on the right hand side of the line."/>
<outline text=""/>
                            </outline>
                        </outline>
                        <outline text="Multi Output Perceptron">
                            <outline text="Multiple outputs $$z_1,z_2,...,z_i$$ also have their own associated weights $$w_{j,i}$$. These layers are called **Dense** layers."/>
                            <outline text="$$z_i = w_{0,i} + \displaystyle\sum^{m}_{j=1}x_jw_{j,i}$$"/>
                            <outline text="```class MyDenseLayer(tf.keras.layers.Layer):&#xA;    def __init__(self,input_dim,output_dim):&#xA;        super(MyDenseLayer, self).__init__()&#xA;&#xA;        # Initialize weights and bias&#xA;        self.W = self.add_weight([input_dim, output_dim])&#xA;        self.b = self.add_weight([1, output_dim])```   "/>
                            <outline text="2 outputs in a layer where units $$= 2$$.&#xA;```import tensorflow as tf&#xA;layer = tf.keras.layers.Dense(units=2)```"/>
                            <outline text="Defining network with $$n$$ hidden layers nodes and 2 outputs. &#xA;```import tensorflow as tf&#xA;&#xA;model = tf.keras.Sequential([&#xA;   tf.keras.layers.Dense(n),&#xA;   tf.keras.layers.Dense(2)&#xA;])```"/>
                        </outline>
                        <outline text="Single Layer Neural Network">
                            <outline text="Inputs $$x_1, x_2, ..., x_m$$ with weights $$W^{(1)}$$."/>
                            <outline text="Hidden $$z_1,z_2,z_3,...,z_{d_1}$$ with weights $$W^{(2)}$$."/>
                            <outline text="Outputs $$\hat y_1$$ $$\hat y_2$$."/>
                            <outline text="Hidden layer results $$z_i = w^{(1)}_{0,i} + \displaystyle\sum^{m}_{j=1} z_j w_{j,i}^{(1)}$$"/>
                            <outline text="Final output $$\hat y_i = g(w_{0,i}^{(2)} + \displaystyle\sum^{d_1}_{j=1} z_j w_{j,i}^{(2)})$$"/>
                            <outline text="Single unit example $$z_2$$."/>
                            <outline text="$$\begin{alignedat} +z_{2} &amp;= w_{0,2}^{(1)} + \displaystyle\sum^m_{j=1} x_j w_{j,2}^{(1)} \\ &amp;= w^{(1)}_{0,2} + x_1 w_{1,2}^{(1)} + x_2 w_{2,2}^{(1)} + x_m w_{m,2}^{(1)}\end{alignedat}$$"/>
                        </outline>
                        <outline text="Deep Neural network">
                            <outline text="$$z_{k,i} = w_{0,i}^{(k)} + \displaystyle\sum^{n_{k-1}}_{j=1} g(z_{k-1,j}) w^{(k)}_{j,i}$$"/>
                            <outline text="```import tensorflow as tf&#xA;&#xA;model = tf.keras.Sequential([&#xA;   tf.keras.layers.Dense(n_1),&#xA;   tf.keras.layers.Dense(n_2),&#xA;   &#xA;   tf.keras.layers.Dense(2)&#xA;])```"/>
                        </outline>
                        <outline text="Quantifying Loss">
                            <outline text="$$\mathcal{L} (f(x^{(i)};W),y^{(1)})$$ where $$f(x^{(i)};W)$$ is the predicted result and $$y^{(i)}$$ is the actual result."/>
                            <outline text="Total loss $$J(W)$$ also called ">
<outline text="Objective function"/>
<outline text="Cost function"/>
<outline text="Empirical Risk"/>
                            </outline>
                            <outline text="$$J(W) = \frac{1}{n} \displaystyle\sum^n_{i=1} \mathcal{L}(f(x^{(i)};W),y^{(i)})$$ is the average of all individual losses."/>
                        </outline>
                        <outline text="Binary Cross Entropy Loss">
                            <outline text="Used with models that output a probability between $$0$$ and $$1$$."/>
                            <outline text="For classification problems."/>
                            <outline text="$$J(W) = \frac{1}{n}\sum^{n}_{i=1} y^{(i)}\log(f(x^{(i)};W)) + (1 - y^{(i)}) \log (1 - f(x^{(i)};W))$$"/>
                            <outline text="```loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(y,predicted))```"/>
                        </outline>
                        <outline text="Mean Squared Error Loss">
                            <outline text="Used with regression models that output continuous real numbers. For example a specific set of values to predict rather than true or false."/>
                            <outline text="$$J(W) = \frac{1}{n} \displaystyle\sum^n_{i=1} (y^{(i)} - f(x^{(i)};W))^2$$"/>
                            <outline text="```loss = tf.reduce_mean(tf.square(tf.subtract(y,predicted)))```"/>
                        </outline>
                        <outline text="Loss Optimization">
                            <outline text="Find network weights that have the lowest loss"/>
                            <outline text="$$W^* = \argmin_w \frac{1}{n} \displaystyle\sum^n_{i=1} \mathcal{L} (f(x^{(i)};W), y^{(i)})$$"/>
                            <outline text="$$W^* = \argmin_w J(W)$$ where $$W = \{W^{(0)}, W^{(1)}, ... \}$$"/>
                        </outline>
                        <outline text="Gradient Descent">
                            <outline text="Gradually path down to find minimum point of function:">
<outline text="Initialise weights randomly $$~\mathcal{N}(0,\sigma^2)$$"/>
<outline text="Loop until convergence:">
    <outline text="Compute gradient, $$\frac{\partial J(W)}{\partial W}$$"/>
    <outline text="Update weights, $$W \leftarrow W - \eta \frac{\partial J(W)}{\partial W}$$$$"/>
</outline>
<outline text="Return weights"/>
                            </outline>
                            <outline text="```import tensorflow as tf&#xA;&#xA;weights = tf.Variable([tf.random.normal()])&#xA;&#xA;while True: # loop forever&#xA;   with tf.GradientTape() as g:&#xA;      loss = compute_loss(weights)&#xA;      gradient = g.gradient(loss, weights)&#xA;&#xA;   weights = weights - lr * gradient```"/>
                        </outline>
                        <outline text="Computing Gradients: Backpropagation">
                            <outline text="$$x \rightarrow z_1 \rightarrow \hat y \rightarrow J(W)$$ where $$x$$ has weight $$w_1$$ and $$z_1$$ has weight $$w_2$$."/>
                            <outline text="Use chain rule from calculus to evaluate $$\frac{\partial J(W)}{\partial w_2} = \frac{\partial J(W)}{\partial \hat y} \times \frac{\partial \hat y}{\partial w_2}$$"/>
                            <outline text="so $$\frac{\partial J(W)}{\partial w_1} = \frac{\partial J(W)}{\partial \hat y} \times \frac{\partial \hat y}{\partial z_1} \times \frac{\partial z_1}{\partial w_1}$$"/>
                        </outline>
                        <outline text="Optimising Loss Functions">
                            <outline text="$$W \leftarrow W - \eta \frac{\partial J(W)}{\partial W}$$ where $$\eta$$ is the learning rate for how big of a step to take in the descent of the gradient."/>
                            <outline text="If $$\eta$$ is too small, the convergence is slow and could get stuck in a false local minima."/>
                            <outline text="If $$\eta$$ is too big, overshooting the minimum can happen with unstability and divergence. "/>
                        </outline>
                        <outline text="How to set learning rate $$\eta$$">
                            <outline text="Try lots of different rates and see."/>
                            <outline text="Adaptive learning rate which adapts to the landscape."/>
                            <outline text="Various Algorithms e.g.">
<outline text="SGD (Non-adaptive gradient descent)```tf.keras.optimizers.SGD```"/>
<outline text="Adam ```tf.keras.optimizers.Adam```"/>
<outline text="Adadelta ```tf.keras.optimizers.Adadelta```"/>
<outline text="Adagrad ```tf.keras.optimizers.Adagrad```"/>
<outline text="RMSProp ```tf.keras.optimizers.RMSProp```"/>
                            </outline>
                            <outline text="```import tensorflow as tf&#xA;model = tf.keras.Sequential([...])&#xA;&#xA;# pick your favourite optimiser&#xA;optimiser = tf.keras.optimizer.SGD()&#xA;&#xA;while True: # loop forever&#xA;&#xA;   # forward pass through the network&#xA;   prediction = model(x)&#xA;&#xA;   with tf.GradientTape() as tale:&#xA;      # compute the loss&#xA;      loss = compute_loss(y, prediction)&#xA;&#xA;   # update the weights using the gradient&#xA;   grads = tape.gradient(loss, model.trainable_variables)&#xA;   optimiser.apply_gradients(zip(grads, model.trainable_variables)))```"/>
                        </outline>
                        <outline text="Mini-batches">
                            <outline text="It is computationally expensive to compute gradient for all weights in $$\frac{\partial J(W)}{\partial W}$$"/>
                            <outline text="More accurate estimation of gradient, has smoother convergence and allows for larger learning rates."/>
                            <outline text="Stochastic Gradient Descent">
<outline text="Singular point">
    <outline text="Initialise weights randomly $$~\mathcal{N}(0, \sigma^2)$$"/>
    <outline text="Loop until convergence:">
        <outline text="Pick single data point $$i$$"/>
        <outline text="Compute gradient, $$\frac{\partial J_i(W)}{\partial W} $$"/>
        <outline text="Update weights, $$W \leftarrow W - \eta \frac{\partial J(W)}{\partial W}$$"/>
    </outline>
    <outline text="Return weights"/>
</outline>
<outline text="Batch points">
    <outline text="Initialise weights randomly $$~\mathcal{N}(0, \sigma^2)$$"/>
    <outline text="Loop until convergence:">
        <outline text="Pick batch of $$B$$ data points"/>
        <outline text="Compute gradient, $$\frac{\partial  J(W)}{\partial W} = \frac{1}{B} \displaystyle^{B}_{k=1} \frac{\partial J_k (W)}{\partial W}$$"/>
        <outline text="Update weights, $$W \leftarrow W - \eta \frac{\partial J(W)}{\partial {W}}$$"/>
    </outline>
    <outline text="Return weights"/>
</outline>
                            </outline>
                        </outline>
                        <outline text="The Problem of Overfitting">
                            <outline text="Underfitting $$\text{--}$$ Model does not have capacity to fully learn the data."/>
                            <outline text="Ideal fit"/>
                            <outline text="Overfitting $$\text{--}$$ Too complex, extra parameters, does not generalise well."/>
                        </outline>
                        <outline text="Regularisation">
                            <outline text="Technique that constrains our optimisation problem to discourage complex models."/>
                            <outline text="Regularisation 1: Dropout">
<outline text="During training, randomly set some activations to $$0$$ so that network isn't relying on every node to get a correct input. Allows generalisation to have multiple channels throughout the network."/>
<outline text="Typically drop 50% of activations in layer."/>
<outline text="```tf.keras.layers.Dropout(p=0.5)```"/>
                            </outline>
                            <outline text="Regularisation 2: Early Stopping">
<outline text="Stop training before we have a chance to overfit."/>
<outline text="Loss value of testing data is higher than training data throughout the iterations."/>
<outline text=""/>
                            </outline>
                        </outline>
                    </outline>
                    <outline text="Example">
                        <outline text="Simple Neural Network ">
                            <outline text="Define Sigmoid Functions">
<outline text="Non-Derivative $$f(x) = \frac{1}{1+e^{-x}}$$"/>
<outline text="Derivative $$f'(x) = x(1-x)$$"/>
                            </outline>
                            <outline text="Data">
<outline text="Input data $$X$$"/>
<outline text="Output data $$y$$"/>
                            </outline>
                            <outline text="Synapse">
<outline text="Randomly initialise weights of synapse that have a mean of $$0$$."/>
<outline text="$$syn0 = 2$$ $$\times$$ Matrix (of row size of the input and variable column size) with random decimals between $$0.0$$ &amp; $$1.0$$ then subtracted by $$1$$."/>
<outline text="Other $$synx$$ have similar property to $$syn0$$ but can just have a single column."/>
                            </outline>
                            <outline text="Training">
<outline text="Loop through iterations of the following:"/>
<outline text="Forward propagating through the layers.">
    <outline text="Layer 0, $$l0 = X$$"/>
    <outline text="Layer 1, $$l1 = f(l0 \cdot syn0)$$"/>
    <outline text="Layer 2, $$l2 = f(l1 \cdot syn1)$$"/>
</outline>
<outline text="Evaluate errors.">
    <outline text="Layer 2 error, $$\psi2 = y - l2$$"/>
    <outline text="Layer 2 delta, $$\delta2 = \psi2 \times f'(l2)$$"/>
    <outline text="Layer 1 error, $$\psi1 = \delta2 \cdot syn1^T$$"/>
    <outline text="Layer 1 delta, $$\delta1 = \psi1 \times f'(l1)$$"/>
</outline>
<outline text="Adjust synpases.">
    <outline text="$$syn1 = syn1 + (l1^T \cdot(\delta2))$$"/>
    <outline text="$$syn0 = syn0 + (l0^T \cdot(\delta1))$$"/>
</outline>
                            </outline>
                        </outline>
                    </outline>
                    <outline text="ML.NET">
                        <outline text="https://dotnet.microsoft.com/apps/machinelearning-ai/ml-dotnet"/>
                        <outline text="Steps to analyse and predict data:" listStyle="arabic">
                            <outline text="Identify data">
<outline text="**Features** are input attributes that help make predictions."/>
<outline text="**Label** are output predictions."/>
<outline text="Can load data from files or real-time sources."/>
                            </outline>
                            <outline text="Transform data">
<outline text="**Transformers** processes input by replacing missing values, converting data, `featurising' text, etc.."/>
                            </outline>
                            <outline text="Choose algorithm">
<outline text="**Trainers** are algorithms that produce model based on given scenario."/>
<outline text="Binary classification - sentiment analysis">
    <outline text="Averaged Perceptron Trainer"/>
    <outline text="Sdca Logicistic Regression Binary Trainer"/>
</outline>
<outline text="Multi-class classfication - topic categorisation">
    <outline text="Light Gbm Multiclass Trainer"/>
    <outline text="One Versus All Trainer"/>
</outline>
<outline text="Regression - price prediction">
    <outline text="Lbfgs Poisson Regression Trainer"/>
    <outline text="Fast Tree Regression Trainer"/>
</outline>
<outline text="Clustering - customer segmentation">
    <outline text="KMeansTrainer"/>
</outline>
<outline text="Anomaly Detection - shampoo sales spike detection">
    <outline text="Randomized Pca Trainer"/>
</outline>
<outline text="Recommendation - movie">
    <outline text="Matrix Factorization Trainer"/>
</outline>
<outline text="Ranking - search results">
    <outline text="Light Gbm Ranking Trainer"/>
    <outline text="Fast Tree Ranking Trainer"/>
</outline>
                            </outline>
                            <outline text="Train model">
<outline text="Training data is derived from input which produces a model. "/>
                            </outline>
                            <outline text="Evaluate model">
<outline text="Model is assessed on:">
    <outline text="Accuracy"/>
    <outline text="Area under curve (AUC)"/>
    <outline text="R-Squared"/>
    <outline text="Root Mean Squared Error (RMSE)"/>
</outline>
                            </outline>
                            <outline text="Predict">
<outline text="Model produced may now be loaded and used to predict labels based on new data."/>
                            </outline>
                        </outline>
                    </outline>
                </outline>
                <outline text="MONEY LAUNDERING #h ">
                    <outline text="Suspicious Activity Report">
                        <outline text="A document from money laundering investigators containing information about plausible money laundering activity."/>
                    </outline>
                    <outline text="Currency Transaction Report">
                        <outline text="When transactions involve over 10,000 $/£/€ currency a CTR (Currency Transaction Report) is automatically generated which leaves a more &quot;fervent&quot; paper trail."/>
                    </outline>
                    <outline text="Money Laundering Schemes">
                        <outline text="Nominee">
                            <outline text="Nominee is someone that is part of a money laundering scheme by performing a certain function or role which is to put name on any given assets on the behalf of the criminal."/>
                        </outline>
                        <outline text="Simple Business Cover">
                            <outline text="Criminal starting own larger sums of money may attempt to remove themselves from the activities of generating dirty money."/>
                            <outline text="The business front can be setup so that the criminal investing is the sole or majority stake holder."/>
                        </outline>
                        <outline text="Banking-Business">
                            <outline text="Usage banks and businesses to create a paper trail that gives the illusion of a legitimate business activity and provable."/>
                        </outline>
                        <outline text="Smurfing/Structure">
                            <outline text="Referenced from Smurfs like the cartoon/comic blue characters which in this context are resembling the numerous entities involved performing transactions below the CTR threshold."/>
                            <outline text="Splitting up large amount of money into smaller transactions that are below threshold of reporting (10,000 $/£/€)."/>
                        </outline>
                        <outline text="Dormant Accounts">
                            <outline text="Inactivity for long periods and sudden large amounts of transaction. This is usually related to terror financing."/>
                        </outline>
                    </outline>
                    <outline text="Factors that indicate money laundering (From a digital transaction perspective)">
                        <outline text="Opening an account">
                            <outline text="Little to no economic activity."/>
                            <outline text="Account opened for local company but makes transactions in foreign currency not related to commercial activity."/>
                            <outline text="Transferring assets of a company to another over time i.e. payable-through account."/>
                            <outline text="Account is dormant and suddenly becomes active for a large number of credit/debit operations done in a short time."/>
                            <outline text="Opening large number of accounts in the name of different companies that don't seem to have any economic substance. These accounts will then exponentially grow in short period in number and volume of operations."/>
                        </outline>
                        <outline text="Manual Exchange Transactions">
                            <outline text="Splitting transactions into amounts that are below the identification threshold of 10,000 $/£/€."/>
                            <outline text="Repeatedly performing exchange transactions on the margins of the bank account."/>
                        </outline>
                        <outline text="International Transfers">
                            <outline text="Substantial transfers of funds to bank accounts on which there are no transactions of any other kind that is imediately followed by cash withdrawals."/>
                            <outline text="Explosive growth of income in short time."/>
                        </outline>
                    </outline>
                    <outline text="Current Anti-Money Laundering Operations">
                        <outline text="Investigators">
                            <outline text="Investigators analyse paper trails, client information to find abnormalities. "/>
                            <outline text="Another type of investigator now uses social networks to find incriminating evidence."/>
                        </outline>
                        <outline text="Machine Learning">
                            <outline text="Trained machine learning algorithm that can analyse large amounts of data compared to other methods however is less effective for more elaborate money laundering schemes."/>
                        </outline>
                        <outline text="Forensic Analysis">
                            <outline text="Using Forensic Tool-kits on databases to manually find money laundering signatures."/>
                        </outline>
                    </outline>
                    <outline text="EU AML">
                        <outline text="Systems interconecting national decentralised databases">
                            <outline text="European Criminal Records Information System (ECRIS)"/>
                            <outline text="European c and driving license information system (EUCARIS)"/>
                            <outline text="EU-wide interconnection of insolvency registers (IRI)"/>
                            <outline text="Business Registers Interonnection System (BRIS)"/>
                            <outline text="Land Registers Interconnection (LRI)"/>
                            <outline text="European Business Ownership and Control Structures (EBOCS)"/>
                            <outline text="e-Justice Communication via Online Data Exchange (e-CODEX)"/>
                        </outline>
                        <outline text="Central Routing component">
                            <outline text="All countries communicate directly to each other - peer-to-peer exchanges between connected points of member states."/>
                            <outline text="Web service that can run user queries from national databases."/>
                        </outline>
                        <outline text="Data Exchange Protocol">
                            <outline text="CEF eDelivery solution - derivation of TLS "/>
                        </outline>
                    </outline>
                    <outline text="UK Crypto AML">
                        <outline text="https://www.loc.gov/law/help/cryptocurrency/cryptocurrency-world-survey.pdf"/>
                        <outline text="No regulation"/>
                        <outline text="Bank of England has determined cryptocurrency market is not big enough to pose a &quot;material risk to monetery or financial stability in the UK&quot; - Robleh Ali et Al, The Economic of Digital Currencies, Bank of England https://www.bankofengland.co.uk/-/media/boe/files/digital-currencies/the-economics-of-digital-currencies.pdf?la=en&amp;hash=BE28BE59F18E79CCE705643CF14F36DF8897E56D"/>
                    </outline>
                    <outline text="Sources">
                        <outline text="John Madinger - Money Laundering: A Guide for Criminal Investigators (Third Edition)"/>
                        <outline text="Belgian Financial Intelligence Processing Unit - Money Laundering Indicators"/>
                        <outline text="Andrea Calladon, Elisa Remondi - Using social network analysis to prevent money laundering"/>
                        <outline text="Tamer Helmy, Mohamed Zaki, Tarek Salah, Khaled Badran - Design of a monitor for detecting money laundering and terror financing"/>
                        <outline text="Denys Flores, Olga angelopoulou, Richard Self - Combining Digital Forensic Practices and Databses Analysis as an Anti-Money Laundering Strategy for Financial Institutions"/>
                    </outline>
                </outline>
                <outline text="Cyber Threat Intelligence #h ">
                    <outline text="Threats"/>
                    <outline text="Tools">
                        <outline text="Open Source Intelligence Tools:">
                            <outline text="Maltego, Shodan, SpiderFoot"/>
                            <outline text="@misc{GitHubsm94:online,"/>
                            <outline text="author = {},"/>
                            <outline text="title = {GitHub - smicallef/spiderfoot: SpiderFoot automates OSINT for threat intelligence and mapping your attack surface.},"/>
                            <outline text="howpublished = {\url{https://github.com/smicallef/spiderfoot}},"/>
                            <outline text="month = {},"/>
                            <outline text="year = {},"/>
                            <outline text="note = {(Accessed on 22/11/2023)}"/>
                            <outline text="}"/>
                        </outline>
                        <outline text="Threat Intelligence Platforms:">
                            <outline text="MISP, ThreatConnect[]"/>
                        </outline>
                        <outline text="Threat Feed Aggregators:">
                            <outline text="OTX, TIE, Intel471, DarkOwl"/>
                        </outline>
                        <outline text="Security Information and Event Management">
                            <outline text="Splunk, SolarWinds SEM, IBM QRadar"/>
                            <outline text="@misc{IBMSecur26:online,"/>
                            <outline text="author = {},"/>
                            <outline text="title = {IBM Security QRadar SIEM},"/>
                            <outline text="howpublished = {\url{https://www.ibm.com/products/qradar-siem}},"/>
                            <outline text="month = {},"/>
                            <outline text="year = {},"/>
                            <outline text="note = {(Accessed on 27/11/2023)}"/>
                            <outline text="}"/>
                        </outline>
                        <outline text="Intrusion Detection System">
                            <outline text="Snort, Bro, Suricata, PaloAlto"/>
                        </outline>
                    </outline>
                    <outline text="Tools OLD">
                        <outline text="Frameworks">
                            <outline text="CIF, IDS"/>
                        </outline>
                        <outline text="IDS">
                            <outline text="Snort, Bro, Suricata, PaloAlto"/>
                        </outline>
                        <outline text="Platforms">
                            <outline text="OTX, TIE, MISP"/>
                        </outline>
                        <outline text="Technologies">
                            <outline text=""/>
                        </outline>
                    </outline>
                    <outline text="Compliance and Regulatory Limitations">
                        <outline text="There are several aspects which adds further hurdles to sharing intelligence. There is a hierarchy of limitations beginning from laws then regulations, standards, policies and procedures, and business rules."/>
                        <outline text="**Laws**">
                            <outline text="Nations will each have their own laws regarding national security, privacy and intellectual property. Thus, an organisation that operates in multiple countries may face different constraints in each of them. These constraints will be dictated by laws that govern data protection and information sharing over borders. An example of this is the Data Protection Act 2018 [] which is the UK's implementation of GDPR. There is also the Official Secrets Act 1989 [] which makes it an offence for public sector members to disclose information without lawful authority. Laws go on to shape who keeps the information, what kind of information, and how it is shared. As laws may differ, so too can the gravity of consequences. An organisation that has been breached may have the following legal consequences:">
<outline text="Prosecution">
    <outline text="Organisations and accountable individuals can face legal action and lawsuits. The impact of security breaches may be devastating enough that clients are severely affected by stolen funds or private information which warrant legal prosecution.  "/>
</outline>
<outline text="Corporate Liability">
    <outline text="Depending on the severity of the infringement an organisation can be charged with significant financial penalties and indemnification. GDPR enforces penalties [] such as a legal reprimand, a temporary or permanent ban on processing and fines up to €20 million or 4% of the business's total annual worldwide turnover.">
        <outline text="@misc{gdpr_penalties,"/>
        <outline text="author = {},"/>
        <outline text="title = {What if my company/organisation fails to comply with the data protection rules?},"/>
        <outline text="howpublished = {\url{https://commission.europa.eu/law/law-topic/data-protection/reform/rules-business-and-organisations/enforcement-and-sanctions/sanctions/what-if-my-companyorganisation-fails-comply-data-protection-rules_en}},"/>
        <outline text="month = {},"/>
        <outline text="year = {},"/>
        <outline text="note = {(Accessed on 13/11/2023)}"/>
        <outline text="}"/>
    </outline>
    <outline text="Investigation into a cyber security breach may find that there has been a breach in legal obligations, contracts or professional rules and standards. This may be due to unsatisfactory security practices or measures taken from industry standards.">
        <outline text="@misc{Conseque18:online,"/>
        <outline text="author = {},"/>
        <outline text="title = {Consequences of a cybersecurity breach | Law Society of Scotland},"/>
        <outline text="howpublished = {\url{https://www.lawscot.org.uk/members/business-support/technology/cybersecurity-guide/consequences-of-a-breach/}},"/>
        <outline text="month = {},"/>
        <outline text="year = {},"/>
        <outline text="note = {(Accessed on 13/11/2023)}"/>
        <outline text="}"/>
    </outline>
    <outline text="@misc{official_secrets_act_1989,"/>
    <outline text="author = {},"/>
    <outline text="title = {Official Secrets Act 1989},"/>
    <outline text="howpublished = {\url{https://www.legislation.gov.uk/ukpga/1989/6/contents}},"/>
    <outline text="month = {},"/>
    <outline text="year = {},"/>
    <outline text="note = {(Accessed on 14/11/2023)}"/>
    <outline text="}"/>
</outline>
                            </outline>
                        </outline>
                        <outline text="**Regulations**">
                            <outline text="For each department in a government, such as Business, Education, Transport, etc, there are a number of regulatory bodies in each of them to ensure that practices are compliant. These can vary in size and scope however, the EU's GDPR [] is a major enforcer, for instance in April 2023, the European Data Protection Board (EDPB) has given its biggest fine of €1.2 billion to Meta Platforms Ireland Limited[]. Other significant multinational companies have been fined such as Amazon [], Google [] and TikTok []. There are also government backed schemes which are not regulators themselves but are a source of official guidance and certifications. For instance the National Cyber Security Centre (NCSC) hosts the Cyber Essentials scheme [].">
<outline text="@misc{meta_april2023_fine,"/>
<outline text="author = {},"/>
<outline text="title = {1.2 billion euro fine for Facebook as a result of EDPB binding decision | European Data Protection Board},"/>
<outline text="howpublished = {\url{https://edpb.europa.eu/news/news/2023/12-billion-euro-fine-facebook-result-edpb-binding-decision_en}},"/>
<outline text="month = {},"/>
<outline text="year = {},"/>
<outline text="note = {(Accessed on 14/11/2023)}"/>
<outline text="}"/>
<outline text="@misc{google_january2019_fine,"/>
<outline text="author = {},"/>
<outline text="title = {The CNIL’s restricted committee imposes a financial penalty of 50 Million euros against GOOGLE LLC | European Data Protection Board},"/>
<outline text="howpublished = {\url{https://edpb.europa.eu/news/national-news/2019/cnils-restricted-committee-imposes-financial-penalty-50-million-euros_en#:~:text=On%2021%20January%202019%2C%20the,consent%20regarding%20the%20ads%20personalization.}},"/>
<outline text="month = {},"/>
<outline text="year = {},"/>
<outline text="note = {(Accessed on 14/11/2023)}"/>
<outline text="}"/>
<outline text="@misc{tiktok_august2023_fine,"/>
<outline text="author = {},"/>
<outline text="title = {Following EDPB Decision, TikTok ordered to eliminate unfair design practices concerning children | European Data Protection Board},"/>
<outline text="howpublished = {\url{https://edpb.europa.eu/news/news/2023/following-edpb-decision-tiktok-ordered-eliminate-unfair-design-practices-concerning_en}},"/>
<outline text="month = {},"/>
<outline text="year = {},"/>
<outline text="note = {(Accessed on 14/11/2023)}"/>
<outline text="}"/>
                            </outline>
                        </outline>
                        <outline text="**Standards**">
                            <outline text="Whilst businesses must respect and comply with law and regulations, businesses should also adopt certain standards recognised by their industries. A company certified for a certain standard indicates to stakeholders that a trustworthy level of approach is taken for managing information security. For instance, following the ISO/IEC 27000 [] is a globally recognised standard and demonstrates implementation of the best practices in information security.  The consequences can have lasting damage on market reputation which erodes trust with clients and partners. The implications for not complying with international standards also affect share prices of a company as investors and stakeholders will punish information security negligence."/>
                        </outline>
                        <outline text="**Policies and Procedures**">
                            <outline text="The incorporation of standards, regulations and laws regarding information security in an organisation begins to manifest through the policies and procedures. Policies outline goals, rules and guidelines from top-down management and governance. Procedures are step-by-step instructions for employees to carry out which comply with policies. Management will have the specific goals and expectations to ensure compliance and correct behaviour in critical areas.  Employees in day-to-day tasks have guidance and awareness to take actions that mitigate risk. Having a robust and well documented set policies and procedures allows an organisation to determine accountability, aid for training and transparency for auditing. With the increase in volume and complexity of device connections, there is a digital transformation in cybersecurity technologies and tactics. As explored in this chapter, cyber threat intelligence sharing itself is part of a new tactic to cope with new generations of threats, this is aided further with other technologies such as machine learning and network defence platforms. An investigation on employee compliance of cybersecurity policies [] shows that the impact of employees aware of the policies are able to cope with cybersecurity issues and thus is critical in reducing risk. "/>
                            <outline text="@article{impact_of_cybersecurity_policy_awareness,"/>
                            <outline text="title = {Investigating the impact of cybersecurity policy awareness on employees’ cybersecurity behavior},"/>
                            <outline text="journal = {International Journal of Information Management},"/>
                            <outline text="volume = {45},"/>
                            <outline text="pages = {13-24},"/>
                            <outline text="year = {2019},"/>
                            <outline text="issn = {0268-4012},"/>
                            <outline text="doi = {https://doi.org/10.1016/j.ijinfomgt.2018.10.017},"/>
                            <outline text="url = {https://www.sciencedirect.com/science/article/pii/S0268401218302093},"/>
                            <outline text="author = {Ling Li and Wu He and Li Xu and Ivan Ash and Mohd Anwar and Xiaohong Yuan},"/>
                            <outline text="keywords = {Information security, Peer behavior, Cues to action, Protection motivation theory, Cybersecurity policy compliance}"/>
                            <outline text="}"/>
                        </outline>
                        <outline text="**Business Rules**">
                            <outline text="Another element of guidance which takes into account laws, regulations and standards are business rules. These are expressed with conditional statements, for instance with IF THEN ELSE, that is, &quot;If a customer has created an account then, they may place an order&quot;. These rules serve to outline limitations of the business and constraints from laws and regulations. These can be planned with information security in mind regarding both employees and customers. A well documented and accessible set of business rules also benefits designing of processes which is informed by information security standards. Depending on jurisdictions business rules may need to be reviewed or updated regularly to ensure changes in governance are consistent."/>
                        </outline>
                    </outline>
                </outline>
            </outline>
            <outline text="Novelty">
                <outline text="Shah x Herzberg">
                    <outline text="Using proactive "/>
                </outline>
            </outline>
        </outline>
        <outline text="References">
            <outline text="References  #univariate #bivariate #verifiable #proactive #cloud #keys #crt #rsa #compartmented #sym #asym">
                <outline text="CRT (Chinese Remainder Theorem)"/>
                <outline text="Rafail Ostrovsky, Amit Sahai, Brent Waters - &quot;Attribute-Based Encryption with Non-Monotonic Access Structures&quot;"/>
                <outline text="https://en.wikipedia.org/wiki/Access_structure"/>
                <outline text="==="/>
                <outline text="I. Alam and A. Basit, &quot;An Extended Protected Secret Sharing Scheme,&quot; 2019 International Conference on Electrical, Electronics and Computer Engineering (UPCON), ALIGARH, India, 2019, pp. 1-4, doi: 10.1109/UPCON47278.2019.8980265. #bivariate "/>
                <outline text="Lein Harn, Zhe Xia, Chingfang Hsu, Yining Liu, Secret sharing with secure secret reconstruction,Information Sciences,Volume 519,2020,Pages 1-8, ISSN 0020-0255, https://doi.org/10.1016/j.ins.2020.01.038. #bivariate #verifiable #asym #sym "/>
                <outline text="Meng, K., Miao, F.,Huang, W., Xiong, Y. (2020) Threshold changeable secret sharing with secure secret reconstruction. https://doi.org/10.1016/j.ipl.2020.105928 #bivariate #univariate #sym "/>
                <outline text="Eldefrawy K., Lepoint T., Leroux A. (2020) Communication-Efficient Proactive Secret Sharing for Dynamic Groups with Dishonest Majorities. In: Conti M., Zhou J., Casalicchio E., Spognardi A. (eds) Applied Cryptography and Network Security. ACNS 2020. Lecture Notes in Computer Science, vol 12146. Springer, Cham. https://doi.org/10.1007/978-3-030-57808-4_1 #proactive #bivariate "/>
                <outline text="Yang, C. N., &amp; Lai, J. Bin. (2013). Protecting data privacy and security for cloud computing based on secret sharing. In Proceedings - 2013 International Symposium on Biometrics and Security Technologies, ISBAST 2013. https://doi.org/10.1109/ISBAST.2013.46 #cloud #univariate"/>
                <outline text="Zhang, F., Zhang, Y., Maram, S. K. D., Wang, L., Juels, A., Low, A., &amp; Song, D. (2019). ChURP: Dynamic-committee proactive secret sharing. In Proceedings of the ACM Conference on Computer and Communications Security. https://doi.org/10.1145/3319535.3363203 #proactive #secret-sharing #bivariate #sym "/>
                <outline text="Liu, Y., Yang, C., Wang, Y., Zhu, L., &amp; Ji, W. (2018). Cheating identifiable secret sharing scheme using symmetric bivariate polynomial. Information Sciences. https://doi.org/10.1016/j.ins.2018.04.043 #verifiable  #bivariate #sym"/>
                <outline text="Harn, L., &amp; Hsu, C. F. (2017). (t, n) Multi-Secret Sharing Scheme Based on Bivariate Polynomial. Wireless Personal Communications. https://doi.org/10.1007/s11277-016-3862-z #keys #bivariate #asym "/>
                <outline text="Harn, L., &amp; Hsu, C. F. (2015). Dynamic threshold secret reconstruction and its application to the threshold cryptography. Information Processing Letters. https://doi.org/10.1016/j.ipl.2015.06.014 #keys  #bivariate #sym "/>
                <outline text="Yang, C. N., Lai, J. Bin, &amp; Fu, Z. (2015). Protecting user privacy for cloud computing by bivariate polynomial based secret sharing. Journal of Computing and Information Technology. https://doi.org/10.2498/cit.1002593 #bivariate #cloud #keys #sym "/>
                <outline text="Goldberg, I., Jenkinson, G., &amp; Stajano, F. (2016). Low-cost mitigation against cold boot attacks for an authentication token. In Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics). https://doi.org/10.1007/978-3-319-39555-5_3 #keys #bivariate "/>
                <outline text="Asharov, G., Lindell, Y., &amp; Rabin, T. (2011). Perfectly-secure multiplication for any t &lt; n/3. In Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics). https://doi.org/10.1007/978-3-642-22792-9_14 #univariate #bivariate "/>
                <outline text="Wang, Z., Liu, Y., Yan, W., Wei, W., Li, J., Zhang, D., &amp; Alfandi, O. (2014). Cheating detection and cheater identification in (t, n) secret sharing scheme. Computer Systems Science and Engineering. #verifiable #crt "/>
                <outline text="Saxena, N., &amp; Yi, J. H. (2009). Noninteractive self-certification for long-lived mobile ad hoc networks. IEEE Transactions on Information Forensics and Security. https://doi.org/10.1109/TIFS.2009.2031946 #bivariate #keys #verifiable #sym "/>
                <outline text="Saxena, N., Tsudik, G., &amp; Yi, J. H. (2009). Efficient Node Admission and Certificateless Secure Communication in Short-Lived MANETs. IEEE Transactions on Parallel and Distributed Systems. https://doi.org/10.1109/TPDS.2008.77 #bivariate #verifiable #sym"/>
                <outline text="Nojoumian, M. (2016). Unconditionally secure proactive verifiable secret sharing using new detection and recovery techniques. In 2016 14th Annual Conference on Privacy, Security and Trust, PST 2016. https://doi.org/10.1109/PST.2016.7906973 #proactive #verifiable #bivariate #sym "/>
                <outline text="N, C. K., Basit, A., Singh, P., V. Ch., V., &amp; Y. V, S. R. (2017). Node Authentication Using BLS Signature in Distributed PKI Based MANETs. International Journal of Network Security &amp; Its Applications. https://doi.org/10.5121/ijnsa.2017.9403 #verifiable #bivariate #sym "/>
                <outline text="Chengli, Z., &amp; Chunming, T. (2011). An efficient threshold signature scheme. In TEIN 2011 - 2011 2nd ETP/IITA Conference on Telecommunication and Information. https://doi.org/10.14569/ijacsa.2012.030116 #verifiable #rsa #univariate "/>
                <outline text="Wang, X., Xiang, C., &amp; Fu, F. W. (2017). Secret sharing schemes for compartmented access structures. Cryptography and Communications. https://doi.org/10.1007/s12095-016-0205-6 #bivariate #compartmented"/>
                <outline text="Zhang, B., Xu, Q., Jiang, H., &amp; Zhao, X. (2012). Research on the round complexity of vss in the information theory model. International Journal of Digital Content Technology and Its Applications. https://doi.org/10.4156/jdcta.vol6.issue8.6 #inexistent"/>
                <outline text="Tang, D., &amp; Shu, H. (2012). A new secret sharing scheme based on bivariate polynomial. Advanced Science Letters. https://doi.org/10.1166/asl.2012.2665 #bivariate"/>
                <outline text="Tang, D., &amp; Huang, J. (2012). Secret image sharing scheme based on bivariate polynomial. In Proceeding of 2012 International Conference on Uncertainty Reasoning and Knowledge Engineering, URKE 2012. https://doi.org/10.1109/URKE.2012.6319543 #bivariate"/>
                <outline text="Tartary, C., Wang, H., &amp; Zhang, Y. (2011). An efficient and information theoretically secure rational secret sharing scheme based on symmetric bivariate polynomials. International Journal of Foundations of Computer Science. https://doi.org/10.1142/S0129054111008775 #bivariate  #sym "/>
                <outline text="Tassa, T., &amp; Dyn, N. (2009). Multipartite secret sharing by bivariate interpolation. Journal of Cryptology. https://doi.org/10.1007/s00145-008-9027-9 #bivariate #compartmented "/>
                <outline text="Tassa, T., &amp; Dyn, N. (2006). Multipartite secret sharing by bivariate interpolation. In Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics). https://doi.org/10.1007/11787006_25 #bivariate #compartmented"/>
                <outline text="Liu, Y., Zhang, Y., &amp; Hu, Y. (2012). Efficient (t, n) secret sharing scheme against cheating. Journal of Computational Information Systems. #bivariate #verifiable "/>
                <outline text="Wang, X., Fu, F. W., &amp; Guang, X. (2016). Probabilistic secret sharing schemes for multipartite access structures. IEICE Transactions on Fundamentals of Electronics, Communications and Computer Sciences. https://doi.org/10.1587/transfun.E99.A.856 #bivariate #compartmented"/>
                <outline text="Ji, W., Zhu, L., Wang, Y., Liu, Z., &amp; Hei, X. (2019). RSU authentication in vehicular ad hoc networks base on verifiable secret sharing. Journal of Intelligent and Fuzzy Systems. https://doi.org/10.3233/JIFS-179286 #verifiable #bivariate "/>
                <outline text="Lin, C., Yan, X., Niu, Q., &amp; Hu, H. (2019). Cheating immune multi-secret sharing without predefined order of secrets. Journal of the Chinese Institute of Engineers, Transactions of the Chinese Institute of Engineers,Series A/Chung-Kuo Kung Ch’eng Hsuch K’an. https://doi.org/10.1080/02533839.2018.1537806 #verifiable #bivariate"/>
                <outline text="@Simmons"/>
                <outline text="@Brickell"/>
            </outline>
        </outline>
        <outline text="Archive">
            <outline text="Projects">
                <outline text="MPhil Upgrade Report">
                    <outline text="Directive (From Rosalind E-Mail)">
                        <outline text="The report should be between 3,000 and 6,000 words in length (excluding appendices, footnotes and bibliography) - 20-25 pages maximum - and should include an account of your early experimental work and a detailed review of existing literature. It is essential that overall your project report demonstrates that the project has the scope and intellectual depth to justify registration for PhD. After submission of your upgrade documentation, your first supervisor will arrange an **upgrade presentation** attended by at least one independent assessor nominated by the Faculty Research Degrees Committee, who will use your submission as a basis for their review of your progress. __Section 2 of the RD5b form requires you to write an action plan including targets for the coming year - this is an important part of your submission, so it is essential that this is included.__ "/>
                        <outline text="the **deadline for your first supervisor to submit this is** **1700 on 31 January 2021**"/>
                    </outline>
                    <outline text="Writing notes">
                        <outline text="Link together zero knowledge proof related papers e.g.">
                            <outline text="Schnorr's signature scheme with ElGamal"/>
                            <outline text="Non-Interactive Heuristic with Schnorr's signature scheme"/>
                            <outline text="tsiounis improvement of elgamal with hasing to original elgamal"/>
                        </outline>
                    </outline>
                    <outline text="Structure">
                        <outline text="Introduction">
                            <outline text="The initial proposal of the project entails a Cyber Evidence Signalling framework. That is, an approach which aims to find out whether communicating parties have some common knowledge. The parties don't necessarily trust each other and have requirements that surround privacy. This proposal arises from the lack of the existence of such tool that cryptographically aids the objective of finding parties with common knowledge without revealing said knowledge."/>
                        </outline>
                        <outline text="Existing Literature">
                            <outline text="Cryptography &amp; Hard Problems">
<outline text="Justification for the use of cryptography is natural in the sense that it provides the confidentiality and integrity of information that the framework requires. "/>
<outline text="From an abstract level, cryptography provides the means to keep information confidential during a period of which the information is considered valuable. This stems into the trend that computational power has kept increasing for which will eventually be able to 'crack' encryption methods given enough time. Therefore, as computational power increases, stronger encryption methods are required i.e. requires more time to be able to break in respect to current and predicted computational power."/>
<outline text="Much of today's encryption relies on the Discrete Logarithm Problem [ref]. This is the problem of finding $$k$$ in $$a = b^k$$ which the logarithm $$\log_b a = k$$. The difficulty of the problem is derived from the process of not being able to directly reverse it and requires an efficient algorithm to do this. Most encryption methods for classical computers rely on modular arithmetic where the divisor is a prime number which contains properties that improve security. Briefly, large co-primes multiplied together as such in RSA are very difficult to factorise. In addition, modular arithmetic with prime numbers as the divisor prevents multiples from appearing in a table of operations (like a sudoku puzzle) which therefore prevent the possibility of bypassing the strength of encryption by finding a smaller multiple."/>
<outline text="[Modular Arithmetic Axioms] [Fermat's theorem] "/>
<outline text="Applicability of modular arithmetic with elliptic curves."/>
<outline text="[Elliptic Curve Arithmetic]"/>
<outline text="It might be worth noting the advent of quantum computers which are able to parallelise tasks by using multiple dimensions of existence that drastically improve the task of solving the Discrete Logarithm Problem using Schor's Algorithm [ref]. To circumvent the potential threat of quantum computing to information security, there have been proposals for quantum resistant encryption schemes e.g. [NTRU] [others qr encr]."/>
                            </outline>
                            <outline text="Commitments">
<outline text="A commitment scheme can be thought as a commitment of some information given to another party which can be later revealed to prove the claim of that information. The nature of this exchange has two main elements, the proof and verification for which the Pedersen Commitment scheme [ref] helps to understand."/>
<outline text="Pedersen">
    <outline text="[Pedersen as Algorithm]"/>
    <outline text="Reference #slide">
        <outline text="Authors | Torben Prdys Pedersen"/>
        <outline text="Title   | Non-Interactive and Information-Theoretic Secure Verifiable Secret Sharing"/>
        <outline text="Year    | 1992"/>
        <outline text="DOI     | 10.1007/3-540-46766-1_9"/>
    </outline>
</outline>
                            </outline>
                            <outline text="Zero-Knowledge Proofs">
<outline text="Extending from Commitments, Zero-Knowledge inherit the Peggy and Victor aspect of protocol while establishing 3 main properties [ref]:">
    <outline text="Zero-Knowledgeness -- Confidentiality is kept for the information that needs to be proved."/>
    <outline text="Completeness -- The verifier will have confidence that the prover knows the information that they didn't reveal."/>
    <outline text="Soundness -- There cannot be an instance where false information can be verified."/>
</outline>
<outline text="Zero-Knowledge Proofs aims to allow whether two parties share some knowledge in common without revealing or inferring this knowledge. From the properties described above the only result would not include any probability but a certainty of either true or false. "/>
<outline text="A hash function can be used in a similar way however, zero-knowledge proofs increase the security by being able to introduce entropy so that repeated function calls of the proof with the same knowledge input would render a different output every time."/>
<outline text="The initial paper that evolved into zero-knowledge proofs by Amos Fiat and Adi Shamir [ref] is born out of having a simpler method of proving something and creating different distinctions of proofs:">
    <outline text="Authentication: A can prove to B that he is A, but someone else cannot prove to B that he is A."/>
    <outline text="Identification: A can prove to B that he is A, but B cannot prove to someone else that he is A."/>
    <outline text="Signature schemes: A can prove to B that he is A, but B cannot prove even to himself that he is A."/>
</outline>
<outline text="The novelty of the scheme asserts less modular multiplications than RSA "/>
<outline text="The strand of development in zero-knowledge proofs has roots with Adi Shamir and Amos Fiat, Shamir is also one of the persons involved in RSA [ref] using a method similar to the Diffie-Hellman [ref] that had evolved with digital signatures [ref Identity-Based Cryptosystems and Signature Schemes/Schnorr's signature schemes]. Shamir and Fiat proposed an interactive protocol called the Fiat-Shamir Heuristic [ref]. This was later improved into a non-interactive protocol [stadler] which has outlined the 3 properties above. In addition,advancements similar in the El Gamal Signature scheme [ref] are seen where hash functions play a role. This is used in a way that the subject information is put through a trap-door avalanche function that has a deterministic but finite-length output large enough to prevent collisions. The following shows a non-interactive protocol of the Fiat-Shamir Heuristic, also known as the Random Oracle Access Scheme:"/>
<outline text="[NI Fiat-Shamir Heuristic]"/>
<outline text="dichotomy for ML scheme it was required to do zero knowledge with a scheme that was:">
    <outline text="had a value in common but must be observed by a third party that does not know that value"/>
    <outline text="deterministic so that the same value is created by other parties"/>
    <outline text="decryptable so that information passed on from third party which can be verified with a key"/>
    <outline text="this was AES in SIV mode as alternative to hashing"/>
</outline>
<outline text="ZK-SNARK">
    <outline text="Reference">
        <outline text="Bitansky, Nir; Canetti, Ran; Chiesa, Alessandro; Tromer, Eran (January 2012). [&quot;From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again&quot;](http://dl.acm.org/citation.cfm?id=2090263). __Proceedings of the 3rd Innovations in Theoretical Computer Science Conference on - ITCS '12__. [ACM](https://en.wikipedia.org/wiki/Association_for_Computing_Machinery). pp. 326–349. doi:[10.1145/2090236.2090263](https://doi.org/10.1145%2F2090236.2090263). ISBN 9781450311151. [S2CID](https://en.wikipedia.org/wiki/S2CID_(identifier)) [2576177](https://api.semanticscholar.org/CorpusID:2576177)"/>
    </outline>
</outline>
<outline text="ZK-STARK">
    <outline text="Scalable, transparent, and post-quantum secure computational integrity, Ben-Sasson, Eli and Bentov, Iddo and Horesh, Yinon and Riabzev, Michael, 2018"/>
</outline>
<outline text="Fiat-Shamir Heuristic">
    <outline text="Reference #slide">
        <outline text="Authors | Jan Stadler Camenisch and Markus"/>
        <outline text="Title   | Proof Systems for General Statements about Discrete Logarithms"/>
        <outline text="Year    | 1997"/>
        <outline text="DOI     | 10.1.1.56.1208"/>
    </outline>
</outline>
<outline text="1-out-of-2 Oblivious Transfer ">
    <outline text="Reference">
        <outline text="S. Even, O. Goldreich, and A. Lempel, &quot;A Randomized Protocol for Signing Contracts&quot;, Communications of the ACM, Volume 28, Issue 6, pg. 637–647, 1985."/>
    </outline>
</outline>
                            </outline>
                            <outline text="Secret Sharing">
<outline text="Univariate">
    <outline text="Shamir ">
        <outline text="Reference!"/>
    </outline>
    <outline text="Shah ">
        <outline text="Reference!"/>
    </outline>
    <outline text="Blakley">
        <outline text="Reference!"/>
    </outline>
    <outline text="Herzberg">
        <outline text="Reference!"/>
    </outline>
</outline>
<outline text="Bivariate">
    <outline text="Lein Harn">
        <outline text=""/>
    </outline>
    <outline text="Harn-Hsu"/>
    <outline text="Tamir Tassa"/>
</outline>
                            </outline>
                            <outline text="Money Laundering"/>
                            <outline text="Machine Learning"/>
                        </outline>
                        <outline text="Current Applications">
                            <outline text="Crypto"/>
                        </outline>
                        <outline text="Personal Work">
                            <outline text="Published Paper">
<outline text="A Secure Framework for Detection of MoneyLaundering Transactions using Secret Sharing"/>
                            </outline>
                            <outline text="Current Tasks">
<outline text="Improvements to Shah">
    <outline text="Communication protocol (reducing unnecessary requests when sharing)"/>
    <outline text="Pro-active secret sharing"/>
</outline>
<outline text="Evidence Signalling Framework"/>
                            </outline>
                        </outline>
                        <outline text="Conclusion"/>
                        <outline text="References">
                            <outline text=""/>
                        </outline>
                    </outline>
                </outline>
                <outline text="Cyber 2020 Talk [13:00 - 13:30 19th June]">
                    <outline text="https://kingston.box.com/s/nsggj8035dhq2xzzos555n7794kjgvk3"/>
                </outline>
            </outline>
            <outline text="Knowledge">
                <outline text="CRYPTOGRAPHY">
                    <outline text="ABOUT #h ">
                        <outline text="Trust #h">
                            <outline text="Entities">
<outline text="Trusted"/>
<outline text="Passive"/>
<outline text="Honest"/>
<outline text="Malicious"/>
                            </outline>
                        </outline>
                        <outline text="Hard Problems (good for security) #h ">
                            <outline text="Non-Deterministic Polynomial Time Complexity">
<outline text="Polynomial Time">
    <outline text="Problem that can be solved on a deterministic algorithm."/>
</outline>
<outline text="Non-Deterministic Polynomial Time"/>
<outline text="Non-Deterministic Polynomial Time - Complete"/>
<outline text="Non-Deterministic Polynomial Time - Hard"/>
                            </outline>
                            <outline text="Discrete Logarithm Problem #h">
<outline text="Description #slide">
    <outline text="The problem of finding $$k$$ in $$a = b^k$$ which the logarithm $$\log_b a = k$$. "/>
    <outline text="This is a difficult problem as this process cannot be directly reversed and requires an efficient algorithm to do this."/>
</outline>
<outline text="Problem #slide">
    <outline text="In terms of classical computers, there is no effective algorithm to determine $$k$$ in any relatively reasonable time that $$k$$ is considered as an important value for it's application."/>
    <outline text="In terms of quantum computers there is Schor's Algorithm"/>
</outline>
                            </outline>
                            <outline text="Shortest Vector Problem #h" colorLabel="1"/>
                        </outline>
                        <outline text="Data Structures #h">
                            <outline text="Hash Chains #h "/>
                            <outline text="Bloom Filter #h">
<outline text="Definition #slide">
    <outline text="Probabilistic data structure where it can be tested if an element exists in a set. "/>
</outline>
<outline text="Characteristics #slide">
    <outline text="A zeroed bit array of size $$k$$ can have arbitrary data plotted at certain indexes. "/>
    <outline text="For example:">
        <outline text="In an Bloom Filter of size 32, the word &quot;hello&quot; sent through a non-cryptographic hash mod 32 can result in 10. "/>
        <outline text="The output of a hash such as 10 means the index of the Bloom Filter at 10 will have it's bit flipped from False to True or 0 to 1. "/>
    </outline>
    <outline text="After adding other elements, it can be determined rapidly if &quot;hello&quot; exists in the set by using the same method."/>
    <outline text="Recommended bits per element for &lt;1% false-positive is 10-15."/>
</outline>
<outline text="Types #slide">
    <outline text="Bit Bloom Filter where points have their respective bits flipped."/>
    <outline text="Counter Bloom Filter which instead of flipping bits, can have superposing of points."/>
</outline>
                            </outline>
                        </outline>
                        <outline text="Protocols (Conceptually) #h" colorLabel="4">
                            <outline text="Intro / General Properties #h">
<outline text="Definition #slide">
    <outline text="A protocol is a series of steps, involving two or more parties, to accomplish a task"/>
    <outline text="There are different protocols for different purposes"/>
    <outline text="Example of a human protocol: Dining in a Posh Restaurant"/>
    <outline text="__Cryptographic/Security Protocol __">
        <outline text="A set of communication rules (specification) in order to achieve security goals amongst a set of users"/>
        <outline text="Can be very difficult to get free of vulnerabilities"/>
    </outline>
</outline>
<outline text="Characteristics #slide">
    <outline text="All parties must have complete knowledge of all the steps involved, in advance"/>
    <outline text="All parties must agree to follow the protocol"/>
    <outline text="Must be unambiguous -- each step must be well defined, so that no misunderstandings"/>
    <outline text="Must be complete -- there must be a specified action for every possible situation"/>
    <outline text="It should not be possible to do more or learn more than that specified in the protocol"/>
</outline>
<outline text="Types #slide">
    <outline text="Based on criteria of dispute resolution mechanism, there are three main types:" _note="[Further Reading](https://www.slideshare.net/afiqefendy/protocols-and-practicesinusingencryption-chap)">
        <outline text="Arbitrated -- a Trusted Third Party is involved"/>
        <outline text="Adjudicated -- communications proceed with no third party until a disagreement"/>
        <outline text="Self-enforcing -- no involvement other than from users"/>
    </outline>
    <outline text="Trust Architecture">
        <outline text="Centralised (TTP) -- online/offline"/>
        <outline text="Partly decentralised (Distributed TTP) -- online/offline"/>
        <outline text="Fully decentralised (no TTP)"/>
    </outline>
    <outline text="Interactivity">
        <outline text="Interactive/non-interactive"/>
    </outline>
</outline>
<outline text="Interactive Protocol #slide">
    <outline text="Multiple rounds of communication is required to achieve the cryptographic objective of a protocol."/>
    <outline text="Alice and Bob may have to exchange information in succession."/>
    <outline text="For example:">
        <outline text="Alice may need to use a value from Bob in order to compute another value."/>
        <outline text="She also uses her own private value in conjuction."/>
        <outline text="This is sent back to Bob where he might also use his own secret value that contributes to the objective of the protocol."/>
    </outline>
</outline>
<outline text="Non-Interactive Protocol #slide ">
    <outline text="Definition ">
        <outline text="A party can broadcast or complete the cryptographic objective of the protocol by communicating once."/>
    </outline>
</outline>
                            </outline>
                            <outline text="Secret Sharing #h">
<outline text="Properties">
    <outline text="General ">
        <outline text="Privacy preserving"/>
        <outline text="Data Recovery"/>
        <outline text="Access Structure">
            <outline text="Monotone Class theorem"/>
            <outline text="(k,n) threshold scheme"/>
        </outline>
    </outline>
    <outline text="Additional">
        <outline text="Non-malleable secret sharing"/>
        <outline text="Dissimenating"/>
        <outline text="Proactive"/>
        <outline text="Dynamic"/>
        <outline text="Multi-Secret"/>
        <outline text="&quot;veto&quot;ing"/>
    </outline>
</outline>
<outline text="Construct">
    <outline text="Polynomial">
        <outline text="Univariate"/>
        <outline text="Bivariate"/>
    </outline>
</outline>
<outline text="Network">
    <outline text="Entities">
        <outline text="Dealer">
            <outline text="Initial secret handler"/>
            <outline text="Splits secret into shares"/>
        </outline>
        <outline text="Shareholder">
            <outline text="Obtains and may 'share' a share."/>
            <outline text="Reconstructs secret"/>
        </outline>
    </outline>
    <outline text="Types">
        <outline text="Asynchronous"/>
        <outline text="Dealer-free"/>
        <outline text="Propagating"/>
    </outline>
</outline>
<outline text="Security Goals?">
    <outline text="Correctness"/>
    <outline text="Consistency"/>
</outline>
<outline text="Applications">
    <outline text="Distributed Certificate Authorities"/>
    <outline text="Distributed Data Storage"/>
    <outline text="Distributed Signing Authority"/>
    <outline text="Electronic voting"/>
    <outline text="Fair exchange"/>
    <outline text="Hardware security modules"/>
    <outline text="Hiding Information"/>
    <outline text="Key management in Ad-Hoc networks"/>
    <outline text="Key recovery mechanisms"/>
    <outline text="Location privacy"/>
    <outline text="Multi-party Computation"/>
    <outline text="RFID"/>
    <outline text="Secure Online Auctions"/>
</outline>
<outline text="Considerations">
    <outline text="Dealer">
        <outline text="Trusted"/>
    </outline>
    <outline text="Shareholders">
        <outline text="Malicious">
            <outline text="Identifiable"/>
            <outline text="Detectable"/>
            <outline text="Passive"/>
            <outline text="Active"/>
        </outline>
        <outline text="Collusion">
            <outline text="Denial of Recovery"/>
            <outline text="Confidentiality"/>
        </outline>
    </outline>
    <outline text="Network">
        <outline text="Communication Cost">
            <outline text="Interactive/Non-interactive"/>
        </outline>
        <outline text="Topology">
            <outline text="Dynamic/Static Participation"/>
        </outline>
        <outline text="MITM">
            <outline text="Confidentiality"/>
            <outline text="Integrity">
                <outline text="Forgery"/>
            </outline>
        </outline>
    </outline>
    <outline text="Shares">
        <outline text="Bit Size"/>
        <outline text="Publicity">
            <outline text="Before reaching shareholder"/>
            <outline text="Broadcasted or given to another shareholder"/>
        </outline>
        <outline text="Immutability"/>
        <outline text="Verifiability"/>
    </outline>
    <outline text="&quot;Hull Patching&quot;">
        <outline text="Zero-Knowledge Proofs"/>
        <outline text="Public Key Cryptography"/>
    </outline>
</outline>
                            </outline>
                            <outline text="Secure Commitment #h">
<outline text="Definition #slide">
    <outline text="An entity wants to reveal information in the future but keep it confidential for now. "/>
    <outline text="A commitment can represent the proof of this information whilst preserving the privacy. When it is revealed, the commitment will verify the revealed information."/>
</outline>
<outline text="Verification #slide">
    <outline text="A protocol allows the verifier to produce a challenge for the information provided by the prover. "/>
    <outline text="The challenge with conjuction of the verifier’s information can be used to produce a result."/>
    <outline text="This result determines if the prover’s information has a relationship with the verifier’s."/>
</outline>
                            </outline>
                            <outline text="Zero-Knowledge Proofs #h">
<outline text="Description #slide">
    <outline text="Involves Peggy (prover) and Victor (verifier)"/>
    <outline text="Peggy attempts to prove she knows $$x$$ to Victor but without revealing $$x$$ at any point."/>
    <outline text="$$x$$ can represent any data especially as it can be represented through a hash."/>
</outline>
<outline text="Characteristics #slide">
    <outline text="Peggy usually computes a proof where Victor creates a challenge in order to verify it derived by their  respective secret values."/>
    <outline text="There are 3 main properties:">
        <outline text="Zero-knowledgeness - Confidentiality is kept for the information that needs to be proved."/>
        <outline text="Completeness - The verifier will have confidence that the prover knows the information that they didn't reveal."/>
        <outline text="Soundness - There cannot be an instance where false information can be verified."/>
    </outline>
    <outline text="They are secure for in terms of Discrete Logarithm Problem for classical computers. "/>
    <outline text="Potential vulnerable to Schor's Algorithm"/>
</outline>
<outline text="Types #slide">
    <outline text="Zero-Knowledge Proof Protocols can be done in 2 ways:">
        <outline text="Interactive"/>
        <outline text="Non-Interactive"/>
    </outline>
</outline>
                            </outline>
                            <outline text="Format Preserving Encryption"/>
                            <outline text="Bitcoin (2008) #h">
<outline text="Philosophy #slide">
    <outline text="Security for the seller by producing non-reversible transactions."/>
    <outline text="Security for the buyer with routine escrow systems."/>
    <outline text="Proof replacing trust in the secure third party model."/>
    <outline text="Peer-to-peer exchange of money like physically handing cash."/>
</outline>
<outline text="Transactions #h">
    <outline text="Description #slide ">
        <outline text="Electronic coin is a chain of digital signatures."/>
        <outline text="Transferring a coin requires to digitally sign a hash of the previous transaction and the public key of the new owner. This signature is added at the end of the coin."/>
        <outline text="Signatures allow public keys belonging to the previous owners to verify the chain of ownership."/>
    </outline>
    <outline text="Double-Spending #slide ">
        <outline text="Double-spending is when a single coin may be used for multiple transaction."/>
        <outline text="The conventional solution is to use a central authority, i.e. the mint."/>
        <outline text="Solve the problem of the next owner being able to know that the previous owners haven't signed earlier transactions."/>
    </outline>
    <outline text="Public Transactions #slide ">
        <outline text="To solve double-spending the transactions have to be announced publicly, i.e. `to confirm the absence of a transaction is to be aware of all transactions'."/>
        <outline text="Participants agree on a single history of the order in which the transactions have been received."/>
        <outline text="The new owner requires proof that the majority of participants agree that each transaction at the time was the first received."/>
    </outline>
</outline>
<outline text="Timestamp Server #slide ">
    <outline text="Proof that transactions existed at a time is solved with a timestamp server. The server computes a hash of a block of items and publishes the hash."/>
    <outline text="This server allows data to be proven to exist at a certain time with confidence."/>
    <outline text="Timestamps are linked with previous timestamps in its hash therefore creating this chain reinforces the previous timestamps."/>
</outline>
<outline text="Proof-of-Work #h">
    <outline text="Description #slide ">
        <outline text="In a peer-to-peer network, the timestamp server will need to generate this hash that requires to invest time computing the hash of the block. "/>
        <outline text="The way of seeing a majority consensus is represented as the longest chain because this is most amount of work done. Essentially voting with CPU power required to proceed."/>
        <outline text="A hash beginning with a number zero bits is required to be computed but with an added challenge that it needs a nonce applied. The input to produce this value is the proof-of-work. Increasing the zero bits requires exponential amount of work."/>
        <outline text="Note that the timestamp server links these hashes together."/>
    </outline>
    <outline text="Properties #slide ">
        <outline text="The longest chain means more participants are invested to make an effort in doing the proof-of-work."/>
        <outline text="An attacker that wants to modify a block will need to redo the work for the block and the ones afterwards, attempting to surpass with `honest' participants."/>
        <outline text="The probability of a slow attacker catching up are drastically low  and get lower as subsequent blocks are added."/>
        <outline text="The difficulty of the proof-of-work is adjusted to how many blocks are generated at a time. If blocks are generated quickly, the difficulty increases."/>
    </outline>
</outline>
<outline text="Network #h">
    <outline text="Protocol Summary #slide">
        <outline text="A series of steps are taken for participants to communicate:" listStyle="arabic">
            <outline text="New transactions are broadcast to all nodes."/>
            <outline text="Each node collects new transactions into a block."/>
            <outline text="Each node works on finding a difficult proof-of-work for its block."/>
            <outline text="When a node finds a proof-of-work, it broadcasts the block to all nodes."/>
            <outline text="Nodes accept the block only if all transactions in it are vaalid and not already spent."/>
            <outline text="Nodes express their acceptance of the block by working on creating the next block in the chain, using the hash of the accepted block as the previous hash."/>
        </outline>
        <outline text="Reminder that the longest chain, representing the majority vote, is always considered to be the valid one. "/>
        <outline text="Transactions don't need to reach every node but as long as a majority has these transactions a block containing them will be produced."/>
    </outline>
    <outline text="Inconsistent block broadcasting #slide">
        <outline text="Two nodes that broadcast different versions of the next block at the same time means some nodes receive one or the other first. "/>
        <outline text="A race begins to work on a new block based on the first one received and gain the proof-of-work."/>
        <outline text="When the first proof-of-work is found, the participants will switch to this branch."/>
        <outline text="In the case that a node doesn't get a block, it will request this additional information when it next receives a block."/>
    </outline>
</outline>
<outline text="Incentive #slide ">
    <outline text="The first transaction of the new block is a transaction that belongs to the creator of the new block."/>
    <outline text="Therefore the creator of this new block earns a new coin which is the incentive to perform this task."/>
    <outline text="This adds new coins into circulation which costs time and electricity."/>
    <outline text="Honesty is rewarded by being more profitable than defrauding because honest participants will not validate the value of coins held by attackers."/>
</outline>
<outline text="Reclaiming Disk Space #slide ">
    <outline text="Spent transactions can be discarded to save disk space. "/>
    <outline text="Hash of Merkle is still valid after pruning some transactions."/>
</outline>
<outline text="Simplified Payment Verification #slide ">
    <outline text="Verifying payments doesn't require running a `full' network node. Only block headers of the longest proof-of-work chain is needed. "/>
    <outline text="A Merkle branch linking transactions can be seen that the network node has accepted it and additional blocks reinforce this."/>
    <outline text="Detected invalid blocks manipulated by attackers would be alerted to other nodes which prompts them to update the full block."/>
</outline>
<outline text="Combining and Splitting Value #slide ">
    <outline text="Transactions contain multiple inputs and outputs so that a single transactions doesn't correspond to a single cent."/>
    <outline text="Inputs consist of a single large transactions or multiple small ones."/>
    <outline text="Outputs contain at most two outputs, the payment and the change."/>
    <outline text="A fan-out transaction relationship, where one transaction depends on multiple transactions and those also depend on other multiple transactions do not cause issues."/>
    <outline text="It is never required to get the complete copy of a transaction history."/>
</outline>
<outline text="Privacy #slide ">
    <outline text="All transactions are publicly announced but public keys associated are anonymous."/>
    <outline text="Revealing the owner of the key would reveal which transactions they belonged to."/>
</outline>
<outline text="Evidence of effectiveness #slide ">
    <outline text="$$p =$$ probability an honest node finds the next block."/>
    <outline text="$$q =$$ probability the attacker finds the next block."/>
    <outline text="$$z =$$ blocks that have been linked afterwards."/>
    <outline text="Attacker's potential progress defined by Poisson distribution:">
        <outline text="$$\lambda = z \frac{q}{p}$$"/>
    </outline>
    <outline text="Probability the attacker could catchup"/>
</outline>
<outline text="Conclusion #slide ">
    <outline text="Control of ownership with digital signatures."/>
    <outline text="Double-spending solved with peer-to-peer network using proof-of-work to make it impractical for an attacker to manipulate."/>
    <outline text="Network requires little maintenance as no particular routing is needed, no identification or co-ordination."/>
    <outline text="Framework will continue normally despite nodes joining and leaving the network."/>
    <outline text="Majority of CPU power directs the validity of transactions and value of currency."/>
</outline>
                            </outline>
                        </outline>
                    </outline>
                    <outline text="Data Structures">
                        <outline text="Hash Chains #h "/>
                        <outline text="Bloom Filter #h">
                            <outline text="Definition #slide">
<outline text="Probabilistic data structure where it can be tested if an element exists in a set. "/>
                            </outline>
                            <outline text="Characteristics #slide">
<outline text="A zeroed bit array of size $$k$$ can have arbitrary data plotted at certain indexes. "/>
<outline text="For example:">
    <outline text="In an Bloom Filter of size 32, the word &quot;hello&quot; sent through a non-cryptographic hash mod 32 can result in 10. "/>
    <outline text="The output of a hash such as 10 means the index of the Bloom Filter at 10 will have it's bit flipped from False to True or 0 to 1. "/>
</outline>
<outline text="After adding other elements, it can be determined rapidly if &quot;hello&quot; exists in the set by using the same method."/>
<outline text="Recommended bits per element for &lt;1% false-positive is 10-15."/>
                            </outline>
                            <outline text="Types #slide">
<outline text="Bit Bloom Filter where points have their respective bits flipped."/>
<outline text="Counter Bloom Filter which instead of flipping bits, can have superposing of points."/>
                            </outline>
                        </outline>
                    </outline>
                </outline>
                <outline text="Linear Algebra #h ">
                    <outline text="Notations #slide #arman ">
                        <outline text="spec($$A$$) -- the spectrum (set of eigenvalues) of the matrix $$A$$."/>
                        <outline text="$$\otimes$$ -- the &quot;Kronecker Product&quot;, defined as #todo  "/>
                        <outline text="$$V({x_1,\ldots, x_n})$$ -- Vandermonde matrix with entries that are powers of $$x_1, ... , x_n$$."/>
                        <outline text="So:">
                            <outline text="$$V({x_1,\ldots, x_n}) = \begin{bmatrix}1 &amp; \cdots &amp; 1 \\ x_1 &amp; \cdots  &amp; x_n \\ x_{1}^2 &amp; \cdots &amp; x_{n}^2 \\ \vdots &amp; &amp; \vdots \\ x_{1}^{n-1} &amp; \cdots &amp; x_{n}^{n-1} \end{bmatrix}$$"/>
                        </outline>
                    </outline>
                    <outline text="Sylvester Equation #slide #arman">
                        <outline text="These are matrix equations $$AX - XB = C$$ where $$A$$ and $$B$$ are square matrices of order $$m$$ and $$n$$."/>
                        <outline text="Goal is to find the $$m$$ by $$n$$ matrix $$X$$."/>
                        <outline text="The following is a well-known fact:">
                            <outline text="The sylvester equation admits a unique solution $$X$$, iff $$A$$ and $$B$$ have no eigenvalues in common."/>
                            <outline text="In this case, the solution is $$x = (I \otimes A - B^t \otimes I)^{-1} \cdot c$$ where $$x$$ and $$c$$ are the matrices $$X$$ and $$C$$ rearranged as single column vectors."/>
                        </outline>
                    </outline>
                    <outline text="Conjecture #slide #arman">
                        <outline text="Informally:">
                            <outline text="Vandermonde-matrices with pairwise different index sequences $$x_1, ..., x_n$$ and $$y_1, ... , y_m$$ have no eigenvalues in common."/>
                        </outline>
                        <outline text="Formally:">
                            <outline text="$$x = (x, ..., x_n), y = (y_1, ... , y_n)$$ and $$x_i \neq y_j (\forall i, j)\Leftrightarrow$$ spec($$V_x$$) $$\cap$$ spec($$V_y$$) = $$\emptyset$$."/>
                        </outline>
                    </outline>
                </outline>
                <outline text="Secret Sharing #h">
                    <outline text="Introduction #slide #arman ">
                        <outline text="In secret sharing schemes a secret is distributed among a set of users $$\mathcal{P}$$ in such a way that only some sets, the authorised sets, can recover it. "/>
                        <outline text="Secret sharing schemes are useful for not trusting a single party e.g. two members of staff required to open a vault. "/>
                        <outline text="Similar challenges can arise in other sensitive areas where a secret should be recovered only if certain users, the authorised sets, get together. "/>
                    </outline>
                    <outline text="Notations #slide #arman ">
                        <outline text="Let denote $$\mathcal{P} =\{P_1, P_2, ...,P_n\}$$ be a set of parties."/>
                    </outline>
                    <outline text="On Access Structures #h #arman ">
                        <outline text="Access Structures #slide #arman">
                            <outline text="Given a set of players $$\mathcal{P} = \{{P}_1, \ldots , {P}_n\}$$, the family $$\Gamma  \subset 2^\mathcal{P}$$ of __authorized sets__ is the __access structure__ of the secret sharing scheme."/>
                            <outline text="Example: for $$n=3$$ parties $$P_1 , P_2, P_3$$ that participate in a secret sharing scheme with threshold $$k=2$$,  the authorised sets are $$\{P_1, P_2\}$$, $$\{P_1 , P_3\}$$, $$\{P_2, P_3\}$$ and $$\{P_1, P_2, P_3\}$$."/>
                            <outline text="A collection $$\Gamma \subseteq 2^\mathcal{P}$$ is __monotone__ if: $$\mathcal{V} \in \Gamma$$ and $$\mathcal{V} \subseteq \mathcal{W} \Rightarrow \mathcal{W} \in \Gamma $$."/>
                            <outline text="Usually, access structures are monotone collections."/>
                        </outline>
                        <outline text="Compartmented Access Structures #slide #arman ">
                            <outline text="Denote $$\mathcal{C} = \{\mathcal{C}_1,...,\mathcal{C}_m \}$$ a partition of $$\mathcal{P}$$ into $$m$$ disjoint subsets, or __compartments__: $$\mathcal{P} = \bigcup^m_{i=1} \mathcal{C}_i$$."/>
                            <outline text="Let ">
<outline text="$$t_i \in \mathbb{N}$$ ($$1 \leq i \leq m$$), and $$\sum^m_{i=1} t_i \le t \in \mathbb{N}$$,"/>
<outline text="$$s_i \in \mathbb{N}$$ ($$1 \leq i \leq m$$), and $$\sum^m_{i=1} s_i \ge s \in \mathbb{N}$$. "/>
                            </outline>
                            <outline text="A __compartemented access structure__ with __lower__ (__upper__ respectively) __bounds__ consists of all subsets containing at least $$t_i$$ (at most $$s_i$$) participants from $$C_i$$ for $$1 \leq i \leq m$$, and a total of at least $$t$$ ($$s$$ respectively) participants."/>
                            <outline text="Formally: ">
<outline text="$$\Gamma = \{\mathcal{V} \subseteq \mathcal{P} : \exists \mathcal{W} \subseteq \mathcal{V}$$ such that $$|\mathcal{W} \cap \mathcal{C}_i | \geq t_i, 1 \leq i \leq m$$, and $$ |\mathcal{W}| = t \}$$."/>
<outline text="$$\Delta= \{\mathcal{V} \subseteq \mathcal{P} : \exists \mathcal{W} \subseteq \mathcal{V}$$ such that $$|\mathcal{W} \cap \mathcal{C}_i | \le s_i, 1 \leq i \leq m$$, and $$ |\mathcal{W}| = s \}$$."/>
                            </outline>
                            <outline text="Original notion by @Simmons had $$\sum^m_{i=1} t_i = t $$, later generalised by @Brickell. "/>
                        </outline>
                        <outline text="Multipartite Access Structures #slide #arman ">
                            <outline text="Let $$\Gamma \in 2^\mathcal{P}$$ be a compartmented access structure."/>
                            <outline text="An $$m$$-__partite__ (or __multipartite__) access structure on $$\mathcal{P}$$ with respect to partition $$\mathcal{C}$$ is any access structure that does not distinguish between members of the same compartment."/>
                            <outline text="Formally:">
<outline text="Assume that for all permutations $$\pi : \mathcal{P} \rightarrow \mathcal{P}$$ such that $$\pi(\mathcal{C}_i) =\mathcal{C_i}\;(1 \leq i \leq m), \;\mathcal{V} \in \Gamma$$ if and only if $$\pi(\mathcal{V}) \in \Gamma$$. "/>
<outline text="Then $$\Gamma$$ is called $$m$$-__partite__ or __multipartite__ with respect to partition $$\mathcal{C}$$."/>
                            </outline>
                            <outline text="Given any subset $$\mathcal{W} \subseteq \mathcal{U}$$, its __type__ with respect to partition (1) is the vector $$(t_1,...,t_m) \in \mathbb{N}^m $$, where $$t_i = |\mathcal{W} \cap \mathcal{C}_i |, 1 \leq i \leq m.$$"/>
                        </outline>
                        <outline text="ARCHIVE">
                            <outline text="INBOX ">
<outline text="The set of elements of $$\mathcal{V}$$ are also elements of $$\mathcal{U}$$."/>
<outline text="There exists a set $$\mathcal{V}$$ such that the number of elements that are in common with set $$\mathcal{W}$$ and $$\mathcal{C}_i$$ is greater than $$t_i$$. ">
    <outline text="where $$\mathcal{C}_i$$ is a set of participants in a compartment and $$\mathcal{U}$$ is a set of all participants in all compartments?"/>
</outline>
<outline text="$$i$$ is not less than l or greater than $$m$$ and the number of elements in $$\mathcal{W}$$ is $$t$$. ">
    <outline text="where $$m$$ is the number of compartments and $$t$$ is the number of participants."/>
</outline>
<outline text="So is subset of participants that are at least size $$t$$ ($$t$$ out of $$n$$?) which are authorised to recover their secret? "/>
                            </outline>
                            <outline text="The sets in $$\Gamma$$ are called the authorised sets, and the sets not in $$\mathbb{A}$$ are called the unauthorised sets.">
<outline text="An access structure (respectivily, monotonic access structure) is a collection (respectively, monotone collection) $$\Gamma$$ of non-empty subsets of $$\{P_1,P_2 ,..., P_n\}$$, i.e., $$\Gamma \subseteq 2^{\{P_1,P_2,...,P_n\}} \setminus \{\emptyset\}$$."/>
                            </outline>
                        </outline>
                    </outline>
                    <outline text="Ideal and Perfect Schemes #slide "/>
                    <outline text="Shamir Secret Sharing -- Matrix Version #h">
                        <outline text="Principle #slide">
                            <outline text="View the evaluation of Shamir polynomial $$f(x)$$ at point $$x_i$$ as vector multiplication:">
<outline text="$$f(x_i) = (1, x_i , x_i^2, ..., x_i^{k-1}) \cdot \begin{bmatrix}s \\ a_1 \\ a_2 \\ \vdots \\ a_{k-1} \end{bmatrix}$$. "/>
                            </outline>
                            <outline text="Hence, the following matrix equations contains all shares $$(x_i, f(x_i) = y_i)$$ for $$i = 1, ..., n$$:">
<outline text="$$V_{(x_1,...,x_n)} := \begin{bmatrix} 1 &amp; x_1 &amp; x_1^2 &amp; \cdots &amp; x_1^{k-1} \\ 1 &amp; x_2 &amp; x_2^2 &amp; \cdots &amp; x_2^{k-1} \\ \vdots &amp; \vdots &amp; \vdots &amp; &amp;\vdots \\ 1 &amp; x_n &amp; x_n^2 &amp; \cdots &amp; x_n^{k-1} \end{bmatrix} \cdot \begin{bmatrix} s \\ a_1 \\ a_2 \\ \vdots \\ a_{k-1} \end{bmatrix} = \begin{bmatrix} y_1 \\ y_2 \\ \vdots \\ \\ y_{k-1} \end{bmatrix}$$. "/>
                            </outline>
                        </outline>
                        <outline text="Reconstruction of Secret #slide ">
                            <outline text="This is possible if the Vandermonde matrix is square and invertible."/>
                            <outline text="Choose a coalition $$\{x_i,...,x_{in}\}$$ of distinct points. Then:">
<outline text="$$\begin{bmatrix} s \\ a_1 \\ a_2 \\ \vdots \\ a_{k-1} \end{bmatrix} = \begin{bmatrix} 1 &amp; x_1 &amp; x_1^2 &amp; \cdots &amp; x_1^{k-1} \\ 1 &amp; x_2 &amp; x_2^2 &amp; \cdots &amp; x_2^{k-1} \\ \vdots &amp; \vdots &amp; \vdots &amp; &amp;\vdots \\ 1 &amp; x_n &amp; x_n^2 &amp; \cdots &amp; x_n^{k-1} \end{bmatrix}^{-1} \cdot \begin{bmatrix} y_1 \\ y_2 \\ \vdots \\ \\ y_{k-1} \end{bmatrix}$$. "/>
                            </outline>
                        </outline>
                    </outline>
                    <outline text="Bivariate Secret Sharing #h">
                        <outline text="Introduction #slide #arman">
                            <outline text="The secret is (part of) a bivariate polynomial $$f(x, y)$$."/>
                            <outline text="Let $$P_1, P_2,...,P_n$$ be players involved in the sharing scheme."/>
                            <outline text="We have:">
<outline text="Symmetric bivariate SS - the poly is symmetric ($$f(x,y) = f(y,x)$$)."/>
<outline text="Asymmetric BSS otherwise."/>
                            </outline>
                            <outline text="The are several applications of BSS:">
<outline text="Multi-secret sharing"/>
<outline text="Key agreement"/>
<outline text="Implementing advanced SS with special access structures"/>
                            </outline>
                        </outline>
                        <outline text="Matrix Notations #slide #arman">
                            <outline text="Galois Field for prime $$p$$ - $$\mathbb{F}_p$$"/>
                            <outline text="Principle: write $$f(x,y)$$ as a matrix $$F = ((a_{i,j}))$$ where $$f(x, y) = \sum^m_{i=0} \sum^m_{i=0} a_{ij} x^i y^j \pmod{p}$$."/>
                            <outline text="Create shares by evaluating $$f$$ at various points, e.g. $$f(x_i,y), f(x,y_i)$$ or $$f(x_i,y_i)$$. [Depending on application]"/>
                            <outline text="Reconstruct $$f$$ by creating invertible Vandermonde matrix from a coalition of shares/players."/>
                        </outline>
                        <outline text="Multi-Secret Sharing #slide #arman">
                            <outline text="Each Player receives $$g_i(y)=f(x_i, y)$$."/>
                            <outline text="Reconstruction of $$f(x,y)$$ is based on $$V(x_1, ...,x_n) \cdot F = \begin{bmatrix} \text{coeffs}_y(g_1) \\ \vdots \\ \text{coeffs}_y(g_m) \end{bmatrix}$$ and inverting $$V(x_{i_1}, ....,x_{i_k})$$."/>
                            <outline text="Similarly, the scheme could be using $$h_j(y)=f(x,y_j)$$: ">
<outline text="$$F \cdot V(y_1,...,y_n)^t = \begin{bmatrix} \text{coeffs}_x(f(x,y)) \\ \vdots \\ \text{coeffs}_x(f(x,y_n)) \end{bmatrix}$$"/>
                            </outline>
                            <outline text="But this is not different to running multiple instances of Shamir SS."/>
                        </outline>
                        <outline text="Harn-Hsu's Bivariate Secret Sharing #h #arman ">
                            <outline text="Share Creation #slide #arman">
<outline text="$$t$$ secrets $$\{s_1, s_2, ... s_t\}$$ where $$s_r = f(r,0)$$"/>
<outline text="$$f(x, y)$$ where $$x$$ and $$y$$ have degree $$t-1$$."/>
<outline text="Dealer computes $$f_i(x) = f(x,i),i = 1,2,...,n$$ and sends this result to the respective $$P_i$$ shareholder."/>
                            </outline>
                            <outline text="Share Reconstruction #slide #arman">
<outline text="$$t$$ Players $$\{P_1, ..., P_t\} \subset \{P_1, P_2, ... , P_n\}, t \leq n$$ can recover the secret."/>
<outline text="For secret a $$s_r$$ each player $$P_i \in \{P_1, ... , P_t\}$$ computes a value $$e_i = f_i(r) = f(r, i)$$."/>
<outline text="$$t$$ number of $$e$$ values are required to recover secret $$s_r$$."/>
<outline text="$$\sum^t_{i=1} (e_i \sum^t_{j=1, j \neq i} \frac{-j}{i - j})\pmod{p} = s_r$$"/>
<outline text="Vandermonde $$V_{ij}$$ of dimension $$i,j$$ is inverted and transposed $$\hat{V_{ij}}$$, $$\hat{V_{ij}} = V_{ij}^{-1 \rightarrow T}$$."/>
<outline text="First column is taken where $$N = \hat{V_{1j}}$$"/>
<outline text="$$\begin{bmatrix} e_{11} &amp; \dots &amp; e_{1n} \\ \vdots &amp; &amp; \vdots \\ e_{1n} &amp; \dots &amp; e_{rn} \end{bmatrix} \cdot N = \begin{bmatrix} s_1 \\ \vdots \\ s_r \end{bmatrix}$$"/>
                            </outline>
                        </outline>
                        <outline text="Tassa's Probabilistic Multipartite Scheme #h "/>
                        <outline text="A Novel Deterministic Bipartite Scheme #h">
                            <outline text="Introduction #slide #arman"/>
                            <outline text="Properties #slide #arman">
<outline text="There are two sets of players:">
    <outline text="$$\mathcal{P} = \{P_1, ..., P_n\}$$ and $$\mathcal{Q} = \{Q_1,...,Q_n\}$$"/>
</outline>
<outline text="Each set has associated thresholds $$k$$ and $$l$$."/>
<outline text="A coalition of at least $$k$$ players of $$P$$ and at least $$l$$ players of $$Q$$ can reconstruct the secret."/>
<outline text="Any coalition with less than these players do not gain (any? all?) information about the secret."/>
                            </outline>
                            <outline text="Notations #slide #arman ">
<outline text="Given a secret $$s$$, we create a bivariate polynomial $$f(x,y)$$ with $$\deg_x f = k-1$$ and $$\deg_y f = l-1$$."/>
<outline text="We set $$f(0,0) = s$$ and $$f(i,j)$$ is random $$(i,j \neq 0)$$."/>
<outline text="Furthermore, we form the matrix $$B := ((b_{ij}))$$ where $$1 \leq i \leq n, 1 \leq j \leq n$$, and ">
    <outline text="$$b_{ij} = \begin{bmatrix} 1 &amp; x_i &amp;  \cdots &amp; x_i^{k-1} \end{bmatrix} \cdot \begin{bmatrix} a_{0j} \\ a_{1j} \\ \vdots \\ a_{kj} \end{bmatrix} - \begin{bmatrix}a_{i0} &amp; a_{i1} &amp; \cdots &amp; a_{il} \end{bmatrix} \cdot \begin{bmatrix} 1 \\ y_j \\ \vdots \\ y^{l-1}_j \end{bmatrix}$$."/>
    <outline text="Here $$B = V_x A - A V_y$$. "/>
</outline>
                            </outline>
                            <outline text="Share Creation #slide #arman">
<outline text="Each player $$P_i$$ has public value $$x_i$$."/>
<outline text="A public value $$y_j$$ is associated with $$Q_j$$."/>
<outline text="The shares distributed to the players in $$\mathcal{P}$$ and  $$\mathcal{Q}$$ are as follows:">
    <outline text="$$P_i$$ receives the row vector $$\begin{bmatrix} b_{i0} &amp; b_{i1} &amp; \dots &amp; b_{in} \end{bmatrix}$$."/>
    <outline text="$$Q_j$$ receives the column vector $$\begin{bmatrix} b_{0j} \\ b_{1j} \\ \vdots \\ b_{nj} \end{bmatrix}$$."/>
</outline>
                            </outline>
                            <outline text="Share Reconstruction #slide #arman ">
<outline text="In order to reconstruct $$f$$, a coalition of $$k$$ players $$\{P_{i_1},...,P_{i_k}\}$$ and $$l$$ players $$\{Q_{j_i}, ..., Q_{j_l}\}$$ proceed as follows:">
    <outline text="The first coalition constructs the matrix $$V{(x_{i_1},...,x_{i_k})}$$."/>
    <outline text="The second coalition forms the matrix $$V^t{(y_{j_1}, ..., y_{j_l})}$$."/>
    <outline text="Together, they build the matrix $$W(k,l) = \begin{bmatrix} b_{i_1,j_1} &amp; b_{i_1,j_2} &amp; \dots &amp; b_{i,j_l} \\ b_{i_2,j_1} &amp; b_{i_2,j_2} &amp; \dots &amp;b_{i_2,j_l} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ b_{i_k,j_1} &amp; b_{i_k,j_2} &amp; \dots &amp; b_{i_k,j_l}\end{bmatrix}$$. "/>
    <outline text="They find the unique solution of the Sylvester equation $$V{(x_{i_1}, ..., x_{i_k})} F - F V^t{(y_{i_1}, ..., y_{i_l})} = W(k,l)$$."/>
</outline>
                            </outline>
                            <outline text="Example #h">
<outline text="Parameters #slide ">
    <outline text="$$k = 2$$"/>
    <outline text="$$l = 3$$"/>
    <outline text="$$A = \begin{bmatrix}15 &amp; 10 &amp; 5\\1 &amp; 2 &amp; 3 \end{bmatrix}$$"/>
    <outline text="$$V{(x_1, x_2)} = \begin{bmatrix}1 &amp; 1 \\1 &amp; 2\end{bmatrix}$$, $$V{(y_1,y_2,y_3)}^T = \begin{bmatrix}1 &amp; 1 &amp; 1\\1 &amp; 2 &amp; 3 \\1 &amp; 4 &amp; 9\end{bmatrix}$$"/>
</outline>
<outline text="Share Creation #slide ">
    <outline text="Calculation of $$B = V{(x_1,x_2)}  A - A  V{(y_1,y_2,y_3)} = ((b_{ij}))$$:">
        <outline text="$$b_{1,1} = \begin{bmatrix}1 &amp; 1\end{bmatrix}  \begin{bmatrix}15 \\ 1 \end{bmatrix} - \begin{bmatrix}15 &amp; 10 &amp; 5 \end{bmatrix}  \begin{bmatrix} 1 \\ 1 \\ 1 \end{bmatrix} = -14$$ "/>
        <outline text="$$b_{2,1} = \begin{bmatrix} 1 &amp; 2 \end{bmatrix}  \begin{bmatrix} 15 \\ 1 \end{bmatrix} - \begin{bmatrix}1 &amp; 2 &amp; 3\end{bmatrix}  \begin{bmatrix}1 \\ 1 \\ 1 \end{bmatrix} = 11$$"/>
        <outline text="$$b_{1,2} = \begin{bmatrix}1 &amp; 1\end{bmatrix}  \begin{bmatrix} 10 \\ 2 \end{bmatrix} - \begin{bmatrix}15 &amp; 10 &amp; 5\end{bmatrix}  \begin{bmatrix} 1 \\ 2 \\ 4 \end{bmatrix} = -43$$"/>
        <outline text="$$b_{2,2} = \begin{bmatrix}1 &amp; 2\end{bmatrix}  \begin{bmatrix} 10 \\ 2\end{bmatrix} - \begin{bmatrix}1 &amp; 2 &amp; 3\end{bmatrix}  \begin{bmatrix}1 \\ 2 \\ 4 \end{bmatrix} = -3$$"/>
        <outline text="$$b_{1,3} = \begin{bmatrix}1 &amp; 1\end{bmatrix}  \begin{bmatrix}5 \\ 3\end{bmatrix} - \begin{bmatrix}1 &amp; 2 &amp; 3\end{bmatrix}  \begin{bmatrix}1 \\ 3 \\ 9\end{bmatrix} = -23$$"/>
        <outline text="$$b_{2,3} = \begin{bmatrix}1 &amp; 2\end{bmatrix}  \begin{bmatrix} 5 \\ 3\end{bmatrix} - \begin{bmatrix}1 &amp; 2 &amp; 3\end{bmatrix}  \begin{bmatrix}1 \\ 3 \\ 9 \end{bmatrix} = -23$$"/>
        <outline text="$$\therefore B = \begin{bmatrix} -14 &amp; -43 &amp; -82 \\ 11 &amp; -3 &amp; -23 \end{bmatrix} = \begin{bmatrix} b_{1,1} &amp; b_{1,2} &amp; b_{1,3} \\ b_{2,1} &amp; b_{2,2} &amp; b_{2,3} \end{bmatrix}$$"/>
    </outline>
</outline>
<outline text="Secret Recovery #slide  ">
    <outline text="Objective">
        <outline text="$$vec(A) = (I_l \otimes V{(x_1, x_2)} - V{(y_1, y_2, y_3)}^T \otimes I_k)^{-1} \cdot vec(B)^T$$"/>
        <outline text="$$vec(B) = \begin{bmatrix} b_{1,1} &amp; b_{2,1} &amp; b_{1,2} &amp; b_{2,2} &amp; b_{1,3} &amp; b_{2,3}\end{bmatrix}$$"/>
    </outline>
    <outline text="Calculation">
        <outline text="$$vec(B) = \begin{bmatrix} -14 &amp; 11 &amp; -43 &amp; -3 &amp; -82 - 23\end{bmatrix}$$"/>
        <outline text="$$vec(A) = \begin{bmatrix} 0 &amp; 1 &amp; -1 &amp; 0 &amp; -1 &amp; 0 \\ 1 &amp; 1 &amp; 0 &amp; -1 &amp; 0 &amp; -1 \\ -1 &amp; 0 &amp; -1 &amp; 1 &amp; -4 &amp; 0\\ 0  &amp; -1 &amp; 1 &amp; 0 &amp; 0 &amp; -4\\-1 &amp; 0 &amp; -3 &amp; 0 &amp; -8 &amp; 1 \\ 0 &amp; -1 &amp; 0 &amp; -3 &amp; 1 &amp; -7\end{bmatrix}^{-1} \cdot \begin{bmatrix} -14 \\ 11 \\ -43 \\ -3 \\ -82 \\ -23\end{bmatrix} = \begin{bmatrix} 15 \\ 1 \\ 10 \\ 2 \\ 5 \\ 3 \end{bmatrix}$$"/>
    </outline>
</outline>
                            </outline>
                        </outline>
                    </outline>
                </outline>
                <outline text="References #slide #arman ">
                    <outline text="#bivariate ">
                        <outline text="Rafail Ostrovsky, Amit Sahai, Brent Waters - &quot;Attribute-Based Encryption with Non-Monotonic Access Structures&quot;"/>
                        <outline text="https://en.wikipedia.org/wiki/Access_structure"/>
                        <outline text="==="/>
                        <outline text="Yang, C. N., &amp; Lai, J. Bin. (2013). Protecting data privacy and security for cloud computing based on secret sharing. In Proceedings - 2013 International Symposium on Biometrics and Security Technologies, ISBAST 2013. https://doi.org/10.1109/ISBAST.2013.46"/>
                        <outline text="Zhang, F., Zhang, Y., Maram, S. K. D., Wang, L., Juels, A., Low, A., &amp; Song, D. (2019). ChURP: Dynamic-committee proactive secret sharing. In Proceedings of the ACM Conference on Computer and Communications Security. https://doi.org/10.1145/3319535.3363203"/>
                        <outline text="Liu, Y., Yang, C., Wang, Y., Zhu, L., &amp; Ji, W. (2018). Cheating identifiable secret sharing scheme using symmetric bivariate polynomial. Information Sciences. https://doi.org/10.1016/j.ins.2018.04.043 #bivariate"/>
                        <outline text="Harn, L., &amp; Hsu, C. F. (2017). (t, n) Multi-Secret Sharing Scheme Based on Bivariate Polynomial. Wireless Personal Communications. https://doi.org/10.1007/s11277-016-3862-z #bivariate "/>
                        <outline text="O’Brien, T. F., Bommaraju, T. V., Hine, F., O’Brien, T. F., Bommaraju, T. V., &amp; Hine, F. (2005). Chemistry and Electrochemistry of the Chlor-Alkali Process. In Handbook of Chlor-Alkali Technology. https://doi.org/10.1007/0-306-48624-5_4"/>
                        <outline text="Harn, L., &amp; Hsu, C. F. (2015). Dynamic threshold secret reconstruction and its application to the threshold cryptography. Information Processing Letters. https://doi.org/10.1016/j.ipl.2015.06.014"/>
                        <outline text="Yang, C. N., Lai, J. Bin, &amp; Fu, Z. (2015). Protecting user privacy for cloud computing by bivariate polynomial based secret sharing. Journal of Computing and Information Technology. https://doi.org/10.2498/cit.1002593 #bivariate"/>
                        <outline text="Goldberg, I., Jenkinson, G., &amp; Stajano, F. (2016). Low-cost mitigation against cold boot attacks for an authentication token. In Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics). https://doi.org/10.1007/978-3-319-39555-5_3"/>
                        <outline text="Asharov, G., Lindell, Y., &amp; Rabin, T. (2011). Perfectly-secure multiplication for any t &lt; n/3. In Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics). https://doi.org/10.1007/978-3-642-22792-9_14"/>
                        <outline text="Wang, Z., Liu, Y., Yan, W., Wei, W., Li, J., Zhang, D., &amp; Alfandi, O. (2014). Cheating detection and cheater identification in (t, n) secret sharing scheme. Computer Systems Science and Engineering."/>
                        <outline text="Saxena, N., &amp; Yi, J. H. (2009). Noninteractive self-certification for long-lived mobile ad hoc networks. IEEE Transactions on Information Forensics and Security. https://doi.org/10.1109/TIFS.2009.2031946"/>
                        <outline text="Saxena, N., Tsudik, G., &amp; Yi, J. H. (2009). Efficient Node Admission and Certificateless Secure Communication in Short-Lived MANETs. IEEE Transactions on Parallel and Distributed Systems. https://doi.org/10.1109/TPDS.2008.77"/>
                        <outline text="Nojoumian, M. (2016). Unconditionally secure proactive verifiable secret sharing using new detection and recovery techniques. In 2016 14th Annual Conference on Privacy, Security and Trust, PST 2016. https://doi.org/10.1109/PST.2016.7906973"/>
                        <outline text="N, C. K., Basit, A., Singh, P., V. Ch., V., &amp; Y. V, S. R. (2017). Node Authentication Using BLS Signature in Distributed PKI Based MANETs. International Journal of Network Security &amp; Its Applications. https://doi.org/10.5121/ijnsa.2017.9403"/>
                        <outline text="Chengli, Z., &amp; Chunming, T. (2011). An efficient threshold signature scheme. In TEIN 2011 - 2011 2nd ETP/IITA Conference on Telecommunication and Information. https://doi.org/10.14569/ijacsa.2012.030116"/>
                        <outline text="Wang, X., Xiang, C., &amp; Fu, F. W. (2017). Secret sharing schemes for compartmented access structures. Cryptography and Communications. https://doi.org/10.1007/s12095-016-0205-6"/>
                        <outline text="Zhang, B., Xu, Q., Jiang, H., &amp; Zhao, X. (2012). Research on the round complexity of vss in the information theory model. International Journal of Digital Content Technology and Its Applications. https://doi.org/10.4156/jdcta.vol6.issue8.6"/>
                        <outline text="Tang, D., &amp; Shu, H. (2012). A new secret sharing scheme based on bivariate polynomial. Advanced Science Letters. https://doi.org/10.1166/asl.2012.2665 #bivariate"/>
                        <outline text="Tang, D., &amp; Huang, J. (2012). Secret image sharing scheme based on bivariate polynomial. In Proceeding of 2012 International Conference on Uncertainty Reasoning and Knowledge Engineering, URKE 2012. https://doi.org/10.1109/URKE.2012.6319543 #bivariate"/>
                        <outline text="Tartary, C., Wang, H., &amp; Zhang, Y. (2011). An efficient and information theoretically secure rational secret sharing scheme based on symmetric bivariate polynomials. International Journal of Foundations of Computer Science. https://doi.org/10.1142/S0129054111008775 #bivariate"/>
                        <outline text="Tassa, T., &amp; Dyn, N. (2009). Multipartite secret sharing by bivariate interpolation. Journal of Cryptology. https://doi.org/10.1007/s00145-008-9027-9 #bivariate "/>
                        <outline text="Tassa, T., &amp; Dyn, N. (2006). Multipartite secret sharing by bivariate interpolation. In Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics). https://doi.org/10.1007/11787006_25 #bivariate"/>
                        <outline text="Liu, Y., Zhang, Y., &amp; Hu, Y. (2012). Efficient (t, n) secret sharing scheme against cheating. Journal of Computational Information Systems."/>
                        <outline text="Wang, X., Fu, F. W., &amp; Guang, X. (2016). Probabilistic secret sharing schemes for multipartite access structures. IEICE Transactions on Fundamentals of Electronics, Communications and Computer Sciences. https://doi.org/10.1587/transfun.E99.A.856"/>
                        <outline text="4th International Conference on Science &amp; Engineering in Mathematics, Chemistry and Physics 2016 (ScieTech 2016). (2017). Journal of Physics: Conference Series. https://doi.org/10.1088/1742-6596/820/1/011001"/>
                        <outline text="Ji, W., Zhu, L., Wang, Y., Liu, Z., &amp; Hei, X. (2019). RSU authentication in vehicular ad hoc networks base on verifiable secret sharing. Journal of Intelligent and Fuzzy Systems. https://doi.org/10.3233/JIFS-179286"/>
                        <outline text="Lin, C., Yan, X., Niu, Q., &amp; Hu, H. (2019). Cheating immune multi-secret sharing without predefined order of secrets. Journal of the Chinese Institute of Engineers, Transactions of the Chinese Institute of Engineers,Series A/Chung-Kuo Kung Ch’eng Hsuch K’an. https://doi.org/10.1080/02533839.2018.1537806"/>
                        <outline text="@Simmons"/>
                        <outline text="@Brickell"/>
                    </outline>
                </outline>
                <outline text="Access Structures #slide #arman">
                    <outline text="The family $$\Gamma  \subset 2^\mathcal{P}$$ of authorised sets is called an __access structure__."/>
                    <outline text="Given a set of users/players $$\mathcal{P} = \{{P}_1, \ldots , {P}_n\}$$, the family $$\Gamma$$ of __authorized sets__ is the __access structure__ of the secret sharing scheme."/>
                    <outline text="Example: Have 3 Parties, $$P_1 , P_2, P_3$$ that participate in a secret sharing scheme with threshold $$k$$ of 2 means that Parties $$\{P_1, P_2\}$$ or $$\{P_2, P_3\}$$ or $$\{P_1 , P_3\}$$ or even $$\{P_1, P_2, P_3\}$$ can recover the secret but no less than $$k$$."/>
                </outline>
                <outline text="Monotonic Access Structures #slide #arman ">
                    <outline text="Let again denote $$\mathcal{P} =\{P_1, P_2, ...,P_n\}$$ be a set of parties."/>
                    <outline text="A collection $$\Gamma \subseteq 2^\mathcal{U}$$ __monotone__ if: $$\mathcal{V} \in \Gamma \text{ and } \mathcal{V} \subseteq \mathcal{W} \Rightarrow \mathcal{W} \in \Gamma $$.">
                        <outline text="An access structure (respectivily, monotonic access structure) is a collection (respectively, monotone collection) $$\Gamma$$ of non-empty subsets of $$\{P_1,P_2 ,..., P_n\}$$, i.e., $$\Gamma \subseteq 2^{\{P_1,P_2,...,P_n\}} \setminus \{\emptyset\}$$."/>
                    </outline>
                    <outline text="The sets in $$\Gamma$$ are called the authorised sets, and the sets not in $$\mathbb{A}$$ are called the unauthorised sets."/>
                </outline>
                <outline text="Compartmented Access Structures #slide #arman ">
                    <outline text="Let $$\mathcal{U}$$ be a set of participants and assume that it is partitioned into $$m$$ disjoint compartments:">
                        <outline text="$$\mathcal{U} = \bigcup^m_{i=1} \mathcal{C}_i$$ #label"/>
                    </outline>
                    <outline text="Denote $$\mathcal{C} = \{\mathcal{C}_1,...,\mathcal{C}_m \}$$ a partition of $$\mathcal{P}$$ into $$m$$ disjoint subsets, or __compartments__. "/>
                    <outline text="Access structure consists of all subsets containing at least $$t_i$$ participants from $$C_i$$ for $$1 \leq i \leq u$$, and a total of at least $$t$$ participants."/>
                    <outline text="Let $$t_i \in \mathbb{N}, 1 \leq i \leq m, \text{ and } t \in \mathbb{N}$$ be threshold $$\ni t \geq \sum^m_{i=1} t_i$$ ">
                        <outline text="where $$m$$ is the number of compartments and $$t$$ is the number of participants."/>
                    </outline>
                    <outline text="$$\Gamma = \{\mathcal{V} \subseteq \mathcal{U} : \exists \mathcal{V} \ni |\mathcal{W} \cap \mathcal{C}_i | \geq t_i, 1 \leq i \leq m, \text{ and } |\mathcal{W}| = t \}$$. ">
                        <outline text="The set of elements of $$\mathcal{V}$$ are also elements of $$\mathcal{U}$$."/>
                        <outline text="There exists a set $$\mathcal{V}$$ such that the number of elements that are in common with set $$\mathcal{W}$$ and $$\mathcal{C}_i$$ is greater than $$t_i$$. ">
                            <outline text="where $$\mathcal{C}_i$$ is a set of participants in a compartment and $$\mathcal{U}$$ is a set of all participants in all compartments?"/>
                        </outline>
                        <outline text="$$i$$ is not less than l or greater than $$m$$ and the number of elements in $$\mathcal{W}$$ is $$t$$. ">
                            <outline text="where $$m$$ is the number of compartments and $$t$$ is the number of participants."/>
                        </outline>
                        <outline text="So is subset of participants that are at least size $$t$$ ($$t$$ out of $$n$$?) which are authorised to recover their secret? "/>
                    </outline>
                </outline>
                <outline text="Multipartite Access Structures #slide #arman ">
                    <outline text="Let $$\Gamma \in 2^\mathcal{P}$$ be an compartmented access structure."/>
                    <outline text="An $$m$$-__partite__ (or __multipartite__) access structure on $$\mathcal{P}$$ with respect to partition $$\mathcal{C}$$ is any access structure that does not distinguish between members of the same compartment."/>
                    <outline text="Formally:">
                        <outline text="Assume that for all permutations $$\pi : \mathcal{P} \rightarrow \mathcal{P}$$ such that $$\pi(\mathcal{C}_i) =\mathcal{C_i}\;(1 \leq i \leq m), \;\mathcal{V} \in \Gamma$$ if and only if $$\pi(\mathcal{V}) \in \Gamma$$. "/>
                        <outline text="Then $$\Gamma$$ is called $$m$$-__partite__ or __multipartite__ with respect to partition $$\mathcal{C}$$."/>
                    </outline>
                    <outline text="Given any subset $$\mathcal{W} \subseteq \mathcal{U}$$, its $$\textit{type}$$ with respect to partition (1) is the vector $$(t_1,...,t_m) \in \mathbb{N}^m $$, where $$t_i = |\mathcal{W} \cap \mathcal{C}_i |, 1 \leq i \leq m.$$"/>
                </outline>
                <outline text="OLD">
                    <outline text="Access Structures #slide #arman">
                        <outline text="The family $$\Gamma  \subset 2^\mathcal{P}$$ of authorised sets is called an __access structure__."/>
                        <outline text="Given a set of users/players $$\mathcal{P} = \{{P}_1, \ldots , {P}_n\}$$, the family $$\Gamma$$ of __authorized sets__ is the __access structure__ of the secret sharing scheme."/>
                        <outline text="Example: Have 3 Parties, $$P_1 , P_2, P_3$$ that participate in a secret sharing scheme with threshold $$k$$ of 2 means that Parties $$\{P_1, P_2\}$$ or $$\{P_2, P_3\}$$ or $$\{P_1 , P_3\}$$ or even $$\{P_1, P_2, P_3\}$$ can recover the secret but no less than $$k$$."/>
                    </outline>
                    <outline text="Monotonic Access Structures #slide #arman ">
                        <outline text="Let again denote $$\mathcal{P} =\{P_1, P_2, ...,P_n\}$$ be a set of parties."/>
                        <outline text="A collection $$\Gamma \subseteq 2^\mathcal{U}$$ __monotone__ if: $$\mathcal{V} \in \Gamma \text{ and } \mathcal{V} \subseteq \mathcal{W} \Rightarrow \mathcal{W} \in \Gamma $$."/>
                        <outline text=" An access structure (respectivily, monotonic access structure) is a collection (respectively, monotone collection) $$\Gamma$$ of non-empty subsets of $$\{P_1,P_2 ,..., P_n\}$$, i.e., $$\Gamma \subseteq 2^{\{P_1,P_2,...,P_n\}} \setminus \{\emptyset\}$$."/>
                        <outline text="The sets in $$\Gamma$$ are called the authorised sets, and the sets not in $$\mathbb{A}$$ are called the unauthorised sets."/>
                    </outline>
                    <outline text="Compartmented Access Structures #slide #arman ">
                        <outline text="Let $$\mathcal{U}$$ be a set of participants and assume that it is partitioned into $$m$$ disjoint compartments:">
                            <outline text="$$\mathcal{U} = \bigcup^m_{i=1} \mathcal{C}_i$$ #label"/>
                        </outline>
                        <outline text="Denote $$\mathcal{C} = \{\mathcal{C}_1,...,\mathcal{C}_m \}$$ a partition of $$\mathcal{P}$$ into $$m$$ disjoint subsets, or __compartments__. "/>
                        <outline text="Access structure consists of all subsets containing at least $$t_i$$ participants from $$C_i$$ for $$1 \leq i \leq u$$, and a total of at least $$t$$ participants."/>
                        <outline text="Let $$t_i \in \mathbb{N}, 1 \leq i \leq m, \text{ and } t \in \mathbb{N}$$ be threshold $$\ni t \geq \sum^m_{i=1} t_i$$ ">
                            <outline text="where $$m$$ is the number of compartments and $$t$$ is the number of participants."/>
                        </outline>
                        <outline text="$$\Gamma = \{\mathcal{V} \subseteq \mathcal{U} : \exists \mathcal{V} \ni |\mathcal{W} \cap \mathcal{C}_i | \geq t_i, 1 \leq i \leq m, \text{ and } |\mathcal{W}| = t \}$$. ">
                            <outline text="The set of elements of $$\mathcal{V}$$ are also elements of $$\mathcal{U}$$."/>
                            <outline text="There exists a set $$\mathcal{V}$$ such that the number of elements that are in common with set $$\mathcal{W}$$ and $$\mathcal{C}_i$$ is greater than $$t_i$$. ">
<outline text="where $$\mathcal{C}_i$$ is a set of participants in a compartment and $$\mathcal{U}$$ is a set of all participants in all compartments?"/>
                            </outline>
                            <outline text="$$i$$ is not less than l or greater than $$m$$ and the number of elements in $$\mathcal{W}$$ is $$t$$. ">
<outline text="where $$m$$ is the number of compartments and $$t$$ is the number of participants."/>
                            </outline>
                            <outline text="So is subset of participants that are at least size $$t$$ ($$t$$ out of $$n$$?) which are authorised to recover their secret? "/>
                        </outline>
                    </outline>
                    <outline text="Multipartite Access Structures #slide #arman ">
                        <outline text="Let $$\Gamma \in 2^\mathcal{P}$$ be an compartmented access structure."/>
                        <outline text="An $$m$$-__partite__ (or __multipartite__) access structure on $$\mathcal{P}$$ with respect to partition $$\mathcal{C}$$ is any access structure that does not distinguish between members of the same compartment."/>
                        <outline text="Formally:">
                            <outline text="Assume that for all permutations $$\pi : \mathcal{P} \rightarrow \mathcal{P}$$ such that $$\pi(\mathcal{C}_i) =\mathcal{C_i}\;(1 \leq i \leq m), \;\mathcal{V} \in \Gamma$$ if and only if $$\pi(\mathcal{V}) \in \Gamma$$. "/>
                            <outline text="Then $$\Gamma$$ is called $$m$$-__partite__ or __multipartite__ with respect to partition $$\mathcal{C}$$."/>
                        </outline>
                        <outline text="Given any subset $$\mathcal{W} \subseteq \mathcal{U}$$, its $$\textit{type}$$ with respect to partition (1) is the vector $$(t_1,...,t_m) \in \mathbb{N}^m $$, where $$t_i = |\mathcal{W} \cap \mathcal{C}_i |, 1 \leq i \leq m.$$"/>
                    </outline>
                    <outline text="INBOX ">
                        <outline text="The set of elements of $$\mathcal{V}$$ are also elements of $$\mathcal{U}$$."/>
                        <outline text="There exists a set $$\mathcal{V}$$ such that the number of elements that are in common with set $$\mathcal{W}$$ and $$\mathcal{C}_i$$ is greater than $$t_i$$. ">
                            <outline text="where $$\mathcal{C}_i$$ is a set of participants in a compartment and $$\mathcal{U}$$ is a set of all participants in all compartments?"/>
                        </outline>
                        <outline text="$$i$$ is not less than l or greater than $$m$$ and the number of elements in $$\mathcal{W}$$ is $$t$$. ">
                            <outline text="where $$m$$ is the number of compartments and $$t$$ is the number of participants."/>
                        </outline>
                        <outline text="So is subset of participants that are at least size $$t$$ ($$t$$ out of $$n$$?) which are authorised to recover their secret? "/>
                        <outline text="The sets in $$\Gamma$$ are called the authorised sets, and the sets not in $$\mathbb{A}$$ are called the unauthorised sets.">
                            <outline text=" An access structure (respectivily, monotonic access structure) is a collection (respectively, monotone collection) $$\Gamma$$ of non-empty subsets of $$\{P_1,P_2 ,..., P_n\}$$, i.e., $$\Gamma \subseteq 2^{\{P_1,P_2,...,P_n\}} \setminus \{\emptyset\}$$."/>
                        </outline>
                    </outline>
                </outline>
            </outline>
            <outline text="CRYPTO">
                <outline text="Cryptography">
                    <outline text="Protocols">
                        <outline text="Secret Sharing">
                            <outline text="Compartments">
<outline text="Some Ideal Secret Sharing Schemes - Ernest F. Brickell"/>
<outline text="Notes 1">
    <outline text="Set $$\Gamma$$ of subsets of participants with the property that any subset of participants that is in $$\Gamma$$ can determine the secret."/>
    <outline text="Compartmented Access Structures have different compartments $$C_1, ..., C_u$$ and positive integers $$t_1, ..., t_u$$ and $$t$$."/>
    <outline text="Access structure consists of all subsets containing at least $$t_i$$ participants from $$C_i$$ for $$1 \leq i \leq u$$, and a total of at least $$t$$ participants."/>
    <outline text="Original notion had $$t = \sum^{u}_{i=1} t_i$$"/>
</outline>
<outline text="Notes 2">
    <outline text="Let $$\mathcal{U} = \{ u_1,...,u_n \}$$ be the underlying set of participants and $$\mathcal{P} = \{\mathcal{C}_1,...,\mathcal{C}_m \}$$ be a partition of $$\mathcal{U}$$ into $$m$$ disjoint subsets, or $$\textit{compartments}$$, an $$m$$-partite (or multipartite) access structure on $$\mathcal{U}$$ with respect to partition $$\mathcal{P}$$ is any access structure that does not distinguish between members of the same compartment."/>
    <outline text="A collection $$\Gamma \subseteq 2^\mathcal{U}$$ is monotone if $$\mathcal{V} \in \Gamma \text{ and } \mathcal{V} \subseteq \mathcal{W} \Rightarrow \mathcal{W} \in \Gamma $$."/>
</outline>
<outline text="Notes 3">
    <outline text="Multipartite Access Structures">
        <outline text="Let $$\mathcal{U}$$ be a set of participants and assume that it is partitioned into $$m$$ disjoint compartments, ">
            <outline text="$$\mathcal{U} = \bigcup^m_{i=1} \mathcal{C}_i$$ (1)"/>
        </outline>
        <outline text="Let $$\Gamma \in 2^\mathcal{U}$$ be an access structure on $$\mathcal{U}$$ and assume that for all permutations $$\pi : \mathcal{U} \rightarrow \mathcal{U}$$ such that $$\pi(C_i) =\mathcal{C_i}, 1 \leq i \leq m, \mathcal{V} \in \Gamma$$ if and only if $$\pi(\mathcal{V}) \in \Gamma$$. Then $$\Gamma$$ is called $$m$$-partite or multipartite with respect to partition (1)."/>
        <outline text="$$\mathbb{N}$$ unsigned integer."/>
        <outline text="Given any subset $$\mathcal{W} \subseteq \mathcal{U}$$, its $$\textit{type}$$ with respect to partition (1) is the vector $$(t_1,...,t_m) \in \mathbb{N}^m $$, where $$t_i = |\mathcal{W} \cap \mathcal{C}_i |, 1 \leq i \leq m.$$  "/>
    </outline>
    <outline text="Compartmented Access Structures">
        <outline text="Access structure consists of all subsets containing at least $$t_i$$ participants from $$C_i$$ for $$1 \leq i \leq u$$, and a total of at least $$t$$ participants."/>
        <outline text="Let $$t_i \in \mathbb{N}, 1 \leq i \leq m, \text{ and } t \in \mathbb{N}$$ be threshold $$\ni t \geq \sum^m_{i=1} t_i$$">
            <outline text="where $$m$$ is the number of compartments and $$t$$ is the number of participants."/>
        </outline>
        <outline text="$$\Gamma = \{\mathcal{V} \subseteq \mathcal{U} : \exists \mathcal{V} \ni |\mathcal{W} \cap \mathcal{C}_i | \geq t_i, 1 \leq i \leq m, \text{ and } |\mathcal{W}| = t \}$$.">
            <outline text="The set of elements of $$\mathcal{V}$$ are also elements of $$\mathcal{U}$$."/>
            <outline text="There exists a set $$\mathcal{V}$$ such that the number of elements that are in common with set $$\mathcal{W}$$ and $$\mathcal{C}_i$$ is greater than $$t_i$$.">
                <outline text="where $$\mathcal{C}_i$$ is a set of participants in a compartment and $$\mathcal{U}$$ is a set of all participants in all compartments? ref (1)"/>
            </outline>
            <outline text="$$i$$ is not less than l or greater than $$m$$ and the number of elements in $$\mathcal{W}$$ is $$t$$. ">
                <outline text="where $$m$$ is the number of compartments and $$t$$ is the number of participants."/>
            </outline>
            <outline text="So is subset of participants that are at least size $$t$$ ($$t$$ out of $$n$$?) which are authorised to recover their secret? "/>
        </outline>
    </outline>
</outline>
<outline text="Notes 4">
    <outline text="Access Structure">
        <outline text="Extended Access Structures and Their Cryptographic Applications"/>
        <outline text="In secret sharing schemes a secret is distributed among a set of users $$\mathcal{P}$$ in such a way that only some sets, the authorised sets, can recover it. The family $$\Gamma$$ of authorised sets is called access structure."/>
        <outline text="Secret sharing schemes are useful for not trusting a single party e.g. two members of staff required to open a vault. Similar challenges can arise in other sensitive areas where a secret should be recovered only if certain users, the authorised sets, get together. Given a set of users $$\mathcal{P} = \{\mathcal{R}_1, ... , \mathcal{R}_n\}$$, the family $$\Gamma \subset 2^\mathcal{P}$$ of authorized sets is the access structure of the secret sharing scheme."/>
        <outline text="See also: https://en.wikipedia.org/wiki/Access_structure"/>
    </outline>
</outline>
<outline text="Notes 5">
    <outline text="Monotone Span Programs">
        <outline text="Similar to Shamir's Secret Sharing, Monotone Span Programs (MSP)"/>
        <outline text="Access structure is a Boolean predicate on a set of users that are allowed to recover the secret. A monotone access structure is similar in a way that adding a user to a set will not change the predicate's output from true to false."/>
        <outline text="For example '(A || B) &amp;&amp; C == true' is fine but '(A || B) &amp;&amp; !C == false' is disallowed.  "/>
        <outline text="Suitable for Distributed Commitments, Verifiable Secret Sharing and Multi-party computation."/>
        <outline text="https://github.com/Bren2010/msp"/>
    </outline>
</outline>
<outline text="Notes 6">
    <outline text="The advantage of bivariate interpolation over the standard univariate one in designing linear secret sharing schemes for multipartite settings is in the ability to associate different compartments with different lines in the plane."/>
    <outline text="Bivariate interpolation on lines was extended to multivariate interpolation on flats in several dimensions in &quot;Polynomial interpolation to data on flats in $$\mathbb{R}^d$$&quot;."/>
    <outline text="By going to higher dimensions and by adequately choosing the flats that represent the compartments, it might be possible to design secret sharing schemes for a wide array of interesting access structures. (In several dimensions, we have more flexibility in choosing dimensions of the flats and their interrelation.)"/>
</outline>
                            </outline>
                        </outline>
                    </outline>
                </outline>
            </outline>
            <outline text="SCENARIOS #h #slide">
                <outline text="Cyber Evidence Intelligence Signalling">
                    <outline text="Scenarios #h">
                        <outline text="Secure Distribution of Fraud Investigation Outcomes #h">
                            <outline text="Players:">
<outline text="A number $$m$$ of banks, a trusted Data Mining Controller (DMC)"/>
                            </outline>
                            <outline text="Assumptions:">
<outline text="Banks do not trust each other (they are competitive)"/>
<outline text="They all trust the DMC (Trusted Third Party)"/>
                            </outline>
                            <outline text="Setup:">
<outline text="All banks to securely send transaction data to DMC"/>
<outline text="This is a secure transmission tunnel"/>
<outline text="DMC analyses data using privacy preserving algorithm"/>
                            </outline>
                            <outline text="Goal: ">
<outline text="To distribute result data to $$n\le m$$ banks, using secret sharing threshold scheme. These are the banks involved in a series of connected fraudulous transactions."/>
                            </outline>
                            <outline text="Protocol approach:">
<outline text="DMC acts as a dealer and computes shares $$t_1,\ldots,t_n$$, using a $$(k,n)$$-threshold scheme."/>
<outline text="Shares are sent securely to each bank"/>
                            </outline>
                            <outline text="Advantages:">
<outline text="No individual bank has access to results (which contain sensitive info about each other's transaction data)"/>
<outline text="This prevents a bank to leak information about competitors "/>
<outline text="A coalition of $$k$$ banks need to cooperate in order to find out results"/>
<outline text="Each bank can then address this (quickly, before any potential leakage at this stage)"/>
                            </outline>
                            <outline text="Challenges:">
<outline text="What if connection to DMC has low bandwidth/speed (could be manual)?"/>
<outline text="What if we don't have a DMC?"/>
                            </outline>
                            <outline text="Research Questions:">
<outline text="Can we set up a specific bank-to-bank communication network architecture to benefit from the protocol in [Shah et al]?"/>
<outline text="Can we extend [Shah et al] to include verification of shares, or dealer-free secret sharing?"/>
                            </outline>
                        </outline>
                        <outline text="Money Laundering #h">
                            <outline text="Players/Actors">
<outline text="Banks"/>
<outline text="Legitimate Account Holders"/>
<outline text="Suspicious/Coerced Account Holders"/>
                            </outline>
                            <outline text="Objectives">
<outline text="Maintain information confidentiality and integrity"/>
<outline text="Facilitate for the collection and categorization of data in a confidential state"/>
<outline text="Entities involve receive updates on detections"/>
                            </outline>
                            <outline text="Type - **Relationship Detection**"/>
                            <outline text="High Level Description">
<outline text="Suspicious series of transactions linked to each other are detected when a certain number of them exist within a time frame. Transactions that have relationships are put together where once a threshold is reached, the relevant entities that contributed are notified and may verify information. Relationship can occur when transactions have sender and recipient pattern that matches. All information sent from clients is in a confidential state."/>
                            </outline>
                            <outline text="Used Techniques:">
<outline text="[NI Fiat-Shamir Heuristic](https://dynalist.io/d/riJBQwEAtmmlbif-Yp3cjXr-#z=QP4OiDhkBWI1881wboS3JeUQ)"/>
<outline text="[Bloom Filter](https://dynalist.io/d/riJBQwEAtmmlbif-Yp3cjXr-#z=X-y9UmXsegQxdghORH166CIV)"/>
<outline text="[RAPPOR](https://dynalist.io/d/riJBQwEAtmmlbif-Yp3cjXr-#z=8jCUb9EorKzREc8r34D36LL4)"/>
                            </outline>
                        </outline>
                        <outline text="Speeding #h">
                            <outline text="Players/Actors:">
<outline text="Drivers"/>
<outline text="Authorities"/>
                            </outline>
                            <outline text="Objectives:">
<outline text="Share information in a confidential state where relationships between such data can be detected."/>
<outline text="Apply a threshold to the number of detections which will flag re-occurring information."/>
                            </outline>
                            <outline text="Type - **Relationship Detection**"/>
                            <outline text="High-Level Description:">
<outline text="A series of cameras record the number plate and speed of cars violating road safety. Once a threshold of detections have been reached in a period of time, the number plate will be flagged for speeding."/>
                            </outline>
                            <outline text="Used Techniques:">
<outline text="[Pedersen Commitment](https://dynalist.io/d/riJBQwEAtmmlbif-Yp3cjXr-#z=R_jgdIFKFjXiwKsw7QMZ84Ah)"/>
<outline text="[NI Fiat-Shamir Heuristic](https://dynalist.io/d/riJBQwEAtmmlbif-Yp3cjXr-#z=QP4OiDhkBWI1881wboS3JeUQ)"/>
                            </outline>
                        </outline>
                        <outline text="Reckless Driver #h">
                            <outline text="Players/Actors:">
<outline text="Reckless Drivers"/>
<outline text="Conforming Drivers"/>
                            </outline>
                            <outline text="Objectives:">
<outline text="Apply security objectives of confidentiality and integrity."/>
<outline text="Submit information in a confidential state where other entities may find relationships."/>
<outline text="Client side detection of the raw information and comparing it with encrypted input allows events to trigger."/>
                            </outline>
                            <outline text="Type - **Relationship Detection**">
<outline text="Drivers install dashcams that can read number plates. Once  a driver finds a reckless driver, they can use the dashcam to submit a report. Once a number of reports for a certain number plate has been reached within a time frame, drivers that encounter the number plate with detection from the dashcam will be notified."/>
                            </outline>
                            <outline text="Used Techniques:">
<outline text="[Pedersen Commitment](https://dynalist.io/d/riJBQwEAtmmlbif-Yp3cjXr-#z=R_jgdIFKFjXiwKsw7QMZ84Ah)"/>
<outline text="[NI Fiat-Shamir Heuristic](https://dynalist.io/d/riJBQwEAtmmlbif-Yp3cjXr-#z=QP4OiDhkBWI1881wboS3JeUQ)"/>
                            </outline>
                        </outline>
                        <outline text="Suspect Protection #h">
                            <outline text="Players/Actors:">
<outline text="Potential Suspect"/>
<outline text="Authority"/>
<outline text="Accusers"/>
                            </outline>
                            <outline text="Objectives:">
<outline text="Protect the identity of the suspect until sufficient evidence has been put forth."/>
<outline text="Allow accusers to prove the identity of the accuser without revealing information."/>
<outline text="WHile the suspect is protected evidence is sent as commitments."/>
<outline text="Once the suspect has had the identity proof completed a number of times, evidence can be revealed and verified by commitments."/>
                            </outline>
                            <outline text="Types - **Relationship Detection**"/>
                            <outline text="High-Level Description:">
<outline text="A suspect has their identity kept confidential to prevent situations of guilty before proven innocent. Accusers can submit evidence relating to the suspect where once enough is gathered, the suspect will be identifiable."/>
                            </outline>
                            <outline text="Used Techniques:">
<outline text="[Pedersen Commitment](https://dynalist.io/d/riJBQwEAtmmlbif-Yp3cjXr-#z=R_jgdIFKFjXiwKsw7QMZ84Ah)"/>
<outline text="[NI Fiat-Shamir Heuristic](https://dynalist.io/d/riJBQwEAtmmlbif-Yp3cjXr-#z=QP4OiDhkBWI1881wboS3JeUQ)"/>
                            </outline>
                        </outline>
                        <outline text="Parenting Progress #h">
                            <outline text="Players/Actors:">
<outline text="Parents"/>
<outline text="Medical Consultants"/>
                            </outline>
                            <outline text="Objectives:">
<outline text="Periodically ask parents for short pieces of information on the development of their child."/>
<outline text="Securely store these responses for a later date."/>
<outline text="Allow parents to consent to revealing these responses."/>
                            </outline>
                            <outline text="Type - **Verification**"/>
                            <outline text="High-Level Description:">
<outline text="&quot;During medical consultations, parents are sometimes queried about their child's early development, several years ago e.g. &quot;at their second birthday,how many words were they using&quot; or &quot;when did they first properly walk up the stairs&quot;. Parents' recollections may be inaccurate. Make a prototype system that sends the parents a couple of text messages a week/month, asking for one-word responses, to be securely stored and then later made available to parents and also to medical departments, only if parents provide explicit consent.&quot; - Daren Gates"/>
                            </outline>
                            <outline text="Used techniques:">
<outline text="[Pedersen Commitment](https://dynalist.io/d/riJBQwEAtmmlbif-Yp3cjXr-#z=R_jgdIFKFjXiwKsw7QMZ84Ah)"/>
                            </outline>
                        </outline>
                        <outline text="Warhead Realisation #h ">
                            <outline text="Players/Actors:">
<outline text="Nation States"/>
                            </outline>
                            <outline text="Objectives:">
<outline text="Confidentiality is kept for the information that needs to be proved."/>
<outline text="The verified will have confidence that the prover knows the information that they didn't reveal."/>
<outline text="There cannot be an instance where false information can be verified."/>
                            </outline>
                            <outline text="Type - **Verification**"/>
                            <outline text="High-Level Description:">
<outline text="A state wants another to prove that they have some weapon capability. Properties of the technology or object may be verifiable if only both states have the mutual knowledge. If they don't they will not be able to infer any information."/>
                            </outline>
                            <outline text="Used Techniques:">
<outline text="[NI Fiat-Shamir Heuristic](https://dynalist.io/d/riJBQwEAtmmlbif-Yp3cjXr-#z=QP4OiDhkBWI1881wboS3JeUQ)"/>
                            </outline>
                        </outline>
                    </outline>
                </outline>
            </outline>
        </outline>
    </body>
</opml>
